(function(b,p){typeof exports=="object"&&typeof module<"u"?p(exports):typeof define=="function"&&define.amd?define(["exports"],p):(b=typeof globalThis<"u"?globalThis:b||self,p(b.ACGraphCore={}))})(this,function(b){"use strict";var _=Object.defineProperty;var G=(b,p,w)=>p in b?_(b,p,{enumerable:!0,configurable:!0,writable:!0,value:w}):b[p]=w;var y=(b,p,w)=>G(b,typeof p!="symbol"?p+"":p,w);class p{}class w extends p{isSubgraphIsomorphic(e,s,i=[],t=[],n=null){const r=e.adjacencyMatrix.length,o=s.adjacencyMatrix.length;if(r>o)return!1;n===null&&(n=new Array(r).fill(-1));const a=e.labels&&s.labels,c=Array(o).fill(!1),l=Array(r).fill(-1),d=new Set(i),u=new Set(t),[h,m,A,O]=this.getInOutDegrees(e,s),I=h.map((M,f)=>A.map((g,j)=>g>=M&&O[j]>=m[f]&&(n[f]===-1||n[f]===j)&&(!a||d.has(f)||e.labels[f]===s.labels[j])?j:-1).filter(g=>g!==-1)),P=M=>{if(M===r)return this.checkCompatibility(e,s,l,u);for(const f of I[M])if(!c[f]){if(l[M]=f,c[f]=!0,this.isFeasible(e,s,l,M,u)&&P(M+1))return!0;c[f]=!1,l[M]=-1}return!1};return P(0)}getInOutDegrees(e,s){const i=e.adjacencyMatrix.map(o=>o.reduce((a,c)=>a+c,0)),t=[],n=s.adjacencyMatrix.map(o=>o.reduce((a,c)=>a+c,0)),r=[];return e.adjacencyMatrix.forEach((o,a)=>{t.push(o.map((c,l)=>e.adjacencyMatrix[l][a]).reduce((c,l)=>c+l,0))}),s.adjacencyMatrix.forEach((o,a)=>{r.push(o.map((c,l)=>s.adjacencyMatrix[l][a]).reduce((c,l)=>c+l,0))}),[i,t,n,r]}findAllSubgraphMonomorphisms(e,s,i=[],t=[],n=null){const r=e.adjacencyMatrix.length,o=s.adjacencyMatrix.length,a=[],c=new Set(i),l=new Set(t);if(r>o)return a;n===null&&(n=new Array(r).fill(-1));const d=e.labels&&s.labels,u=Array(o).fill(!1),h=Array(r).fill(-1),[m,A,O,I]=this.getInOutDegrees(e,s),P=m.map((f,g)=>O.map((j,D)=>j>=f&&I[D]>=A[g]&&(n[g]===-1||n[g]===D)&&(!d||c.has(g)||e.labels[g]===s.labels[D])?D:-1).filter(j=>j!==-1)),M=f=>{if(f===r){this.checkCompatibility(e,s,h,l)&&a.push([...h]);return}for(const g of P[f])u[g]||(h[f]=g,u[g]=!0,this.isFeasible(e,s,h,f,l)&&M(f+1),u[g]=!1,h[f]=-1)};return M(0),a}isFeasible(e,s,i,t,n){const r=e.edgeLabels&&s.edgeLabels;for(let o=0;o<t;o++)if(e.adjacencyMatrix[t][o]&&(!s.adjacencyMatrix[i[t]][i[o]]||r&&!n.has(t+","+o)&&e.edgeLabels[t][o]!==s.edgeLabels[i[t]][i[o]])||e.adjacencyMatrix[o][t]&&(!s.adjacencyMatrix[i[o]][i[t]]||r&&!n.has(o+","+t)&&e.edgeLabels[o][t]!==s.edgeLabels[i[o]][i[t]]))return!1;return!0}checkCompatibility(e,s,i,t){const n=e.edgeLabels&&s.edgeLabels,r=e.adjacencyMatrix.length;for(let o=0;o<r;o++)for(let a=0;a<r;a++)if(e.adjacencyMatrix[o][a]&&(!s.adjacencyMatrix[i[o]][i[a]]||n&&!t.has(o+","+a)&&e.edgeLabels[o][a]!==s.edgeLabels[i[o]][i[a]]))return!1;return!0}}const K=Object.freeze(Object.defineProperty({__proto__:null,GraphMatcher:p,UllmannGraphMatcher:w},Symbol.toStringTag,{value:"Module"})),S=class S{constructor(e,s=S.DefaultNodeKeySuffixGenerator,i=S.DefaultNodePropertiesMapper,t=S.DefaultNodePropertiesCanonKeyMapper){y(this,"nodeCount");y(this,"hasNodeLabels");y(this,"hasNodeProperties");y(this,"hasEdgeLabels");y(this,"isSymmetric");y(this,"graph");y(this,"nodeNeighbors",new Map);y(this,"nodeKeys",new Map);y(this,"nodePropertiesMapper");y(this,"nodePropertiesCanonKeyMapper");y(this,"graphStringBuilder");this.graph=e,this.nodeCount=e.adjacencyMatrix.length,this.hasNodeLabels=e.labels!==void 0,this.hasNodeProperties=e.nodeProperties!==void 0,this.hasEdgeLabels=e.edgeLabels!==void 0,this.nodePropertiesMapper=i,this.nodePropertiesCanonKeyMapper=t;let n=!0;for(let r=0;r<this.nodeCount;r++){const o=new Set;let a=0,c=0;for(let d=0;d<this.nodeCount;d++){const u=e.adjacencyMatrix[r][d],h=e.adjacencyMatrix[d][r];u===1&&(c++,o.add(d)),h===1&&(a++,o.add(d)),u!==h&&(n=!1)}this.nodeNeighbors.set(r,[...o]);const l=c+"|"+a+"|"+s(e,r);this.nodeKeys.set(r,l)}this.isSymmetric=n,this.graphStringBuilder=this.buildGraphStringCurry()}canonicalize(){const e=new Array(this.nodeCount).fill(1);this.partitionByPropertyKeys(e);const s=new Map,i=new Set;this.individualizeDFS(e,[],i,this.handleRepresentationCurry(s,i));const t=[...s.keys()].sort((l,d)=>l.localeCompare(d))[0],n=s.get(t),r=new Array(this.nodeCount),o=new Array(r.length);[...n.partitions[0].entries()].forEach(([l,d])=>{r[d]=l,o[l-1]=d});const a=this.buildRepresentationGraph(r),c=new Map;return[...s.values()].forEach(l=>[...l.automorphisms.entries()].forEach(([d,u])=>c.set(d,u))),[a,this.buildGraphString(a),o,new E([...c.values()])]}handleRepresentationCurry(e,s){const i=Array.from({length:this.nodeCount},(t,n)=>n+1);return(t,n)=>{const r=new Map;t.forEach((c,l)=>r.set(c,l));const o=i.map(c=>this.nodeNeighbors.get(r.get(c)).map(l=>t[l]).sort().join(";")).join("|");let a=e.get(o);a===void 0&&(a={partitions:[],automorphisms:new Map},e.set(o,a));for(const c of a.partitions){const l=new Map;for(let u=0;u<t.length;u++){const h=c.get(t[u]);if(h!==u){const m=[h<u?h:u,u<h?h:u];l.set(m[0]+"|"+m[1],m)}}const d=new x([...l.values()]);a.automorphisms.set(d.toString(),d);for(const u of d.mappings)for(let h=0;h<n.length;h++)u.includes(n[h])&&u.filter(m=>m!=n[h]).forEach(m=>s.add([...n.slice(0,h),m].join("|")))}a.partitions.push(r)}}aut(){const e=new Array(this.nodeCount).fill(1);this.partitionByPropertyKeys(e);const s=new Map,i=new Set;this.individualizeDFS(e,[],i,this.handleRepresentationCurry(s,i));const t=new Map;return[...s.values()].forEach(n=>[...n.automorphisms.entries()].forEach(([r,o])=>t.set(r,o))),new E([...t.values()])}partitionByPropertyKeys(e){const s=new Map;for(let t=0;t<this.nodeCount;t++){const n=this.nodeKeys.get(t);s.has(n)?s.get(n).push(t):s.set(n,[t])}let i=1;Array.from(s.keys()).sort((t,n)=>t.localeCompare(n)).forEach(t=>{const n=s.get(t);n.forEach(r=>e[r]=i),i+=n.length})}isCanon(e){return new Set(e).size===this.nodeCount}individualizeDFS(e,s,i,t){if(this.isCanon(e)){t(e,s);return}if(this.individualizationRefinement(e),this.isCanon(e)){t(e,s);return}const n=this.getCellToBreak(e);for(const r of n[1])e[r]=n[0]+1;for(const r of n[1]){const o=[...s,r];i.has(o.join("|"))||(e[r]=n[0],this.individualizeDFS([...e],o,i,t),e[r]=n[0]+1)}}individualizationRefinement(e){let s=!1;for(;!s;){s=!0;const i=e.map((n,r)=>this.nodeNeighbors.get(r).map(a=>{if(this.hasEdgeLabels){const c=this.graph.edgeLabels;return this.isSymmetric?`${e[a]};${c[r][a]}`:`${e[a]};${c[r][a]};${c[a][r]}`}return e[a].toString()}).sort().join("|")),t=new Map;i.forEach((n,r)=>{const o=e[r];let a=t.get(o);a===void 0&&(a=new Map,t.set(o,a));let c=a.get(n);c===void 0&&(c=[],a.set(n,c)),c.push(r)});for(let n=1;n<=this.nodeCount;n++){const r=t.get(n);if(r===void 0||r.size<2)continue;s=!1;const o=[...r.keys()].sort((c,l)=>l.localeCompare(c));let a=n;for(const c of o){const l=r.get(c);l.forEach(d=>e[d]=a),a+=l.length}break}}}getCellToBreak(e){const s=Array.from({length:e.length},()=>[]);e.forEach((i,t)=>s[i-1].push(t));for(let i=0;i<s.length;i++)if(s[i].length>1)return[i+1,s[i]];return[1,s[0]]}buildRepresentationGraph(e){const s=e.map(t=>t-1),i={adjacencyMatrix:Array.from({length:this.nodeCount},()=>new Array(this.nodeCount))};if(this.isSymmetric)for(let t=0;t<this.nodeCount;t++){const n=s[t],r=this.graph.adjacencyMatrix[t];for(let o=t;o<this.nodeCount;o++)i.adjacencyMatrix[n][s[o]]=r[o],i.adjacencyMatrix[s[o]][n]=r[o]}else for(let t=0;t<this.nodeCount;t++){const n=s[t],r=this.graph.adjacencyMatrix[t];for(let o=0;o<this.nodeCount;o++)i.adjacencyMatrix[n][s[o]]=r[o]}if(this.hasNodeLabels&&(i.labels=new Array(this.nodeCount),s.forEach((t,n)=>i.labels[t]=this.graph.labels[n])),this.hasNodeProperties&&(i.nodeProperties=new Array(this.nodeCount),s.forEach((t,n)=>i.nodeProperties[t]=this.nodePropertiesMapper(this.graph,n,s))),this.hasEdgeLabels)if(i.edgeLabels=Array.from({length:this.nodeCount},()=>new Array(this.nodeCount)),this.isSymmetric)for(let t=0;t<this.nodeCount;t++){const n=s[t],r=this.graph.edgeLabels[t];for(let o=t;o<this.nodeCount;o++)i.edgeLabels[n][s[o]]=r[o],i.edgeLabels[s[o]][n]=r[o]}else for(let t=0;t<this.nodeCount;t++){const n=s[t],r=this.graph.edgeLabels[t];for(let o=0;o<this.nodeCount;o++)i.edgeLabels[n][s[o]]=r[o]}return i}buildGraphStringCurry(){const e=this.hasEdgeLabels?(t,n,r)=>`${n}-${t.edgeLabels[n][r]}-${r}`:(t,n,r)=>`${n}-${r}`,s=this.hasNodeProperties?(t,n)=>{const r=this.nodePropertiesCanonKeyMapper(t,n);return r.length>0?`{${r}}`:""}:(t,n)=>"",i=this.hasNodeLabels?t=>";"+t.labels.map((n,r)=>n+s(t,r)).join("|"):this.hasNodeProperties?t=>";"+t.nodeProperties.map((n,r)=>this.nodePropertiesCanonKeyMapper(t,r)).join("|"):t=>"";return this.isSymmetric?t=>{const n=[];for(let r=0;r<this.nodeCount;r++){const o=t.adjacencyMatrix[r];for(let a=r;a<this.nodeCount;a++)o[a]===1&&n.push(e(t,r,a))}return n.join("|")+i(t)}:t=>{const n=[];for(let r=0;r<this.nodeCount;r++){const o=t.adjacencyMatrix[r];for(let a=0;a<this.nodeCount;a++)o[a]===1&&n.push(e(t,r,a))}return n.join("|")+i(t)}}buildGraphString(e){return this.graphStringBuilder(e)}};y(S,"DefaultNodeKeySuffixGenerator",(e,s)=>e.labels?e.labels[s]:""),y(S,"DefaultNodePropertiesMapper",(e,s,i)=>e.nodeProperties&&e.nodeProperties[s]?new Map(e.nodeProperties[s]):void 0),y(S,"DefaultNodePropertiesCanonKeyMapper",(e,s)=>"");let v=S;const $=Object.freeze(Object.defineProperty({__proto__:null,GraphCanon:v},Symbol.toStringTag,{value:"Module"}));class z{static find(e){const s=[],i=new Set,t=(n,r)=>{i.add(n),r.push(n);for(let o=0;o<e.adjacencyMatrix.length;o++)(e.adjacencyMatrix[n][o]===1||e.adjacencyMatrix[o][n]===1)&&(i.has(o)||t(o,r))};for(let n=0;n<e.adjacencyMatrix.length;n++)if(!i.has(n)){const r=[];t(n,r),s.push(r)}return s}}const L=class L{constructor(e){y(this,"mappings");this.mappings=e}apply(e){for(const s of this.mappings){if(s[0]===e)return s[1];if(s[1]===e)return s[0]}return e}toString(){return this.mappings.map(e=>`(${e[0]} ${e[1]})`).join("")}};y(L,"Identity",new L([]));let x=L;class E{constructor(e){y(this,"generators");this.generators=[x.Identity,...e]}orbitOf(e){const s=new Set;s.add(e);for(const i of this.generators)s.add(i.apply(e));return Array.from(s).sort()}stabilizerOf(e){return this.generators.filter(s=>s.apply(e)===e)}stabilizerSizeOf(e){return this.generators.reduce((s,i)=>s+=i.apply(e)===e?1:0,0)}orbitSizeOf(e){return this.generators.length/this.stabilizerSizeOf(e)}orbits(e){const s=new Set,i=[];for(const t of e)if(!s.has(t)){const n=this.orbitOf(t);n.forEach(r=>s.add(r)),i.push(n)}return i}toString(){return"["+this.generators.map(e=>e.toString()).join(", ")+"]"}}function N(C){const e=C.adjacencyMatrix.length;let s=[];for(let i=0;i<e;i++)for(let t=i+1;t<e;t++)C.adjacencyMatrix[i][t]!==0&&s.push(`e ${i+1} ${t+1}`);return[`p edge ${e} ${s.length}`,...s].join(`
`)}const k=Object.freeze(Object.defineProperty({__proto__:null,Automorphism:x,AutomorphismGroup:E,ConnectedComponents:z,canon:$,matching:K,symmetricGraphToDIMACS:N},Symbol.toStringTag,{value:"Module"}));b.graph=k,Object.defineProperty(b,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=ac-graph-core-js.umd.cjs.map
