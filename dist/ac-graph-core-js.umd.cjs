(function(b,h){typeof exports=="object"&&typeof module<"u"?h(exports):typeof define=="function"&&define.amd?define(["exports"],h):(b=typeof globalThis<"u"?globalThis:b||self,h(b.ACGraphCore={}))})(this,function(b){"use strict";var _=Object.defineProperty;var v=(b,h,x)=>h in b?_(b,h,{enumerable:!0,configurable:!0,writable:!0,value:x}):b[h]=x;var u=(b,h,x)=>v(b,typeof h!="symbol"?h+"":h,x);class h{}class x extends h{isSubgraphIsomorphic(e,n,o=[],t=[],s=null){const i=e.adjacencyMatrix.length,r=n.adjacencyMatrix.length;if(i>r)return!1;s===null&&(s=new Array(i).fill(-1));const a=e.labels&&n.labels,c=Array(r).fill(!1),l=Array(i).fill(-1),f=new Set(o),g=new Set(t),[M,w,D,P]=this.getInOutDegrees(e,n),A=M.map((p,d)=>D.map((y,j)=>y>=p&&P[j]>=w[d]&&(s[d]===-1||s[d]===j)&&(!a||f.has(d)||e.labels[d]===n.labels[j])?j:-1).filter(y=>y!==-1)),S=p=>{if(p===i)return this.checkCompatibility(e,n,l,g);for(const d of A[p])if(!c[d]){if(l[p]=d,c[d]=!0,this.isFeasible(e,n,l,p,g)&&S(p+1))return!0;c[d]=!1,l[p]=-1}return!1};return S(0)}getInOutDegrees(e,n){const o=e.adjacencyMatrix.map(r=>r.reduce((a,c)=>a+c,0)),t=[],s=n.adjacencyMatrix.map(r=>r.reduce((a,c)=>a+c,0)),i=[];return e.adjacencyMatrix.forEach((r,a)=>{t.push(r.map((c,l)=>e.adjacencyMatrix[l][a]).reduce((c,l)=>c+l,0))}),n.adjacencyMatrix.forEach((r,a)=>{i.push(r.map((c,l)=>n.adjacencyMatrix[l][a]).reduce((c,l)=>c+l,0))}),[o,t,s,i]}findAllSubgraphMonomorphisms(e,n,o=[],t=[],s=null){const i=e.adjacencyMatrix.length,r=n.adjacencyMatrix.length,a=[],c=new Set(o),l=new Set(t);if(i>r)return a;s===null&&(s=new Array(i).fill(-1));const f=e.labels&&n.labels,g=Array(r).fill(!1),M=Array(i).fill(-1),[w,D,P,A]=this.getInOutDegrees(e,n),S=w.map((d,y)=>P.map((j,C)=>j>=d&&A[C]>=D[y]&&(s[y]===-1||s[y]===C)&&(!f||c.has(y)||e.labels[y]===n.labels[C])?C:-1).filter(j=>j!==-1)),p=d=>{if(d===i){this.checkCompatibility(e,n,M,l)&&a.push([...M]);return}for(const y of S[d])g[y]||(M[d]=y,g[y]=!0,this.isFeasible(e,n,M,d,l)&&p(d+1),g[y]=!1,M[d]=-1)};return p(0),a}isFeasible(e,n,o,t,s){const i=e.edgeLabels&&n.edgeLabels;for(let r=0;r<t;r++)if(e.adjacencyMatrix[t][r]&&(!n.adjacencyMatrix[o[t]][o[r]]||i&&!s.has(t+","+r)&&e.edgeLabels[t][r]!==n.edgeLabels[o[t]][o[r]])||e.adjacencyMatrix[r][t]&&(!n.adjacencyMatrix[o[r]][o[t]]||i&&!s.has(r+","+t)&&e.edgeLabels[r][t]!==n.edgeLabels[o[r]][o[t]]))return!1;return!0}checkCompatibility(e,n,o,t){const s=e.edgeLabels&&n.edgeLabels,i=e.adjacencyMatrix.length;for(let r=0;r<i;r++)for(let a=0;a<i;a++)if(e.adjacencyMatrix[r][a]&&(!n.adjacencyMatrix[o[r]][o[a]]||s&&!t.has(r+","+a)&&e.edgeLabels[r][a]!==n.edgeLabels[o[r]][o[a]]))return!1;return!0}}const I=Object.freeze(Object.defineProperty({__proto__:null,GraphMatcher:h,UllmannGraphMatcher:x},Symbol.toStringTag,{value:"Module"})),m=class m{constructor(e,n=m.DefaultNodeKeySuffixGenerator,o=m.DefaultNodePropertiesMapper,t=m.DefaultNodePropertiesCanonKeyMapper){u(this,"nodeCount");u(this,"hasNodeLabels");u(this,"hasNodeProperties");u(this,"hasEdgeLabels");u(this,"graph");u(this,"nodeNeighbors",new Map);u(this,"nodeKeys",new Map);u(this,"inDegrees",new Map);u(this,"outDegrees",new Map);u(this,"nodePropertiesMapper");u(this,"nodePropertiesCanonKeyMapper");this.graph=e,this.nodeCount=e.adjacencyMatrix.length,this.hasNodeLabels=e.labels!==void 0,this.hasNodeProperties=e.nodeProperties!==void 0,this.hasEdgeLabels=e.edgeLabels!==void 0,this.nodePropertiesMapper=o,this.nodePropertiesCanonKeyMapper=t;for(let s=0;s<this.nodeCount;s++){const i=new Set;let r=0,a=0;for(let l=0;l<this.nodeCount;l++)e.adjacencyMatrix[s][l]===1&&(a++,i.add(l)),e.adjacencyMatrix[l][s]===1&&(r++,i.add(l));this.inDegrees.set(s,r),this.outDegrees.set(s,a),this.nodeNeighbors.set(s,[...i]);const c=a+"|"+r+"|"+n(e,s);this.nodeKeys.set(s,c)}}canonicalize(){const e=new Array(this.nodeCount).fill(1);this.partitionByPropertyKeys(e);let n=null,o=null,t=null;const s=Array.from({length:this.nodeCount},r=>new Set),i=new Set;return this.individualizeDFS(e,[],i,(r,a)=>{for(let f=0;f<r.length;f++)s[r[f]-1].add(f);for(let f=0;f<s.length;f++)if(s[f].size>1){const g=[...s[f]].sort();for(let M=1;M<g.length;M++)i.add(g[M])}const c=this.buildRepresentationGraph(r),l=this.buildGraphString(c);(t===null||l.localeCompare(t)<0)&&(n=c,o=new Array(r.length),r.forEach((f,g)=>o[f-1]=g),t=l)}),[n,t,o]}partitionByPropertyKeys(e){const n=new Map;for(let t=0;t<this.nodeCount;t++){const s=this.nodeKeys.get(t);n.has(s)?n.get(s).push(t):n.set(s,[t])}let o=1;Array.from(n.keys()).sort((t,s)=>t.localeCompare(s)).forEach(t=>{const s=n.get(t);s.forEach(i=>e[i]=o),o+=s.length})}isCanon(e){return new Set(e).size===this.nodeCount}individualizeDFS(e,n,o,t){if(this.isCanon(e)){t(e,n);return}if(this.individualizationRefinement(e),this.isCanon(e)){t(e,n);return}const s=this.getCurrentCells(e),i=Array.from(s.entries()).sort(([r],[a])=>r-a).filter(([,r])=>r.length>1)[0];for(const r of i[1]){if(o.has(r))continue;const a=[...e];i[1].forEach(l=>{l!==r&&(a[l]=i[0]+1)});const c=[...n,r];this.individualizeDFS(a,c,o,t)}}individualizationRefinement(e){let n=!1;for(;!n;){n=!0;const o=e.map((i,r)=>[this.nodeNeighbors.get(r).map(l=>{let f=e[l].toString();return this.hasEdgeLabels&&(f+=";"+this.graph.edgeLabels[r][l]+";"+this.graph.edgeLabels[l][r]),f}).sort().join("|"),r]),t=new Map;for(const[i,r]of o){const a=e[r];t.has(a)||t.set(a,new Map);const c=t.get(a);c.has(i)||c.set(i,[]),c.get(i).push(r)}const s=Array.from(t.keys()).sort();for(const i of s){const r=Array.from(t.get(i).entries());if(r.length>1){n=!1,r.sort(([c],[l])=>l.localeCompare(c));let a=i;r.forEach(([,c])=>{c.forEach(l=>e[l]=a),a+=c.length});break}}}}getCurrentCells(e){const n=new Map;return e.forEach((o,t)=>{n.has(o)?n.get(o).push(t):n.set(o,[t])}),n}buildRepresentationGraph(e){const n=e.map(t=>t-1),o={adjacencyMatrix:Array.from({length:this.nodeCount},()=>new Array(this.nodeCount))};for(let t=0;t<this.nodeCount;t++)for(let s=0;s<this.nodeCount;s++)o.adjacencyMatrix[n[t]][n[s]]=this.graph.adjacencyMatrix[t][s];if(this.hasNodeLabels&&(o.labels=new Array(this.nodeCount),n.forEach((t,s)=>o.labels[t]=this.graph.labels[s])),this.hasNodeProperties&&(o.nodeProperties=new Array(this.nodeCount),n.forEach((t,s)=>o.nodeProperties[t]=this.nodePropertiesMapper(this.graph,s,n))),this.hasEdgeLabels){o.edgeLabels=Array.from({length:this.nodeCount},()=>new Array(this.nodeCount));for(let t=0;t<this.nodeCount;t++)for(let s=0;s<this.nodeCount;s++)o.edgeLabels[n[t]][n[s]]=this.graph.edgeLabels[t][s]}return o}buildGraphString(e){const n=[];for(let t=0;t<this.nodeCount;t++)for(let s=0;s<this.nodeCount;s++)e.adjacencyMatrix[t][s]===1&&(this.hasEdgeLabels?n.push(t+"-"+e.edgeLabels[t][s]+"-"+s):n.push(t+"-"+s));let o=n.join("|");return this.hasNodeLabels&&this.hasNodeProperties?n.join("|")+";"+e.labels.map((t,s)=>{const i=this.nodePropertiesCanonKeyMapper(e,s);return t+(i.length>0?"{"+i+"}":"")}).join("|"):(this.hasNodeLabels?o+=";"+e.labels.join("|"):this.hasNodeProperties&&(o+=";"+e.nodeProperties.map((t,s)=>this.nodePropertiesCanonKeyMapper(e,s)).join("|")),o)}};u(m,"DefaultNodeKeySuffixGenerator",(e,n)=>e.labels?e.labels[n]:""),u(m,"DefaultNodePropertiesMapper",(e,n,o)=>e.nodeProperties&&e.nodeProperties[n]?new Map(e.nodeProperties[n]):void 0),u(m,"DefaultNodePropertiesCanonKeyMapper",(e,n)=>"");let L=m;const N=Object.freeze(Object.defineProperty({__proto__:null,GraphCanon:L},Symbol.toStringTag,{value:"Module"}));class K{static find(e){const n=[],o=new Set,t=(s,i)=>{o.add(s),i.push(s);for(let r=0;r<e.adjacencyMatrix.length;r++)(e.adjacencyMatrix[s][r]===1||e.adjacencyMatrix[r][s]===1)&&(o.has(r)||t(r,i))};for(let s=0;s<e.adjacencyMatrix.length;s++)if(!o.has(s)){const i=[];t(s,i),n.push(i)}return n}}const O=Object.freeze(Object.defineProperty({__proto__:null,ConnectedComponents:K,canon:N,matching:I},Symbol.toStringTag,{value:"Module"}));b.graph=O,Object.defineProperty(b,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=ac-graph-core-js.umd.cjs.map
