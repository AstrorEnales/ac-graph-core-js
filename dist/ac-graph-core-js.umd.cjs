(function(f,d){typeof exports=="object"&&typeof module<"u"?d(exports):typeof define=="function"&&define.amd?define(["exports"],d):(f=typeof globalThis<"u"?globalThis:f||self,d(f.ACGraphCore={}))})(this,function(f){"use strict";var G=Object.defineProperty;var z=(f,d,x)=>d in f?G(f,d,{enumerable:!0,configurable:!0,writable:!0,value:x}):f[d]=x;var g=(f,d,x)=>z(f,typeof d!="symbol"?d+"":d,x);class d{}class x extends d{isSubgraphIsomorphic(e,n,s=[],t=[]){const i=e.adjacencyMatrix.length,r=n.adjacencyMatrix.length;if(i>r)return!1;const a=e.labels&&n.labels,o=Array(r).fill(!1),l=Array(i).fill(-1),c=new Set(s),y=new Set(t),[M,D,C,w]=this.getInOutDegrees(e,n),p=M.map((b,u)=>C.map((h,j)=>h>=b&&w[j]>=D[u]&&(!a||c.has(u)||e.labels[u]===n.labels[j])?j:-1).filter(h=>h!==-1)),S=b=>{if(b===i)return this.checkCompatibility(e,n,l,y);for(const u of p[b])if(!o[u]){if(l[b]=u,o[u]=!0,this.isFeasible(e,n,l,b,y)&&S(b+1))return!0;o[u]=!1,l[b]=-1}return!1};return S(0)}getInOutDegrees(e,n){const s=e.adjacencyMatrix.map(a=>a.reduce((o,l)=>o+l,0)),t=[],i=n.adjacencyMatrix.map(a=>a.reduce((o,l)=>o+l,0)),r=[];return e.adjacencyMatrix.forEach((a,o)=>{t.push(a.map((l,c)=>e.adjacencyMatrix[c][o]).reduce((l,c)=>l+c,0))}),n.adjacencyMatrix.forEach((a,o)=>{r.push(a.map((l,c)=>n.adjacencyMatrix[c][o]).reduce((l,c)=>l+c,0))}),[s,t,i,r]}findAllSubgraphMonomorphisms(e,n,s=[],t=[]){const i=e.adjacencyMatrix.length,r=n.adjacencyMatrix.length,a=[],o=new Set(s),l=new Set(t);if(i>r)return a;const c=e.labels&&n.labels,y=Array(r).fill(!1),M=Array(i).fill(-1),[D,C,w,p]=this.getInOutDegrees(e,n),S=D.map((u,h)=>w.map((j,E)=>j>=u&&p[E]>=C[h]&&(!c||o.has(h)||e.labels[h]===n.labels[E])?E:-1).filter(j=>j!==-1)),b=u=>{if(u===i){this.checkCompatibility(e,n,M,l)&&a.push([...M]);return}for(const h of S[u])y[h]||(M[u]=h,y[h]=!0,this.isFeasible(e,n,M,u,l)&&b(u+1),y[h]=!1,M[u]=-1)};return b(0),a}isFeasible(e,n,s,t,i){const r=e.edgeLabels&&n.edgeLabels;for(let a=0;a<t;a++)if(e.adjacencyMatrix[t][a]&&(!n.adjacencyMatrix[s[t]][s[a]]||r&&!i.has(t+","+a)&&e.edgeLabels[t][a]!==n.edgeLabels[s[t]][s[a]])||e.adjacencyMatrix[a][t]&&(!n.adjacencyMatrix[s[a]][s[t]]||r&&!i.has(a+","+t)&&e.edgeLabels[a][t]!==n.edgeLabels[s[a]][s[t]]))return!1;return!0}checkCompatibility(e,n,s,t){const i=e.edgeLabels&&n.edgeLabels,r=e.adjacencyMatrix.length;for(let a=0;a<r;a++)for(let o=0;o<r;o++)if(e.adjacencyMatrix[a][o]&&(!n.adjacencyMatrix[s[a]][s[o]]||i&&!t.has(a+","+o)&&e.edgeLabels[a][o]!==n.edgeLabels[s[a]][s[o]]))return!1;return!0}}const A=Object.freeze(Object.defineProperty({__proto__:null,GraphMatcher:d,UllmannGraphMatcher:x},Symbol.toStringTag,{value:"Module"})),m=class m{constructor(e,n=m.DefaultNodeKeySuffixGenerator){g(this,"nodeCount");g(this,"hasNodeLabels");g(this,"hasEdgeLabels");g(this,"graph");g(this,"nodeNeighbors",new Map);g(this,"nodeKeys",new Map);g(this,"inDegrees",new Map);g(this,"outDegrees",new Map);this.graph=e,this.nodeCount=e.adjacencyMatrix.length,this.hasNodeLabels=e.labels!==void 0,this.hasEdgeLabels=e.edgeLabels!==void 0;for(let s=0;s<this.nodeCount;s++){const t=new Set;let i=0,r=0;for(let o=0;o<this.nodeCount;o++)e.adjacencyMatrix[s][o]===1&&(r++,t.add(o)),e.adjacencyMatrix[o][s]===1&&(i++,t.add(o));this.inDegrees.set(s,i),this.outDegrees.set(s,r),this.nodeNeighbors.set(s,[...t]);const a=r+"|"+i+n(e,s);this.nodeKeys.set(s,a)}}canonicalize(){const e=new Array(this.nodeCount).fill(1);this.partitionByPropertyKeys(e);let n=null,s=null,t=null;return this.individualizeDFS(e,[],(i,r)=>{const a=this.buildRepresentationGraph(i),o=this.buildGraphString(a);(t===null||o.localeCompare(t)<0)&&(n=a,s=new Array(i.length),i.forEach((l,c)=>s[l-1]=c),t=o)}),[n,t,s]}partitionByPropertyKeys(e){const n=new Map;for(let t=0;t<this.nodeCount;t++){const i=this.nodeKeys.get(t);n.has(i)?n.get(i).push(t):n.set(i,[t])}let s=1;Array.from(n.keys()).sort((t,i)=>t.localeCompare(i)).forEach(t=>{const i=n.get(t);i.forEach(r=>e[r]=s),s+=i.length})}isCanon(e){return new Set(e).size===this.nodeCount}individualizeDFS(e,n,s){if(this.isCanon(e)){s(e,n);return}if(this.individualizationRefinement(e),this.isCanon(e)){s(e,n);return}const t=this.getCurrentCells(e),i=Array.from(t.entries()).sort(([r],[a])=>r-a).filter(([,r])=>r.length>1)[0];for(const r of i[1]){const a=[...e];i[1].forEach(o=>{o!==r&&(a[o]=i[0]+1)}),this.individualizeDFS(a,[...n,r],s)}}individualizationRefinement(e){let n=!1;for(;!n;){n=!0;const s=e.map((r,a)=>[this.nodeNeighbors.get(a).map(c=>{let y=e[c].toString();return this.hasEdgeLabels&&(y+=";"+this.graph.edgeLabels[a][c]+";"+this.graph.edgeLabels[c][a]),y}).sort().join("|"),a]),t=new Map;for(const[r,a]of s){const o=e[a];t.has(o)||t.set(o,new Map);const l=t.get(o);l.has(r)||l.set(r,[]),l.get(r).push(a)}const i=Array.from(t.keys()).sort();for(const r of i){const a=Array.from(t.get(r).entries());if(a.length>1){n=!1,a.sort(([l],[c])=>c.localeCompare(l));let o=r;a.forEach(([,l])=>{l.forEach(c=>e[c]=o),o+=l.length});break}}}}getCurrentCells(e){const n=new Map;return e.forEach((s,t)=>{n.has(s)?n.get(s).push(t):n.set(s,[t])}),n}buildRepresentationGraph(e){const n={adjacencyMatrix:Array.from({length:this.nodeCount},()=>new Array(this.nodeCount))};for(let s=0;s<this.nodeCount;s++)for(let t=0;t<this.nodeCount;t++)n.adjacencyMatrix[e[s]-1][e[t]-1]=this.graph.adjacencyMatrix[s][t];if(this.hasNodeLabels&&(n.labels=new Array(this.nodeCount),e.forEach((s,t)=>n.labels[s-1]=this.graph.labels[t])),this.hasEdgeLabels){n.edgeLabels=Array.from({length:this.nodeCount},()=>new Array(this.nodeCount));for(let s=0;s<this.nodeCount;s++)for(let t=0;t<this.nodeCount;t++)n.edgeLabels[e[s]-1][e[t]-1]=this.graph.edgeLabels[s][t]}return n}buildGraphString(e){const n=[];for(let s=0;s<this.nodeCount;s++)for(let t=0;t<this.nodeCount;t++)e.adjacencyMatrix[s][t]===1&&(this.hasEdgeLabels?n.push(s+"-"+e.edgeLabels[s][t]+"-"+t):n.push(s+"-"+t));return this.hasNodeLabels?n.join("|")+";"+e.labels.join("|"):n.join("|")}};g(m,"DefaultNodeKeySuffixGenerator",(e,n)=>e.labels?e.labels[n]:"");let L=m;const O=Object.freeze(Object.defineProperty({__proto__:null,GraphCanon:L},Symbol.toStringTag,{value:"Module"}));class _{static find(e){const n=[],s=new Set,t=(i,r)=>{s.add(i),r.push(i);for(let a=0;a<e.adjacencyMatrix.length;a++)(e.adjacencyMatrix[i][a]===1||e.adjacencyMatrix[a][i]===1)&&(s.has(a)||t(a,r))};for(let i=0;i<e.adjacencyMatrix.length;i++)if(!s.has(i)){const r=[];t(i,r),n.push(r)}return n}}const v=Object.freeze(Object.defineProperty({__proto__:null,ConnectedComponents:_,canon:O,matching:A},Symbol.toStringTag,{value:"Module"}));f.graph=v,Object.defineProperty(f,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=ac-graph-core-js.umd.cjs.map
