(function(b,y){typeof exports=="object"&&typeof module<"u"?y(exports):typeof define=="function"&&define.amd?define(["exports"],y):(b=typeof globalThis<"u"?globalThis:b||self,y(b.ACGraphCore={}))})(this,function(b){"use strict";class y{}class L extends y{isSubgraphIsomorphic(a,r){const n=a.adjacencyMatrix.length,o=r.adjacencyMatrix.length;if(n>o)return!1;const u=a.labels&&r.labels,i=Array(o).fill(!1),f=Array(n).fill(-1),d=[],x=[],M=[],j=[];for(let l=0;l<n;l++){const e=a.adjacencyMatrix[l];d.push(e.reduce((c,s)=>c+s,0)),x.push(e.map((c,s)=>a.adjacencyMatrix[s][l]).reduce((c,s)=>c+s,0))}for(let l=0;l<o;l++){const e=r.adjacencyMatrix[l];M.push(e.reduce((c,s)=>c+s,0)),j.push(e.map((c,s)=>r.adjacencyMatrix[s][l]).reduce((c,s)=>c+s,0))}const h=d.map((l,e)=>M.map((c,s)=>c>=l&&j[s]>=x[e]&&(!u||a.labels[e]===r.labels[s])?s:-1).filter(c=>c!==-1)),m=l=>{if(l===n)return this.checkCompatibility(a,r,f);for(const e of h[l])if(!i[e]){if(f[l]=e,i[e]=!0,this.isFeasible(a,r,f,l)&&m(l+1))return!0;i[e]=!1,f[l]=-1}return!1};return m(0)}findAllSubgraphMonomorphisms(a,r){const n=a.adjacencyMatrix.length,o=r.adjacencyMatrix.length,u=[];if(n>o)return u;const i=a.labels&&r.labels,f=Array(o).fill(!1),d=Array(n).fill(-1),x=[],M=[],j=[],h=[];for(let e=0;e<n;e++){const c=a.adjacencyMatrix[e];x.push(c.reduce((s,t)=>s+t,0)),M.push(c.map((s,t)=>a.adjacencyMatrix[t][e]).reduce((s,t)=>s+t,0))}for(let e=0;e<o;e++){const c=r.adjacencyMatrix[e];j.push(c.reduce((s,t)=>s+t,0)),h.push(c.map((s,t)=>r.adjacencyMatrix[t][e]).reduce((s,t)=>s+t,0))}const m=x.map((e,c)=>j.map((s,t)=>s>=e&&h[t]>=M[c]&&(!i||a.labels[c]===r.labels[t])?t:-1).filter(s=>s!==-1)),l=e=>{if(e===n){this.checkCompatibility(a,r,d)&&u.push([...d]);return}for(const c of m[e])f[c]||(d[e]=c,f[c]=!0,this.isFeasible(a,r,d,e)&&l(e+1),f[c]=!1,d[e]=-1)};return l(0),u}isFeasible(a,r,n,o){const u=a.edgeLabels&&r.edgeLabels;for(let i=0;i<o;i++)if(a.adjacencyMatrix[o][i]&&(!r.adjacencyMatrix[n[o]][n[i]]||u&&a.edgeLabels[o][i]!==r.edgeLabels[n[o]][n[i]])||a.adjacencyMatrix[i][o]&&(!r.adjacencyMatrix[n[i]][n[o]]||u&&a.edgeLabels[i][o]!==r.edgeLabels[n[i]][n[o]]))return!1;return!0}checkCompatibility(a,r,n){const o=a.edgeLabels&&r.edgeLabels,u=a.adjacencyMatrix.length;for(let i=0;i<u;i++)for(let f=0;f<u;f++)if(a.adjacencyMatrix[i][f]&&(!r.adjacencyMatrix[n[i]][n[f]]||o&&a.edgeLabels[i][f]!==r.edgeLabels[n[i]][n[f]]))return!1;return!0}}const g=Object.freeze(Object.defineProperty({__proto__:null,matching:Object.freeze(Object.defineProperty({__proto__:null,GraphMatcher:y,UllmannGraphMatcher:L},Symbol.toStringTag,{value:"Module"}))},Symbol.toStringTag,{value:"Module"}));b.graph=g,Object.defineProperty(b,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=ac-graph-core-js.umd.cjs.map
