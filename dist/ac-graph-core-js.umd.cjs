(function(S,j){typeof exports=="object"&&typeof module<"u"?j(exports):typeof define=="function"&&define.amd?define(["exports"],j):(S=typeof globalThis<"u"?globalThis:S||self,j(S.ACGraphCore={}))})(this,function(S){"use strict";var O=Object.defineProperty;var z=(S,j,C)=>j in S?O(S,j,{enumerable:!0,configurable:!0,writable:!0,value:C}):S[j]=C;var p=(S,j,C)=>z(S,typeof j!="symbol"?j+"":j,C);class j{}class C extends j{isSubgraphIsomorphic(n,r,i=[],e=[],o=null){const t=n.adjacencyMatrix.length,s=r.adjacencyMatrix.length;if(t>s)return!1;o===null&&(o=new Array(t).fill(-1));const a=n.labels&&r.labels,l=Array(s).fill(!1),d=Array(t).fill(-1),h=new Set(i),m=new Set(e),[M,c,g,y]=this.getInOutDegrees(n,r),L=M.map((f,u)=>g.map((b,x)=>b>=f&&y[x]>=c[u]&&(o[u]===-1||o[u]===x)&&(!a||h.has(u)||n.labels[u]===r.labels[x])?x:-1).filter(b=>b!==-1)),P=f=>{if(f===t)return this.checkCompatibility(n,r,d,m);for(const u of L[f])if(!l[u]){if(d[f]=u,l[u]=!0,this.isFeasible(n,r,d,f,m)&&P(f+1))return!0;l[u]=!1,d[f]=-1}return!1};return P(0)}getInOutDegrees(n,r){const i=n.adjacencyMatrix.map(s=>s.reduce((a,l)=>a+l,0)),e=[],o=r.adjacencyMatrix.map(s=>s.reduce((a,l)=>a+l,0)),t=[];return n.adjacencyMatrix.forEach((s,a)=>{e.push(s.map((l,d)=>n.adjacencyMatrix[d][a]).reduce((l,d)=>l+d,0))}),r.adjacencyMatrix.forEach((s,a)=>{t.push(s.map((l,d)=>r.adjacencyMatrix[d][a]).reduce((l,d)=>l+d,0))}),[i,e,o,t]}findAllSubgraphMonomorphisms(n,r,i=[],e=[],o=null){const t=n.adjacencyMatrix.length,s=r.adjacencyMatrix.length,a=[],l=new Set(i),d=new Set(e);if(t>s)return a;o===null&&(o=new Array(t).fill(-1));const h=n.labels&&r.labels,m=Array(s).fill(!1),M=Array(t).fill(-1),[c,g,y,L]=this.getInOutDegrees(n,r),P=c.map((u,b)=>y.map((x,D)=>x>=u&&L[D]>=g[b]&&(o[b]===-1||o[b]===D)&&(!h||l.has(b)||n.labels[b]===r.labels[D])?D:-1).filter(x=>x!==-1)),f=u=>{if(u===t){this.checkCompatibility(n,r,M,d)&&a.push([...M]);return}for(const b of P[u])m[b]||(M[u]=b,m[b]=!0,this.isFeasible(n,r,M,u,d)&&f(u+1),m[b]=!1,M[u]=-1)};return f(0),a}isFeasible(n,r,i,e,o){const t=n.edgeLabels&&r.edgeLabels;for(let s=0;s<e;s++)if(n.adjacencyMatrix[e][s]&&(!r.adjacencyMatrix[i[e]][i[s]]||t&&!o.has(e+","+s)&&n.edgeLabels[e][s]!==r.edgeLabels[i[e]][i[s]])||n.adjacencyMatrix[s][e]&&(!r.adjacencyMatrix[i[s]][i[e]]||t&&!o.has(s+","+e)&&n.edgeLabels[s][e]!==r.edgeLabels[i[s]][i[e]]))return!1;return!0}checkCompatibility(n,r,i,e){const o=n.edgeLabels&&r.edgeLabels,t=n.adjacencyMatrix.length;for(let s=0;s<t;s++)for(let a=0;a<t;a++)if(n.adjacencyMatrix[s][a]&&(!r.adjacencyMatrix[i[s]][i[a]]||o&&!e.has(s+","+a)&&n.edgeLabels[s][a]!==r.edgeLabels[i[s]][i[a]]))return!1;return!0}}const E=Object.freeze(Object.defineProperty({__proto__:null,GraphMatcher:j,UllmannGraphMatcher:C},Symbol.toStringTag,{value:"Module"})),w=class w{constructor(n,r=w.DefaultNodeKeySuffixGenerator,i=w.DefaultNodePropertiesMapper,e=w.DefaultNodePropertiesCanonKeyMapper){p(this,"nodeCount");p(this,"hasNodeLabels");p(this,"hasNodeProperties");p(this,"hasEdgeLabels");p(this,"isSymmetric");p(this,"graph");p(this,"nodeNeighbors",new Map);p(this,"nodeKeys",new Map);p(this,"nodePropertiesMapper");p(this,"nodePropertiesCanonKeyMapper");p(this,"graphStringBuilder");this.graph=n,this.nodeCount=n.adjacencyMatrix.length,this.hasNodeLabels=n.labels!==void 0,this.hasNodeProperties=n.nodeProperties!==void 0,this.hasEdgeLabels=n.edgeLabels!==void 0,this.nodePropertiesMapper=i,this.nodePropertiesCanonKeyMapper=e;let o=!0;for(let t=0;t<this.nodeCount;t++){const s=new Set;let a=0,l=0;for(let h=0;h<this.nodeCount;h++){const m=n.adjacencyMatrix[t][h],M=n.adjacencyMatrix[h][t];m===1&&(l++,s.add(h)),M===1&&(a++,s.add(h)),m!==M&&(o=!1)}this.nodeNeighbors.set(t,[...s]);const d=l+"|"+a+"|"+r(n,t);this.nodeKeys.set(t,d)}this.isSymmetric=o,this.graphStringBuilder=this.buildGraphStringCurry()}canonicalize(){const n=new Array(this.nodeCount).fill(1);this.partitionByPropertyKeys(n);let r=null,i=null,e=null;const o=[],t=new Map,s=Array.from({length:this.nodeCount},l=>new Set),a=new Set;return this.individualizeDFS(n,[],a,(l,d)=>{for(const c of o){const g=new Map;for(let f=0;f<l.length;f++){const u=c.get(l[f]);if(u!==f){const b=[u<f?u:f,f<u?u:f];g.set(b.join("|"),b)}}const y=[...g.values()];let L=!0;for(;L;){L=!1;for(let f=0;f<y.length;f++)for(let u=f+1;u<y.length;u++)if(y[f].some(b=>y[u].includes(b))){y[f]=Array.from(new Set([...y[f],...y[u]])).sort(),y.splice(u,1),L=!0;break}}const P=y.map(f=>"("+f.join(" ")+")").join("");t.set(P,y)}const h=new Map;l.forEach((c,g)=>h.set(c,g)),o.push(h);for(let c=0;c<l.length;c++)s[l[c]-1].add(c);for(let c=0;c<s.length;c++)if(s[c].size>1){const g=[...s[c]].sort();for(let y=1;y<g.length;y++)a.add(g[y])}const m=this.buildRepresentationGraph(l),M=this.buildGraphString(m);(e===null||M.localeCompare(e)<0)&&(r=m,i=new Array(l.length),l.forEach((c,g)=>i[c-1]=g),e=M)}),[r,e,i,new A([...t.values()])]}aut(){const n=new Array(this.nodeCount).fill(1);this.partitionByPropertyKeys(n);const r=[],i=new Map,e=Array.from({length:this.nodeCount},t=>new Set),o=new Set;return this.individualizeDFS(n,[],o,(t,s)=>{for(const l of r){const d=new Map;for(let c=0;c<t.length;c++){const g=l.get(t[c]);if(g!==c){const y=[g<c?g:c,c<g?g:c];d.set(y.join("|"),y)}}const h=[...d.values()];let m=!0;for(;m;){m=!1;for(let c=0;c<h.length;c++)for(let g=c+1;g<h.length;g++)if(h[c].some(y=>h[g].includes(y))){h[c]=Array.from(new Set([...h[c],...h[g]])).sort(),h.splice(g,1),m=!0;break}}const M=h.map(c=>"("+c.join(" ")+")").join("");i.set(M,h)}const a=new Map;t.forEach((l,d)=>a.set(l,d)),r.push(a);for(let l=0;l<t.length;l++)e[t[l]-1].add(l);for(let l=0;l<e.length;l++)if(e[l].size>1){const d=[...e[l]].sort();for(let h=1;h<d.length;h++)o.add(d[h])}}),new A([...i.values()])}partitionByPropertyKeys(n){const r=new Map;for(let e=0;e<this.nodeCount;e++){const o=this.nodeKeys.get(e);r.has(o)?r.get(o).push(e):r.set(o,[e])}let i=1;Array.from(r.keys()).sort((e,o)=>e.localeCompare(o)).forEach(e=>{const o=r.get(e);o.forEach(t=>n[t]=i),i+=o.length})}isCanon(n){return new Set(n).size===this.nodeCount}individualizeDFS(n,r,i,e){if(this.isCanon(n)){e(n,r);return}if(this.individualizationRefinement(n),this.isCanon(n)){e(n,r);return}const o=this.getCellToBreak(n);for(const t of o[1])n[t]=o[0]+1;for(const t of o[1])r.length===0&&i.has(t)||(n[t]=o[0],this.individualizeDFS([...n],[...r,t],i,e),n[t]=o[0]+1)}individualizationRefinement(n){let r=!1;for(;!r;){r=!0;const i=n.map((o,t)=>this.nodeNeighbors.get(t).map(a=>{if(this.hasEdgeLabels){const l=this.graph.edgeLabels;return this.isSymmetric?`${n[a]};${l[t][a]}`:`${n[a]};${l[t][a]};${l[a][t]}`}return n[a].toString()}).sort().join("|")),e=new Map;i.forEach((o,t)=>{const s=n[t];let a=e.get(s);a===void 0&&(a=new Map,e.set(s,a));let l=a.get(o);l===void 0&&(l=[],a.set(o,l)),l.push(t)});for(let o=1;o<=this.nodeCount;o++){const t=e.get(o);if(t===void 0||t.size<2)continue;r=!1;const s=Array.from(t.keys()).sort((l,d)=>d.localeCompare(l));let a=o;for(const l of s){const d=t.get(l);d.forEach(h=>n[h]=a),a+=d.length}break}}}getCellToBreak(n){const r=Array.from({length:n.length},()=>[]);n.forEach((i,e)=>r[i-1].push(e));for(let i=0;i<r.length;i++)if(r[i].length>1)return[i+1,r[i]];return[1,r[0]]}buildRepresentationGraph(n){const r=n.map(e=>e-1),i={adjacencyMatrix:Array.from({length:this.nodeCount},()=>new Array(this.nodeCount))};if(this.isSymmetric)for(let e=0;e<this.nodeCount;e++){const o=r[e],t=this.graph.adjacencyMatrix[e];for(let s=e;s<this.nodeCount;s++)i.adjacencyMatrix[o][r[s]]=t[s],i.adjacencyMatrix[r[s]][o]=t[s]}else for(let e=0;e<this.nodeCount;e++){const o=r[e],t=this.graph.adjacencyMatrix[e];for(let s=0;s<this.nodeCount;s++)i.adjacencyMatrix[o][r[s]]=t[s]}if(this.hasNodeLabels&&(i.labels=new Array(this.nodeCount),r.forEach((e,o)=>i.labels[e]=this.graph.labels[o])),this.hasNodeProperties&&(i.nodeProperties=new Array(this.nodeCount),r.forEach((e,o)=>i.nodeProperties[e]=this.nodePropertiesMapper(this.graph,o,r))),this.hasEdgeLabels)if(i.edgeLabels=Array.from({length:this.nodeCount},()=>new Array(this.nodeCount)),this.isSymmetric)for(let e=0;e<this.nodeCount;e++){const o=r[e],t=this.graph.edgeLabels[e];for(let s=e;s<this.nodeCount;s++)i.edgeLabels[o][r[s]]=t[s],i.edgeLabels[r[s]][o]=t[s]}else for(let e=0;e<this.nodeCount;e++){const o=r[e],t=this.graph.edgeLabels[e];for(let s=0;s<this.nodeCount;s++)i.edgeLabels[o][r[s]]=t[s]}return i}buildGraphStringCurry(){const n=this.hasEdgeLabels?(e,o,t)=>`${o}-${e.edgeLabels[o][t]}-${t}`:(e,o,t)=>`${o}-${t}`,r=this.hasNodeProperties?(e,o)=>{const t=this.nodePropertiesCanonKeyMapper(e,o);return t.length>0?`{${t}}`:""}:(e,o)=>"",i=this.hasNodeLabels?e=>";"+e.labels.map((o,t)=>o+r(e,t)).join("|"):this.hasNodeProperties?e=>";"+e.nodeProperties.map((o,t)=>this.nodePropertiesCanonKeyMapper(e,t)).join("|"):e=>"";return this.isSymmetric?e=>{const o=[];for(let t=0;t<this.nodeCount;t++){const s=e.adjacencyMatrix[t];for(let a=t;a<this.nodeCount;a++)s[a]===1&&o.push(n(e,t,a))}return o.join("|")+i(e)}:e=>{const o=[];for(let t=0;t<this.nodeCount;t++){const s=e.adjacencyMatrix[t];for(let a=0;a<this.nodeCount;a++)s[a]===1&&o.push(n(e,t,a))}return o.join("|")+i(e)}}buildGraphString(n){return this.graphStringBuilder(n)}};p(w,"DefaultNodeKeySuffixGenerator",(n,r)=>n.labels?n.labels[r]:""),p(w,"DefaultNodePropertiesMapper",(n,r,i)=>n.nodeProperties&&n.nodeProperties[r]?new Map(n.nodeProperties[r]):void 0),p(w,"DefaultNodePropertiesCanonKeyMapper",(n,r)=>"");let v=w;const K=Object.freeze(Object.defineProperty({__proto__:null,GraphCanon:v},Symbol.toStringTag,{value:"Module"}));class k{static find(n){const r=[],i=new Set,e=(o,t)=>{i.add(o),t.push(o);for(let s=0;s<n.adjacencyMatrix.length;s++)(n.adjacencyMatrix[o][s]===1||n.adjacencyMatrix[s][o]===1)&&(i.has(s)||e(s,t))};for(let o=0;o<n.adjacencyMatrix.length;o++)if(!i.has(o)){const t=[];e(o,t),r.push(t)}return r}}class A{constructor(n){p(this,"generators");this.generators=n}orbits(){const n=new Map;for(const e of this.generators)for(const o of e)for(let t=0;t<o.length;t++){let s=n.get(o[t]);s===void 0&&(s=new Set,n.set(o[t],s));for(let a=0;a<o.length;a++)t!==a&&s.add(o[a])}const r=[],i=new Set;for(const[e,o]of n.entries())if(!i.has(e)){i.add(e);for(const t of o)i.add(t);r.push([e,...o].sort())}return r}toString(){return"gen["+this.generators.map(n=>n.map(r=>"("+r.join(" ")+")").join("")).join(", ")+"], orb["+this.orbits().map(n=>"{"+n.join(" ")+"}").join(", ")+"]"}}const I=Object.freeze(Object.defineProperty({__proto__:null,AutomorphismGroup:A,ConnectedComponents:k,canon:K,matching:E},Symbol.toStringTag,{value:"Module"}));S.graph=I,Object.defineProperty(S,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=ac-graph-core-js.umd.cjs.map
