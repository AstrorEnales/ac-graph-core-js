(function(y,f){typeof exports=="object"&&typeof module<"u"?f(exports):typeof define=="function"&&define.amd?define(["exports"],f):(y=typeof globalThis<"u"?globalThis:y||self,f(y.ACGraphCore={}))})(this,function(y){"use strict";var v=Object.defineProperty;var _=(y,f,j)=>f in y?v(y,f,{enumerable:!0,configurable:!0,writable:!0,value:j}):y[f]=j;var u=(y,f,j)=>_(y,typeof f!="symbol"?f+"":f,j);class f{}class j extends f{isSubgraphIsomorphic(e,n,o=[],s=[],t=null){const i=e.adjacencyMatrix.length,r=n.adjacencyMatrix.length;if(i>r)return!1;t===null&&(t=new Array(i).fill(-1));const a=e.labels&&n.labels,c=Array(r).fill(!1),l=Array(i).fill(-1),x=new Set(o),m=new Set(s),[p,D,P,w]=this.getInOutDegrees(e,n),A=p.map((b,d)=>P.map((h,M)=>h>=b&&w[M]>=D[d]&&(t[d]===-1||t[d]===M)&&(!a||x.has(d)||e.labels[d]===n.labels[M])?M:-1).filter(h=>h!==-1)),C=b=>{if(b===i)return this.checkCompatibility(e,n,l,m);for(const d of A[b])if(!c[d]){if(l[b]=d,c[d]=!0,this.isFeasible(e,n,l,b,m)&&C(b+1))return!0;c[d]=!1,l[b]=-1}return!1};return C(0)}getInOutDegrees(e,n){const o=e.adjacencyMatrix.map(r=>r.reduce((a,c)=>a+c,0)),s=[],t=n.adjacencyMatrix.map(r=>r.reduce((a,c)=>a+c,0)),i=[];return e.adjacencyMatrix.forEach((r,a)=>{s.push(r.map((c,l)=>e.adjacencyMatrix[l][a]).reduce((c,l)=>c+l,0))}),n.adjacencyMatrix.forEach((r,a)=>{i.push(r.map((c,l)=>n.adjacencyMatrix[l][a]).reduce((c,l)=>c+l,0))}),[o,s,t,i]}findAllSubgraphMonomorphisms(e,n,o=[],s=[],t=null){const i=e.adjacencyMatrix.length,r=n.adjacencyMatrix.length,a=[],c=new Set(o),l=new Set(s);if(i>r)return a;t===null&&(t=new Array(i).fill(-1));const x=e.labels&&n.labels,m=Array(r).fill(!1),p=Array(i).fill(-1),[D,P,w,A]=this.getInOutDegrees(e,n),C=D.map((d,h)=>w.map((M,L)=>M>=d&&A[L]>=P[h]&&(t[h]===-1||t[h]===L)&&(!x||c.has(h)||e.labels[h]===n.labels[L])?L:-1).filter(M=>M!==-1)),b=d=>{if(d===i){this.checkCompatibility(e,n,p,l)&&a.push([...p]);return}for(const h of C[d])m[h]||(p[d]=h,m[h]=!0,this.isFeasible(e,n,p,d,l)&&b(d+1),m[h]=!1,p[d]=-1)};return b(0),a}isFeasible(e,n,o,s,t){const i=e.edgeLabels&&n.edgeLabels;for(let r=0;r<s;r++)if(e.adjacencyMatrix[s][r]&&(!n.adjacencyMatrix[o[s]][o[r]]||i&&!t.has(s+","+r)&&e.edgeLabels[s][r]!==n.edgeLabels[o[s]][o[r]])||e.adjacencyMatrix[r][s]&&(!n.adjacencyMatrix[o[r]][o[s]]||i&&!t.has(r+","+s)&&e.edgeLabels[r][s]!==n.edgeLabels[o[r]][o[s]]))return!1;return!0}checkCompatibility(e,n,o,s){const t=e.edgeLabels&&n.edgeLabels,i=e.adjacencyMatrix.length;for(let r=0;r<i;r++)for(let a=0;a<i;a++)if(e.adjacencyMatrix[r][a]&&(!n.adjacencyMatrix[o[r]][o[a]]||t&&!s.has(r+","+a)&&e.edgeLabels[r][a]!==n.edgeLabels[o[r]][o[a]]))return!1;return!0}}const E=Object.freeze(Object.defineProperty({__proto__:null,GraphMatcher:f,UllmannGraphMatcher:j},Symbol.toStringTag,{value:"Module"})),g=class g{constructor(e,n=g.DefaultNodeKeySuffixGenerator,o=g.DefaultNodePropertiesMapper,s=g.DefaultNodePropertiesCanonKeyMapper){u(this,"nodeCount");u(this,"hasNodeLabels");u(this,"hasNodeProperties");u(this,"hasEdgeLabels");u(this,"graph");u(this,"nodeNeighbors",new Map);u(this,"nodeKeys",new Map);u(this,"inDegrees",new Map);u(this,"outDegrees",new Map);u(this,"nodePropertiesMapper");u(this,"nodePropertiesCanonKeyMapper");this.graph=e,this.nodeCount=e.adjacencyMatrix.length,this.hasNodeLabels=e.labels!==void 0,this.hasNodeProperties=e.nodeProperties!==void 0,this.hasEdgeLabels=e.edgeLabels!==void 0,this.nodePropertiesMapper=o,this.nodePropertiesCanonKeyMapper=s;for(let t=0;t<this.nodeCount;t++){const i=new Set;let r=0,a=0;for(let l=0;l<this.nodeCount;l++)e.adjacencyMatrix[t][l]===1&&(a++,i.add(l)),e.adjacencyMatrix[l][t]===1&&(r++,i.add(l));this.inDegrees.set(t,r),this.outDegrees.set(t,a),this.nodeNeighbors.set(t,[...i]);const c=a+"|"+r+n(e,t);this.nodeKeys.set(t,c)}}canonicalize(){const e=new Array(this.nodeCount).fill(1);this.partitionByPropertyKeys(e);let n=null,o=null,s=null;return this.individualizeDFS(e,[],(t,i)=>{const r=this.buildRepresentationGraph(t),a=this.buildGraphString(r);(s===null||a.localeCompare(s)<0)&&(n=r,o=new Array(t.length),t.forEach((c,l)=>o[c-1]=l),s=a)}),[n,s,o]}partitionByPropertyKeys(e){const n=new Map;for(let s=0;s<this.nodeCount;s++){const t=this.nodeKeys.get(s);n.has(t)?n.get(t).push(s):n.set(t,[s])}let o=1;Array.from(n.keys()).sort((s,t)=>s.localeCompare(t)).forEach(s=>{const t=n.get(s);t.forEach(i=>e[i]=o),o+=t.length})}isCanon(e){return new Set(e).size===this.nodeCount}individualizeDFS(e,n,o){if(this.isCanon(e)){o(e,n);return}if(this.individualizationRefinement(e),this.isCanon(e)){o(e,n);return}const s=this.getCurrentCells(e),t=Array.from(s.entries()).sort(([i],[r])=>i-r).filter(([,i])=>i.length>1)[0];for(const i of t[1]){const r=[...e];t[1].forEach(a=>{a!==i&&(r[a]=t[0]+1)}),this.individualizeDFS(r,[...n,i],o)}}individualizationRefinement(e){let n=!1;for(;!n;){n=!0;const o=e.map((i,r)=>[this.nodeNeighbors.get(r).map(l=>{let x=e[l].toString();return this.hasEdgeLabels&&(x+=";"+this.graph.edgeLabels[r][l]+";"+this.graph.edgeLabels[l][r]),x}).sort().join("|"),r]),s=new Map;for(const[i,r]of o){const a=e[r];s.has(a)||s.set(a,new Map);const c=s.get(a);c.has(i)||c.set(i,[]),c.get(i).push(r)}const t=Array.from(s.keys()).sort();for(const i of t){const r=Array.from(s.get(i).entries());if(r.length>1){n=!1,r.sort(([c],[l])=>l.localeCompare(c));let a=i;r.forEach(([,c])=>{c.forEach(l=>e[l]=a),a+=c.length});break}}}}getCurrentCells(e){const n=new Map;return e.forEach((o,s)=>{n.has(o)?n.get(o).push(s):n.set(o,[s])}),n}buildRepresentationGraph(e){const n=e.map(s=>s-1),o={adjacencyMatrix:Array.from({length:this.nodeCount},()=>new Array(this.nodeCount))};for(let s=0;s<this.nodeCount;s++)for(let t=0;t<this.nodeCount;t++)o.adjacencyMatrix[n[s]][n[t]]=this.graph.adjacencyMatrix[s][t];if(this.hasNodeLabels&&(o.labels=new Array(this.nodeCount),n.forEach((s,t)=>o.labels[s]=this.graph.labels[t])),this.hasNodeProperties&&(o.nodeProperties=new Array(this.nodeCount),n.forEach((s,t)=>o.nodeProperties[s]=this.nodePropertiesMapper(this.graph,t,n))),this.hasEdgeLabels){o.edgeLabels=Array.from({length:this.nodeCount},()=>new Array(this.nodeCount));for(let s=0;s<this.nodeCount;s++)for(let t=0;t<this.nodeCount;t++)o.edgeLabels[n[s]][n[t]]=this.graph.edgeLabels[s][t]}return o}buildGraphString(e){const n=[];for(let s=0;s<this.nodeCount;s++)for(let t=0;t<this.nodeCount;t++)e.adjacencyMatrix[s][t]===1&&(this.hasEdgeLabels?n.push(s+"-"+e.edgeLabels[s][t]+"-"+t):n.push(s+"-"+t));let o=n.join("|");return this.hasNodeLabels&&this.hasNodeProperties?n.join("|")+";"+e.labels.map((s,t)=>{const i=this.nodePropertiesCanonKeyMapper(e,t);return s+(i.length>0?"{"+i+"}":"")}).join("|"):(this.hasNodeLabels?o+=";"+e.labels.join("|"):this.hasNodeProperties&&(o+=";"+e.nodeProperties.map((s,t)=>this.nodePropertiesCanonKeyMapper(e,t)).join("|")),o)}};u(g,"DefaultNodeKeySuffixGenerator",(e,n)=>e.labels?e.labels[n]:""),u(g,"DefaultNodePropertiesMapper",(e,n,o)=>e.nodeProperties&&e.nodeProperties[n]?new Map(e.nodeProperties[n]):void 0),u(g,"DefaultNodePropertiesCanonKeyMapper",(e,n)=>"");let S=g;const I=Object.freeze(Object.defineProperty({__proto__:null,GraphCanon:S},Symbol.toStringTag,{value:"Module"}));class K{static find(e){const n=[],o=new Set,s=(t,i)=>{o.add(t),i.push(t);for(let r=0;r<e.adjacencyMatrix.length;r++)(e.adjacencyMatrix[t][r]===1||e.adjacencyMatrix[r][t]===1)&&(o.has(r)||s(r,i))};for(let t=0;t<e.adjacencyMatrix.length;t++)if(!o.has(t)){const i=[];s(t,i),n.push(i)}return n}}const O=Object.freeze(Object.defineProperty({__proto__:null,ConnectedComponents:K,canon:I,matching:E},Symbol.toStringTag,{value:"Module"}));y.graph=O,Object.defineProperty(y,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=ac-graph-core-js.umd.cjs.map
