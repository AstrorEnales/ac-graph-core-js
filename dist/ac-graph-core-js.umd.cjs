(function(h,f){typeof exports=="object"&&typeof module<"u"?f(exports):typeof define=="function"&&define.amd?define(["exports"],f):(h=typeof globalThis<"u"?globalThis:h||self,f(h.ACGraphCore={}))})(this,function(h){"use strict";var N=Object.defineProperty;var k=(h,f,M)=>f in h?N(h,f,{enumerable:!0,configurable:!0,writable:!0,value:M}):h[f]=M;var y=(h,f,M)=>k(h,typeof f!="symbol"?f+"":f,M);class f{}class M extends f{isSubgraphIsomorphic(e,n,s=[],t=[],a=null){const i=e.adjacencyMatrix.length,r=n.adjacencyMatrix.length;if(i>r)return!1;a===null&&(a=new Array(i).fill(-1));const o=e.labels&&n.labels,l=Array(r).fill(!1),c=Array(i).fill(-1),j=new Set(s),m=new Set(t),[x,C,A,E]=this.getInOutDegrees(e,n),I=x.map((b,u)=>A.map((d,g)=>d>=b&&E[g]>=C[u]&&(a[u]===-1||a[u]===g)&&(!o||j.has(u)||e.labels[u]===n.labels[g])?g:-1).filter(d=>d!==-1)),L=b=>{if(b===i)return this.checkCompatibility(e,n,c,m);for(const u of I[b])if(!l[u]){if(c[b]=u,l[u]=!0,this.isFeasible(e,n,c,b,m)&&L(b+1))return!0;l[u]=!1,c[b]=-1}return!1};return L(0)}getInOutDegrees(e,n){const s=e.adjacencyMatrix.map(r=>r.reduce((o,l)=>o+l,0)),t=[],a=n.adjacencyMatrix.map(r=>r.reduce((o,l)=>o+l,0)),i=[];return e.adjacencyMatrix.forEach((r,o)=>{t.push(r.map((l,c)=>e.adjacencyMatrix[c][o]).reduce((l,c)=>l+c,0))}),n.adjacencyMatrix.forEach((r,o)=>{i.push(r.map((l,c)=>n.adjacencyMatrix[c][o]).reduce((l,c)=>l+c,0))}),[s,t,a,i]}findAllSubgraphMonomorphisms(e,n,s=[],t=[],a=null){const i=e.adjacencyMatrix.length,r=n.adjacencyMatrix.length,o=[],l=new Set(s),c=new Set(t);if(i>r)return o;a===null&&(a=new Array(i).fill(-1));const j=e.labels&&n.labels,m=Array(r).fill(!1),x=Array(i).fill(-1),[C,A,E,I]=this.getInOutDegrees(e,n),L=C.map((u,d)=>E.map((g,D)=>g>=u&&I[D]>=A[d]&&(a[d]===-1||a[d]===D)&&(!j||l.has(d)||e.labels[d]===n.labels[D])?D:-1).filter(g=>g!==-1)),b=u=>{if(u===i){this.checkCompatibility(e,n,x,c)&&o.push([...x]);return}for(const d of L[u])m[d]||(x[u]=d,m[d]=!0,this.isFeasible(e,n,x,u,c)&&b(u+1),m[d]=!1,x[u]=-1)};return b(0),o}isFeasible(e,n,s,t,a){const i=e.edgeLabels&&n.edgeLabels;for(let r=0;r<t;r++)if(e.adjacencyMatrix[t][r]&&(!n.adjacencyMatrix[s[t]][s[r]]||i&&!a.has(t+","+r)&&e.edgeLabels[t][r]!==n.edgeLabels[s[t]][s[r]])||e.adjacencyMatrix[r][t]&&(!n.adjacencyMatrix[s[r]][s[t]]||i&&!a.has(r+","+t)&&e.edgeLabels[r][t]!==n.edgeLabels[s[r]][s[t]]))return!1;return!0}checkCompatibility(e,n,s,t){const a=e.edgeLabels&&n.edgeLabels,i=e.adjacencyMatrix.length;for(let r=0;r<i;r++)for(let o=0;o<i;o++)if(e.adjacencyMatrix[r][o]&&(!n.adjacencyMatrix[s[r]][s[o]]||a&&!t.has(r+","+o)&&e.edgeLabels[r][o]!==n.edgeLabels[s[r]][s[o]]))return!1;return!0}}const _=Object.freeze(Object.defineProperty({__proto__:null,GraphMatcher:f,UllmannGraphMatcher:M},Symbol.toStringTag,{value:"Module"})),S=class S{constructor(e,n=S.DefaultNodeKeySuffixGenerator){y(this,"nodeCount");y(this,"hasNodeLabels");y(this,"hasEdgeLabels");y(this,"graph");y(this,"nodeNeighbors",new Map);y(this,"nodeKeys",new Map);y(this,"inDegrees",new Map);y(this,"outDegrees",new Map);this.graph=e,this.nodeCount=e.adjacencyMatrix.length,this.hasNodeLabels=e.labels!==void 0,this.hasEdgeLabels=e.edgeLabels!==void 0;for(let s=0;s<this.nodeCount;s++){const t=new Set;let a=0,i=0;for(let o=0;o<this.nodeCount;o++)e.adjacencyMatrix[s][o]===1&&(i++,t.add(o)),e.adjacencyMatrix[o][s]===1&&(a++,t.add(o));this.inDegrees.set(s,a),this.outDegrees.set(s,i),this.nodeNeighbors.set(s,[...t]);const r=i+"|"+a+n(e,s);this.nodeKeys.set(s,r)}}canonicalize(){const e=new Array(this.nodeCount).fill(1);this.partitionByPropertyKeys(e);let n=null,s=null,t=null;return this.individualizeDFS(e,[],(a,i)=>{const r=this.buildRepresentationGraph(a),o=this.buildGraphString(r);(t===null||o.localeCompare(t)<0)&&(n=r,s=new Array(a.length),a.forEach((l,c)=>s[l-1]=c),t=o)}),[n,t,s]}partitionByPropertyKeys(e){const n=new Map;for(let t=0;t<this.nodeCount;t++){const a=this.nodeKeys.get(t);n.has(a)?n.get(a).push(t):n.set(a,[t])}let s=1;Array.from(n.keys()).sort((t,a)=>t.localeCompare(a)).forEach(t=>{const a=n.get(t);a.forEach(i=>e[i]=s),s+=a.length})}isCanon(e){return new Set(e).size===this.nodeCount}individualizeDFS(e,n,s){if(this.isCanon(e)){s(e,n);return}if(this.individualizationRefinement(e),this.isCanon(e)){s(e,n);return}const t=this.getCurrentCells(e),a=Array.from(t.entries()).sort(([i],[r])=>i-r).filter(([,i])=>i.length>1)[0];for(const i of a[1]){const r=[...e];a[1].forEach(o=>{o!==i&&(r[o]=a[0]+1)}),this.individualizeDFS(r,[...n,i],s)}}individualizationRefinement(e){let n=!1;for(;!n;){n=!0;const s=e.map((i,r)=>[this.nodeNeighbors.get(r).map(c=>{let j=e[c].toString();return this.hasEdgeLabels&&(j+=";"+this.graph.edgeLabels[r][c]+";"+this.graph.edgeLabels[c][r]),j}).sort().join("|"),r]),t=new Map;for(const[i,r]of s){const o=e[r];t.has(o)||t.set(o,new Map);const l=t.get(o);l.has(i)||l.set(i,[]),l.get(i).push(r)}const a=Array.from(t.keys()).sort();for(const i of a){const r=Array.from(t.get(i).entries());if(r.length>1){n=!1,r.sort(([l],[c])=>c.localeCompare(l));let o=i;r.forEach(([,l])=>{l.forEach(c=>e[c]=o),o+=l.length});break}}}}getCurrentCells(e){const n=new Map;return e.forEach((s,t)=>{n.has(s)?n.get(s).push(t):n.set(s,[t])}),n}buildRepresentationGraph(e){const n={adjacencyMatrix:Array.from({length:this.nodeCount},()=>new Array(this.nodeCount))};for(let s=0;s<this.nodeCount;s++)for(let t=0;t<this.nodeCount;t++)n.adjacencyMatrix[e[s]-1][e[t]-1]=this.graph.adjacencyMatrix[s][t];if(this.hasNodeLabels&&(n.labels=new Array(this.nodeCount),e.forEach((s,t)=>n.labels[s-1]=this.graph.labels[t])),this.hasEdgeLabels){n.edgeLabels=Array.from({length:this.nodeCount},()=>new Array(this.nodeCount));for(let s=0;s<this.nodeCount;s++)for(let t=0;t<this.nodeCount;t++)n.edgeLabels[e[s]-1][e[t]-1]=this.graph.edgeLabels[s][t]}return n}buildGraphString(e){const n=[];for(let s=0;s<this.nodeCount;s++)for(let t=0;t<this.nodeCount;t++)e.adjacencyMatrix[s][t]===1&&(this.hasEdgeLabels?n.push(s+"-"+e.edgeLabels[s][t]+"-"+t):n.push(s+"-"+t));return this.hasNodeLabels?n.join("|")+";"+e.labels.join("|"):n.join("|")}};y(S,"DefaultNodeKeySuffixGenerator",(e,n)=>e.labels?e.labels[n]:"");let w=S;const v=Object.freeze(Object.defineProperty({__proto__:null,GraphCanon:w},Symbol.toStringTag,{value:"Module"}));class G{static find(e){const n=[],s=new Set,t=(a,i)=>{s.add(a),i.push(a);for(let r=0;r<e.adjacencyMatrix.length;r++)(e.adjacencyMatrix[a][r]===1||e.adjacencyMatrix[r][a]===1)&&(s.has(r)||t(r,i))};for(let a=0;a<e.adjacencyMatrix.length;a++)if(!s.has(a)){const i=[];t(a,i),n.push(i)}return n}}const z=Object.freeze(Object.defineProperty({__proto__:null,ConnectedComponents:G,canon:v,matching:_},Symbol.toStringTag,{value:"Module"}));h.graph=z,Object.defineProperty(h,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=ac-graph-core-js.umd.cjs.map
