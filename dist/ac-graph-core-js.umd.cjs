(function(b,y){typeof exports=="object"&&typeof module<"u"?y(exports):typeof define=="function"&&define.amd?define(["exports"],y):(b=typeof globalThis<"u"?globalThis:b||self,y(b.ACGraphCore={}))})(this,function(b){"use strict";var $=Object.defineProperty;var _=(b,y,w)=>y in b?$(b,y,{enumerable:!0,configurable:!0,writable:!0,value:w}):b[y]=w;var f=(b,y,w)=>_(b,typeof y!="symbol"?y+"":y,w);class y{}class w extends y{isSubgraphIsomorphic(e,n,r=[],t=[],s=null){const o=e.adjacencyMatrix.length,i=n.adjacencyMatrix.length;if(o>i)return!1;s===null&&(s=new Array(o).fill(-1));const a=e.labels&&n.labels,c=Array(i).fill(!1),l=Array(o).fill(-1),d=new Set(r),p=new Set(t),[h,m,E,k]=this.getInOutDegrees(e,n),D=h.map((S,u)=>E.map((g,j)=>g>=S&&k[j]>=m[u]&&(s[u]===-1||s[u]===j)&&(!a||d.has(u)||e.labels[u]===n.labels[j])?j:-1).filter(g=>g!==-1)),L=S=>{if(S===o)return this.checkCompatibility(e,n,l,p);for(const u of D[S])if(!c[u]){if(l[S]=u,c[u]=!0,this.isFeasible(e,n,l,S,p)&&L(S+1))return!0;c[u]=!1,l[S]=-1}return!1};return L(0)}getInOutDegrees(e,n){const r=e.adjacencyMatrix.map(i=>i.reduce((a,c)=>a+c,0)),t=[],s=n.adjacencyMatrix.map(i=>i.reduce((a,c)=>a+c,0)),o=[];return e.adjacencyMatrix.forEach((i,a)=>{t.push(i.map((c,l)=>e.adjacencyMatrix[l][a]).reduce((c,l)=>c+l,0))}),n.adjacencyMatrix.forEach((i,a)=>{o.push(i.map((c,l)=>n.adjacencyMatrix[l][a]).reduce((c,l)=>c+l,0))}),[r,t,s,o]}findAllSubgraphMonomorphisms(e,n,r=[],t=[],s=null){const o=e.adjacencyMatrix.length,i=n.adjacencyMatrix.length,a=[],c=new Set(r),l=new Set(t);if(o>i)return a;s===null&&(s=new Array(o).fill(-1));const d=e.labels&&n.labels,p=Array(i).fill(!1),h=Array(o).fill(-1),[m,E,k,D]=this.getInOutDegrees(e,n),L=m.map((u,g)=>k.map((j,v)=>j>=u&&D[v]>=E[g]&&(s[g]===-1||s[g]===v)&&(!d||c.has(g)||e.labels[g]===n.labels[v])?v:-1).filter(j=>j!==-1)),S=u=>{if(u===o){this.checkCompatibility(e,n,h,l)&&a.push([...h]);return}for(const g of L[u])p[g]||(h[u]=g,p[g]=!0,this.isFeasible(e,n,h,u,l)&&S(u+1),p[g]=!1,h[u]=-1)};return S(0),a}isFeasible(e,n,r,t,s){const o=e.edgeLabels&&n.edgeLabels;for(let i=0;i<t;i++)if(e.adjacencyMatrix[t][i]&&(!n.adjacencyMatrix[r[t]][r[i]]||o&&!s.has(t+","+i)&&e.edgeLabels[t][i]!==n.edgeLabels[r[t]][r[i]])||e.adjacencyMatrix[i][t]&&(!n.adjacencyMatrix[r[i]][r[t]]||o&&!s.has(i+","+t)&&e.edgeLabels[i][t]!==n.edgeLabels[r[i]][r[t]]))return!1;return!0}checkCompatibility(e,n,r,t){const s=e.edgeLabels&&n.edgeLabels,o=e.adjacencyMatrix.length;for(let i=0;i<o;i++)for(let a=0;a<o;a++)if(e.adjacencyMatrix[i][a]&&(!n.adjacencyMatrix[r[i]][r[a]]||s&&!t.has(i+","+a)&&e.edgeLabels[i][a]!==n.edgeLabels[r[i]][r[a]]))return!1;return!0}}const O=Object.freeze(Object.defineProperty({__proto__:null,GraphMatcher:y,UllmannGraphMatcher:w},Symbol.toStringTag,{value:"Module"}));class x{constructor(e){f(this,"mappings");f(this,"cycles",[]);if(this.mappings=e,new Set(e.values()).size!==e.size)throw"Automorphism is not bijective";const n=new Set,r=[...e.keys()].sort();for(const t of r)if(!n.has(t)){n.add(t);const s=[t];for(;e.has(s[s.length-1]);){const o=e.get(s[s.length-1]);if(n.add(o),o!==s[0])s.push(o);else break}s.length>1&&this.cycles.push(s)}}apply(e){return this.mappings.get(e)}compose(e){const n=new Map;for(const r of this.mappings.keys()){const t=e.apply(r),s=this.apply(t);n.set(r,s)}return new x(n)}reverse(){return new x(new Map([...this.mappings.entries()].map(([e,n])=>[n,e])))}equals(e){for(const n of this.mappings.keys())if(this.mappings.get(n)!==e.mappings.get(n))return!1;return!0}isIdentity(){for(const e of this.mappings.keys())if(this.mappings.get(e)!==e)return!1;return!0}toString(){return this.cycles.length===0?"()":this.cycles.map(e=>`(${e.join(" ")})`).sort().join("")}}class A{constructor(e,n){f(this,"generators");if(e.some(r=>r.isIdentity()))this.generators=[...e];else{const r=new x(new Map(Array.from({length:n},(t,s)=>[s,s])));this.generators=[r,...e]}}orbitOf(e){const n=new Set;n.add(e);for(const r of this.generators)n.add(r.apply(e));return Array.from(n).sort()}stabilizerOf(e){return this.generators.filter(n=>n.apply(e)===e)}stabilizerSizeOf(e){return this.generators.reduce((n,r)=>n+=r.apply(e)===e?1:0,0)}orbitSizeOf(e){return this.generators.length/this.stabilizerSizeOf(e)}orbits(){const e=new Set,n=[];for(const r of this.generators[0].mappings.keys())if(!e.has(r)){const t=this.orbitOf(r);t.forEach(s=>e.add(s)),n.push(t)}return n}closure(){const e=[],n=new Set,r=s=>{const o=s.toString();n.has(o)||(e.push(s),n.add(o))},t=[...this.generators,...this.generators.map(s=>s.reverse())];for(t.forEach(s=>r(s));t.length>0;){const s=t.pop();for(const o of e)r(s.compose(o)),r(o.compose(s))}return e}toString(){return"["+this.generators.map(e=>e.toString()).join(", ")+"]"}}const M=class M{constructor(e,n=M.DefaultNodeKeySuffixGenerator,r=M.DefaultNodePropertiesMapper,t=M.DefaultNodePropertiesCanonKeyMapper){f(this,"nodeCount");f(this,"hasNodeLabels");f(this,"hasNodeProperties");f(this,"hasEdgeLabels");f(this,"isSymmetric");f(this,"graph");f(this,"nodeNeighbors",new Map);f(this,"nodeKeys",new Map);f(this,"nodePropertiesMapper");f(this,"nodePropertiesCanonKeyMapper");f(this,"graphStringBuilder");this.graph=e,this.nodeCount=e.adjacencyMatrix.length,this.hasNodeLabels=e.labels!==void 0,this.hasNodeProperties=e.nodeProperties!==void 0,this.hasEdgeLabels=e.edgeLabels!==void 0,this.nodePropertiesMapper=r,this.nodePropertiesCanonKeyMapper=t;let s=!0;for(let o=0;o<this.nodeCount;o++){const i=new Set;let a=0,c=0;for(let d=0;d<this.nodeCount;d++){const p=e.adjacencyMatrix[o][d],h=e.adjacencyMatrix[d][o];p===1&&(c++,i.add(d)),h===1&&(a++,i.add(d)),p!==h&&(s=!1)}this.nodeNeighbors.set(o,[...i]);const l=c+"|"+a+"|"+n(e,o);this.nodeKeys.set(o,l)}this.isSymmetric=s,this.graphStringBuilder=this.buildGraphStringCurry()}canonicalize(){const e=new Array(this.nodeCount).fill(1);this.partitionByPropertyKeys(e);const n=new Map,r=new Set;this.individualizeDFS(e,[],r,this.handleRepresentationCurry(n,r));const t=[...n.keys()].sort((l,d)=>l.localeCompare(d))[0],s=n.get(t),o=new Array(this.nodeCount),i=new Array(o.length);[...s.partitions[0].entries()].forEach(([l,d])=>{o[d]=l,i[l-1]=d});const a=this.buildRepresentationGraph(o),c=new Map;return[...n.values()].forEach(l=>[...l.automorphisms.entries()].forEach(([d,p])=>c.set(d,p))),[a,this.buildGraphString(a),i,new A([...c.values()],this.nodeCount)]}handleRepresentationCurry(e,n){const r=Array.from({length:this.nodeCount},(t,s)=>s+1);return(t,s)=>{const o=new Map;t.forEach((c,l)=>o.set(c,l));const i=r.map(c=>this.nodeNeighbors.get(o.get(c)).map(l=>t[l]).sort().join(";")).join("|");let a=e.get(i);a===void 0&&(a={partitions:[],automorphisms:new Map},e.set(i,a));for(const c of a.partitions){const l=new Map;for(let h=0;h<t.length;h++){const m=c.get(t[h]);l.set(h,m)}const d=new x(l),p=d.toString();if(!a.automorphisms.has(p)){a.automorphisms.set(p,d);for(const h of d.mappings)if(h[0]!==h[1])for(let m=0;m<s.length;m++)s[m]===h[0]?n.add([...s.slice(0,m),h[1]].join("|")):s[m]===h[1]&&n.add([...s.slice(0,m),h[0]].join("|"))}}a.partitions.push(o)}}aut(){const e=new Array(this.nodeCount).fill(1);this.partitionByPropertyKeys(e);const n=new Map,r=new Set;this.individualizeDFS(e,[],r,this.handleRepresentationCurry(n,r));const t=new Map;return[...n.values()].forEach(s=>[...s.automorphisms.entries()].forEach(([o,i])=>t.set(o,i))),new A([...t.values()],this.nodeCount)}partitionByPropertyKeys(e){const n=new Map;for(let t=0;t<this.nodeCount;t++){const s=this.nodeKeys.get(t);n.has(s)?n.get(s).push(t):n.set(s,[t])}let r=1;Array.from(n.keys()).sort((t,s)=>t.localeCompare(s)).forEach(t=>{const s=n.get(t);s.forEach(o=>e[o]=r),r+=s.length})}isCanon(e){return new Set(e).size===this.nodeCount}individualizeDFS(e,n,r,t){if(this.isCanon(e)){t(e,n);return}if(this.individualizationRefinement(e),this.isCanon(e)){t(e,n);return}const s=this.getCellToBreak(e);for(const o of s[1])e[o]=s[0]+1;for(const o of s[1]){const i=[...n,o];r.has(i.join("|"))||(e[o]=s[0],this.individualizeDFS([...e],i,r,t),e[o]=s[0]+1)}}individualizationRefinement(e){let n=!1;for(;!n;){n=!0;const r=e.map((s,o)=>this.nodeNeighbors.get(o).map(a=>{if(this.hasEdgeLabels){const c=this.graph.edgeLabels;return this.isSymmetric?`${e[a]};${c[o][a]}`:`${e[a]};${c[o][a]};${c[a][o]}`}return e[a].toString()}).sort().join("|")),t=new Map;r.forEach((s,o)=>{const i=e[o];let a=t.get(i);a===void 0&&(a=new Map,t.set(i,a));let c=a.get(s);c===void 0&&(c=[],a.set(s,c)),c.push(o)});for(let s=1;s<=this.nodeCount;s++){const o=t.get(s);if(o===void 0||o.size<2)continue;n=!1;const i=[...o.keys()].sort((c,l)=>l.localeCompare(c));let a=s;for(const c of i){const l=o.get(c);l.forEach(d=>e[d]=a),a+=l.length}break}}}getCellToBreak(e){const n=Array.from({length:e.length},()=>[]);e.forEach((r,t)=>n[r-1].push(t));for(let r=0;r<n.length;r++)if(n[r].length>1)return[r+1,n[r]];return[1,n[0]]}buildRepresentationGraph(e){const n=e.map(t=>t-1),r={adjacencyMatrix:Array.from({length:this.nodeCount},()=>new Array(this.nodeCount))};if(this.isSymmetric)for(let t=0;t<this.nodeCount;t++){const s=n[t],o=this.graph.adjacencyMatrix[t];for(let i=t;i<this.nodeCount;i++)r.adjacencyMatrix[s][n[i]]=o[i],r.adjacencyMatrix[n[i]][s]=o[i]}else for(let t=0;t<this.nodeCount;t++){const s=n[t],o=this.graph.adjacencyMatrix[t];for(let i=0;i<this.nodeCount;i++)r.adjacencyMatrix[s][n[i]]=o[i]}if(this.hasNodeLabels&&(r.labels=new Array(this.nodeCount),n.forEach((t,s)=>r.labels[t]=this.graph.labels[s])),this.hasNodeProperties&&(r.nodeProperties=new Array(this.nodeCount),n.forEach((t,s)=>r.nodeProperties[t]=this.nodePropertiesMapper(this.graph,s,n))),this.hasEdgeLabels)if(r.edgeLabels=Array.from({length:this.nodeCount},()=>new Array(this.nodeCount)),this.isSymmetric)for(let t=0;t<this.nodeCount;t++){const s=n[t],o=this.graph.edgeLabels[t];for(let i=t;i<this.nodeCount;i++)r.edgeLabels[s][n[i]]=o[i],r.edgeLabels[n[i]][s]=o[i]}else for(let t=0;t<this.nodeCount;t++){const s=n[t],o=this.graph.edgeLabels[t];for(let i=0;i<this.nodeCount;i++)r.edgeLabels[s][n[i]]=o[i]}return r}buildGraphStringCurry(){const e=this.hasEdgeLabels?(t,s,o)=>`${s}-${t.edgeLabels[s][o]}-${o}`:(t,s,o)=>`${s}-${o}`,n=this.hasNodeProperties?(t,s)=>{const o=this.nodePropertiesCanonKeyMapper(t,s);return o.length>0?`{${o}}`:""}:(t,s)=>"",r=this.hasNodeLabels?t=>";"+t.labels.map((s,o)=>s+n(t,o)).join("|"):this.hasNodeProperties?t=>";"+t.nodeProperties.map((s,o)=>this.nodePropertiesCanonKeyMapper(t,o)).join("|"):t=>"";return this.isSymmetric?t=>{const s=[];for(let o=0;o<this.nodeCount;o++){const i=t.adjacencyMatrix[o];for(let a=o;a<this.nodeCount;a++)i[a]===1&&s.push(e(t,o,a))}return M.KEY_VERSION+";"+t.adjacencyMatrix.length+";sym;"+s.join("|")+r(t)}:t=>{const s=[];for(let o=0;o<this.nodeCount;o++){const i=t.adjacencyMatrix[o];for(let a=0;a<this.nodeCount;a++)i[a]===1&&s.push(e(t,o,a))}return M.KEY_VERSION+";"+t.adjacencyMatrix.length+";"+s.join("|")+r(t)}}buildGraphString(e){return this.graphStringBuilder(e)}};f(M,"KEY_VERSION","v2"),f(M,"DefaultNodeKeySuffixGenerator",(e,n)=>e.labels?e.labels[n]:""),f(M,"DefaultNodePropertiesMapper",(e,n,r)=>e.nodeProperties&&e.nodeProperties[n]?new Map(e.nodeProperties[n]):void 0),f(M,"DefaultNodePropertiesCanonKeyMapper",(e,n)=>"");let P=M;const I=Object.freeze(Object.defineProperty({__proto__:null,GraphCanon:P},Symbol.toStringTag,{value:"Module"}));class K{static find(e){const n=[],r=new Set,t=(s,o)=>{r.add(s),o.push(s);for(let i=0;i<e.adjacencyMatrix.length;i++)(e.adjacencyMatrix[s][i]===1||e.adjacencyMatrix[i][s]===1)&&(r.has(i)||t(i,o))};for(let s=0;s<e.adjacencyMatrix.length;s++)if(!r.has(s)){const o=[];t(s,o),n.push(o)}return n}}function N(C){const e=C.adjacencyMatrix.length;let n=[];for(let r=0;r<e;r++)for(let t=r+1;t<e;t++)C.adjacencyMatrix[r][t]!==0&&n.push(`e ${r+1} ${t+1}`);return[`p edge ${e} ${n.length}`,...n].join(`
`)}const z=Object.freeze(Object.defineProperty({__proto__:null,ConnectedComponents:K,canon:I,matching:O,symmetricGraphToDIMACS:N},Symbol.toStringTag,{value:"Module"}));b.graph=z,Object.defineProperty(b,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=ac-graph-core-js.umd.cjs.map
