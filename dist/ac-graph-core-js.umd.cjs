(function(M,g){typeof exports=="object"&&typeof module<"u"?g(exports):typeof define=="function"&&define.amd?define(["exports"],g):(M=typeof globalThis<"u"?globalThis:M||self,g(M.ACGraphCore={}))})(this,function(M){"use strict";var $=Object.defineProperty;var _=(M,g,w)=>g in M?$(M,g,{enumerable:!0,configurable:!0,writable:!0,value:w}):M[g]=w;var h=(M,g,w)=>_(M,typeof g!="symbol"?g+"":g,w);class g{}class w extends g{isSubgraphIsomorphic(e,n,i=[],t=[],s=null){const o=e.adjacencyMatrix.length,r=n.adjacencyMatrix.length;if(o>r)return!1;s===null&&(s=new Array(o).fill(-1));const a=e.labels&&n.labels,c=Array(r).fill(!1),l=Array(o).fill(-1),f=new Set(i),y=new Set(t),[d,p,E,D]=this.getInOutDegrees(e,n),k=d.map((S,u)=>E.map((b,j)=>b>=S&&D[j]>=p[u]&&(s[u]===-1||s[u]===j)&&(!a||f.has(u)||e.labels[u]===n.labels[j])?j:-1).filter(b=>b!==-1)),L=S=>{if(S===o)return this.checkCompatibility(e,n,l,y);for(const u of k[S])if(!c[u]){if(l[S]=u,c[u]=!0,this.isFeasible(e,n,l,S,y)&&L(S+1))return!0;c[u]=!1,l[S]=-1}return!1};return L(0)}getInOutDegrees(e,n){const i=e.adjacencyMatrix.map(r=>r.reduce((a,c)=>a+c,0)),t=[],s=n.adjacencyMatrix.map(r=>r.reduce((a,c)=>a+c,0)),o=[];return e.adjacencyMatrix.forEach((r,a)=>{t.push(r.map((c,l)=>e.adjacencyMatrix[l][a]).reduce((c,l)=>c+l,0))}),n.adjacencyMatrix.forEach((r,a)=>{o.push(r.map((c,l)=>n.adjacencyMatrix[l][a]).reduce((c,l)=>c+l,0))}),[i,t,s,o]}findAllSubgraphMonomorphisms(e,n,i=[],t=[],s=null){const o=e.adjacencyMatrix.length,r=n.adjacencyMatrix.length,a=[],c=new Set(i),l=new Set(t);if(o>r)return a;s===null&&(s=new Array(o).fill(-1));const f=e.labels&&n.labels,y=Array(r).fill(!1),d=Array(o).fill(-1),[p,E,D,k]=this.getInOutDegrees(e,n),L=p.map((u,b)=>D.map((j,v)=>j>=u&&k[v]>=E[b]&&(s[b]===-1||s[b]===v)&&(!f||c.has(b)||e.labels[b]===n.labels[v])?v:-1).filter(j=>j!==-1)),S=u=>{if(u===o){this.checkCompatibility(e,n,d,l)&&a.push([...d]);return}for(const b of L[u])y[b]||(d[u]=b,y[b]=!0,this.isFeasible(e,n,d,u,l)&&S(u+1),y[b]=!1,d[u]=-1)};return S(0),a}isFeasible(e,n,i,t,s){const o=e.edgeLabels&&n.edgeLabels;for(let r=0;r<t;r++)if(e.adjacencyMatrix[t][r]&&(!n.adjacencyMatrix[i[t]][i[r]]||o&&!s.has(t+","+r)&&e.edgeLabels[t][r]!==n.edgeLabels[i[t]][i[r]])||e.adjacencyMatrix[r][t]&&(!n.adjacencyMatrix[i[r]][i[t]]||o&&!s.has(r+","+t)&&e.edgeLabels[r][t]!==n.edgeLabels[i[r]][i[t]]))return!1;return!0}checkCompatibility(e,n,i,t){const s=e.edgeLabels&&n.edgeLabels,o=e.adjacencyMatrix.length;for(let r=0;r<o;r++)for(let a=0;a<o;a++)if(e.adjacencyMatrix[r][a]&&(!n.adjacencyMatrix[i[r]][i[a]]||s&&!t.has(r+","+a)&&e.edgeLabels[r][a]!==n.edgeLabels[i[r]][i[a]]))return!1;return!0}}const A=Object.freeze(Object.defineProperty({__proto__:null,GraphMatcher:g,UllmannGraphMatcher:w},Symbol.toStringTag,{value:"Module"}));class x{constructor(e){h(this,"mappings");h(this,"cycles",[]);if(this.mappings=e,new Set(e.values()).size!==e.size)throw"Automorphism is not bijective";const n=new Set,i=[...e.keys()].sort();for(const t of i)if(!n.has(t)){n.add(t);const s=[t];for(;e.has(s[s.length-1]);){const o=e.get(s[s.length-1]);if(n.add(o),o!==s[0])s.push(o);else break}s.length>1&&this.cycles.push(s)}}apply(e){return this.mappings.get(e)}compose(e){const n=new Map;for(const i of this.mappings.keys()){const t=e.apply(i),s=this.apply(t);n.set(i,s)}return new x(n)}reverse(){return new x(new Map([...this.mappings.entries()].map(([e,n])=>[n,e])))}equals(e){for(const n of this.mappings.keys())if(this.mappings.get(n)!==e.mappings.get(n))return!1;return!0}isIdentity(){for(const e of this.mappings.keys())if(this.mappings.get(e)!==e)return!1;return!0}toString(){return this.cycles.length===0?"()":this.cycles.map(e=>`(${e.join(" ")})`).sort().join("")}}class K{constructor(e,n){h(this,"generators");if(e.some(i=>i.isIdentity()))this.generators=[...e];else{const i=new x(new Map(Array.from({length:n},(t,s)=>[s,s])));this.generators=[i,...e]}}orbitOf(e){const n=new Set;n.add(e);for(const i of this.generators)n.add(i.apply(e));return Array.from(n).sort()}stabilizerOf(e){return this.generators.filter(n=>n.apply(e)===e)}stabilizerSizeOf(e){return this.generators.reduce((n,i)=>n+=i.apply(e)===e?1:0,0)}orbitSizeOf(e){return this.generators.length/this.stabilizerSizeOf(e)}orbits(){const e=new Set,n=[];for(const i of this.generators[0].mappings.keys())if(!e.has(i)){const t=this.orbitOf(i);t.forEach(s=>e.add(s)),n.push(t)}return n}closure(){const e=[],n=new Set,i=s=>{const o=s.toString();n.has(o)||(e.push(s),n.add(o))},t=[...this.generators,...this.generators.map(s=>s.reverse())];for(t.forEach(s=>i(s));t.length>0;){const s=t.pop();for(const o of e)i(s.compose(o)),i(o.compose(s))}return e}toString(){return"["+this.generators.map(e=>e.toString()).join(", ")+"]"}}const m=class m{constructor(e,n=m.DefaultNodeKeySuffixGenerator,i=m.DefaultNodePropertiesMapper,t=m.DefaultNodeLabelCanonKeyMapper,s=m.DefaultNodePropertiesCanonKeyMapper){h(this,"nodeCount");h(this,"hasNodeLabels");h(this,"hasNodeProperties");h(this,"hasEdgeLabels");h(this,"isSymmetric");h(this,"graph");h(this,"nodeNeighbors",new Map);h(this,"nodeKeys",new Map);h(this,"nodePropertiesMapper");h(this,"nodeLabelCanonKeyMapper");h(this,"nodePropertiesCanonKeyMapper");h(this,"graphStringBuilder");this.graph=e,this.nodeCount=e.adjacencyMatrix.length,this.hasNodeLabels=e.labels!==void 0,this.hasNodeProperties=e.nodeProperties!==void 0,this.hasEdgeLabels=e.edgeLabels!==void 0,this.nodePropertiesMapper=i,this.nodeLabelCanonKeyMapper=t,this.nodePropertiesCanonKeyMapper=s;let o=!0;for(let r=0;r<this.nodeCount;r++){const a=new Set;let c=0,l=0;for(let y=0;y<this.nodeCount;y++){const d=e.adjacencyMatrix[r][y],p=e.adjacencyMatrix[y][r];d===1&&(l++,a.add(y)),p===1&&(c++,a.add(y)),d!==p&&(o=!1)}this.nodeNeighbors.set(r,[...a]);const f=l+"|"+c+"|"+n(e,r);this.nodeKeys.set(r,f)}this.isSymmetric=o,this.graphStringBuilder=this.buildGraphStringCurry()}canonicalize(){const e=new Array(this.nodeCount).fill(1);this.partitionByPropertyKeys(e);const n=new Map,i=new Set;this.individualizeDFS(e,[],i,this.handleRepresentationCurry(n,i));const t=[...n.keys()].sort((l,f)=>l.localeCompare(f))[0],s=n.get(t),o=new Array(this.nodeCount),r=new Array(o.length);[...s.partitions[0].entries()].forEach(([l,f])=>{o[f]=l,r[l-1]=f});const a=this.buildRepresentationGraph(o),c=new Map;return[...n.values()].forEach(l=>[...l.automorphisms.entries()].forEach(([f,y])=>c.set(f,y))),[a,this.buildGraphString(a),r,new K([...c.values()],this.nodeCount)]}handleRepresentationCurry(e,n){const i=Array.from({length:this.nodeCount},(t,s)=>s+1);return(t,s)=>{const o=new Map;t.forEach((c,l)=>o.set(c,l));const r=i.map(c=>this.nodeNeighbors.get(o.get(c)).map(l=>t[l]).sort().join(";")).join("|");let a=e.get(r);a===void 0&&(a={partitions:[],automorphisms:new Map},e.set(r,a));for(const c of a.partitions){const l=new Map;for(let d=0;d<t.length;d++){const p=c.get(t[d]);l.set(d,p)}const f=new x(l),y=f.toString();if(!a.automorphisms.has(y)){a.automorphisms.set(y,f);for(const d of f.mappings)if(d[0]!==d[1])for(let p=0;p<s.length;p++)s[p]===d[0]?n.add([...s.slice(0,p),d[1]].join("|")):s[p]===d[1]&&n.add([...s.slice(0,p),d[0]].join("|"))}}a.partitions.push(o)}}aut(){const e=new Array(this.nodeCount).fill(1);this.partitionByPropertyKeys(e);const n=new Map,i=new Set;this.individualizeDFS(e,[],i,this.handleRepresentationCurry(n,i));const t=new Map;return[...n.values()].forEach(s=>[...s.automorphisms.entries()].forEach(([o,r])=>t.set(o,r))),new K([...t.values()],this.nodeCount)}partitionByPropertyKeys(e){const n=new Map;for(let t=0;t<this.nodeCount;t++){const s=this.nodeKeys.get(t);n.has(s)?n.get(s).push(t):n.set(s,[t])}let i=1;Array.from(n.keys()).sort((t,s)=>t.localeCompare(s)).forEach(t=>{const s=n.get(t);s.forEach(o=>e[o]=i),i+=s.length})}isCanon(e){return new Set(e).size===this.nodeCount}individualizeDFS(e,n,i,t){if(this.isCanon(e)){t(e,n);return}if(this.individualizationRefinement(e),this.isCanon(e)){t(e,n);return}const s=this.getCellToBreak(e);for(const o of s[1])e[o]=s[0]+1;for(const o of s[1]){const r=[...n,o];i.has(r.join("|"))||(e[o]=s[0],this.individualizeDFS([...e],r,i,t),e[o]=s[0]+1)}}individualizationRefinement(e){let n=!1;for(;!n;){n=!0;const i=e.map((s,o)=>this.nodeNeighbors.get(o).map(a=>{if(this.hasEdgeLabels){const c=this.graph.edgeLabels;return this.isSymmetric?`${e[a]};${c[o][a]}`:`${e[a]};${c[o][a]};${c[a][o]}`}return e[a].toString()}).sort().join("|")),t=new Map;i.forEach((s,o)=>{const r=e[o];let a=t.get(r);a===void 0&&(a=new Map,t.set(r,a));let c=a.get(s);c===void 0&&(c=[],a.set(s,c)),c.push(o)});for(let s=1;s<=this.nodeCount;s++){const o=t.get(s);if(o===void 0||o.size<2)continue;n=!1;const r=[...o.keys()].sort((c,l)=>l.localeCompare(c));let a=s;for(const c of r){const l=o.get(c);l.forEach(f=>e[f]=a),a+=l.length}break}}}getCellToBreak(e){const n=Array.from({length:e.length},()=>[]);e.forEach((i,t)=>n[i-1].push(t));for(let i=0;i<n.length;i++)if(n[i].length>1)return[i+1,n[i]];return[1,n[0]]}buildRepresentationGraph(e){const n=e.map(t=>t-1),i={adjacencyMatrix:Array.from({length:this.nodeCount},()=>new Array(this.nodeCount))};if(this.isSymmetric)for(let t=0;t<this.nodeCount;t++){const s=n[t],o=this.graph.adjacencyMatrix[t];for(let r=t;r<this.nodeCount;r++)i.adjacencyMatrix[s][n[r]]=o[r],i.adjacencyMatrix[n[r]][s]=o[r]}else for(let t=0;t<this.nodeCount;t++){const s=n[t],o=this.graph.adjacencyMatrix[t];for(let r=0;r<this.nodeCount;r++)i.adjacencyMatrix[s][n[r]]=o[r]}if(this.hasNodeLabels&&(i.labels=new Array(this.nodeCount),n.forEach((t,s)=>i.labels[t]=this.graph.labels[s])),this.hasNodeProperties&&(i.nodeProperties=new Array(this.nodeCount),n.forEach((t,s)=>i.nodeProperties[t]=this.nodePropertiesMapper(this.graph,s,n))),this.hasEdgeLabels)if(i.edgeLabels=Array.from({length:this.nodeCount},()=>new Array(this.nodeCount)),this.isSymmetric)for(let t=0;t<this.nodeCount;t++){const s=n[t],o=this.graph.edgeLabels[t];for(let r=t;r<this.nodeCount;r++)i.edgeLabels[s][n[r]]=o[r],i.edgeLabels[n[r]][s]=o[r]}else for(let t=0;t<this.nodeCount;t++){const s=n[t],o=this.graph.edgeLabels[t];for(let r=0;r<this.nodeCount;r++)i.edgeLabels[s][n[r]]=o[r]}return i}buildGraphStringCurry(){const e=this.hasEdgeLabels?(t,s,o)=>`${s}-${t.edgeLabels[s][o]}-${o}`:(t,s,o)=>`${s}-${o}`,n=this.hasNodeProperties?(t,s)=>{const o=this.nodePropertiesCanonKeyMapper(t,s);return o.length>0?`{${o}}`:""}:(t,s)=>"",i=this.hasNodeLabels?t=>";"+t.labels.map((s,o)=>this.nodeLabelCanonKeyMapper(t,o)+n(t,o)).join("|"):this.hasNodeProperties?t=>";"+t.nodeProperties.map((s,o)=>this.nodePropertiesCanonKeyMapper(t,o)).join("|"):t=>"";return this.isSymmetric?t=>{const s=[];for(let o=0;o<this.nodeCount;o++){const r=t.adjacencyMatrix[o];for(let a=o;a<this.nodeCount;a++)r[a]===1&&s.push(e(t,o,a))}return m.KEY_VERSION+";"+t.adjacencyMatrix.length+";sym;"+s.join("|")+i(t)}:t=>{const s=[];for(let o=0;o<this.nodeCount;o++){const r=t.adjacencyMatrix[o];for(let a=0;a<this.nodeCount;a++)r[a]===1&&s.push(e(t,o,a))}return m.KEY_VERSION+";"+t.adjacencyMatrix.length+";"+s.join("|")+i(t)}}buildGraphString(e){return this.graphStringBuilder(e)}};h(m,"KEY_VERSION","v2"),h(m,"DefaultNodeKeySuffixGenerator",(e,n)=>e.labels?e.labels[n]:""),h(m,"DefaultNodePropertiesMapper",(e,n,i)=>e.nodeProperties&&e.nodeProperties[n]?new Map(e.nodeProperties[n]):void 0),h(m,"DefaultNodeLabelCanonKeyMapper",(e,n)=>e.labels?e.labels[n]:""),h(m,"DefaultNodePropertiesCanonKeyMapper",(e,n)=>"");let P=m;const O=Object.freeze(Object.defineProperty({__proto__:null,GraphCanon:P},Symbol.toStringTag,{value:"Module"}));class I{static find(e){const n=[],i=new Set,t=(s,o)=>{i.add(s),o.push(s);for(let r=0;r<e.adjacencyMatrix.length;r++)(e.adjacencyMatrix[s][r]===1||e.adjacencyMatrix[r][s]===1)&&(i.has(r)||t(r,o))};for(let s=0;s<e.adjacencyMatrix.length;s++)if(!i.has(s)){const o=[];t(s,o),n.push(o)}return n}}function N(C){const e=C.adjacencyMatrix.length;let n=[];for(let i=0;i<e;i++)for(let t=i+1;t<e;t++)C.adjacencyMatrix[i][t]!==0&&n.push(`e ${i+1} ${t+1}`);return[`p edge ${e} ${n.length}`,...n].join(`
`)}const z=Object.freeze(Object.defineProperty({__proto__:null,ConnectedComponents:I,canon:O,matching:A,symmetricGraphToDIMACS:N},Symbol.toStringTag,{value:"Module"}));M.graph=z,Object.defineProperty(M,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=ac-graph-core-js.umd.cjs.map
