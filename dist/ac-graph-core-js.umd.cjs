(function(S,j){typeof exports=="object"&&typeof module<"u"?j(exports):typeof define=="function"&&define.amd?define(["exports"],j):(S=typeof globalThis<"u"?globalThis:S||self,j(S.ACGraphCore={}))})(this,function(S){"use strict";var O=Object.defineProperty;var z=(S,j,C)=>j in S?O(S,j,{enumerable:!0,configurable:!0,writable:!0,value:C}):S[j]=C;var p=(S,j,C)=>z(S,typeof j!="symbol"?j+"":j,C);class j{}class C extends j{isSubgraphIsomorphic(o,r,i=[],e=[],n=null){const t=o.adjacencyMatrix.length,s=r.adjacencyMatrix.length;if(t>s)return!1;n===null&&(n=new Array(t).fill(-1));const a=o.labels&&r.labels,l=Array(s).fill(!1),h=Array(t).fill(-1),f=new Set(i),m=new Set(e),[M,c,y,g]=this.getInOutDegrees(o,r),L=M.map((u,d)=>y.map((b,x)=>b>=u&&g[x]>=c[d]&&(n[d]===-1||n[d]===x)&&(!a||f.has(d)||o.labels[d]===r.labels[x])?x:-1).filter(b=>b!==-1)),P=u=>{if(u===t)return this.checkCompatibility(o,r,h,m);for(const d of L[u])if(!l[d]){if(h[u]=d,l[d]=!0,this.isFeasible(o,r,h,u,m)&&P(u+1))return!0;l[d]=!1,h[u]=-1}return!1};return P(0)}getInOutDegrees(o,r){const i=o.adjacencyMatrix.map(s=>s.reduce((a,l)=>a+l,0)),e=[],n=r.adjacencyMatrix.map(s=>s.reduce((a,l)=>a+l,0)),t=[];return o.adjacencyMatrix.forEach((s,a)=>{e.push(s.map((l,h)=>o.adjacencyMatrix[h][a]).reduce((l,h)=>l+h,0))}),r.adjacencyMatrix.forEach((s,a)=>{t.push(s.map((l,h)=>r.adjacencyMatrix[h][a]).reduce((l,h)=>l+h,0))}),[i,e,n,t]}findAllSubgraphMonomorphisms(o,r,i=[],e=[],n=null){const t=o.adjacencyMatrix.length,s=r.adjacencyMatrix.length,a=[],l=new Set(i),h=new Set(e);if(t>s)return a;n===null&&(n=new Array(t).fill(-1));const f=o.labels&&r.labels,m=Array(s).fill(!1),M=Array(t).fill(-1),[c,y,g,L]=this.getInOutDegrees(o,r),P=c.map((d,b)=>g.map((x,D)=>x>=d&&L[D]>=y[b]&&(n[b]===-1||n[b]===D)&&(!f||l.has(b)||o.labels[b]===r.labels[D])?D:-1).filter(x=>x!==-1)),u=d=>{if(d===t){this.checkCompatibility(o,r,M,h)&&a.push([...M]);return}for(const b of P[d])m[b]||(M[d]=b,m[b]=!0,this.isFeasible(o,r,M,d,h)&&u(d+1),m[b]=!1,M[d]=-1)};return u(0),a}isFeasible(o,r,i,e,n){const t=o.edgeLabels&&r.edgeLabels;for(let s=0;s<e;s++)if(o.adjacencyMatrix[e][s]&&(!r.adjacencyMatrix[i[e]][i[s]]||t&&!n.has(e+","+s)&&o.edgeLabels[e][s]!==r.edgeLabels[i[e]][i[s]])||o.adjacencyMatrix[s][e]&&(!r.adjacencyMatrix[i[s]][i[e]]||t&&!n.has(s+","+e)&&o.edgeLabels[s][e]!==r.edgeLabels[i[s]][i[e]]))return!1;return!0}checkCompatibility(o,r,i,e){const n=o.edgeLabels&&r.edgeLabels,t=o.adjacencyMatrix.length;for(let s=0;s<t;s++)for(let a=0;a<t;a++)if(o.adjacencyMatrix[s][a]&&(!r.adjacencyMatrix[i[s]][i[a]]||n&&!e.has(s+","+a)&&o.edgeLabels[s][a]!==r.edgeLabels[i[s]][i[a]]))return!1;return!0}}const E=Object.freeze(Object.defineProperty({__proto__:null,GraphMatcher:j,UllmannGraphMatcher:C},Symbol.toStringTag,{value:"Module"})),w=class w{constructor(o,r=w.DefaultNodeKeySuffixGenerator,i=w.DefaultNodePropertiesMapper,e=w.DefaultNodePropertiesCanonKeyMapper){p(this,"nodeCount");p(this,"hasNodeLabels");p(this,"hasNodeProperties");p(this,"hasEdgeLabels");p(this,"isSymmetric");p(this,"graph");p(this,"nodeNeighbors",new Map);p(this,"nodeKeys",new Map);p(this,"nodePropertiesMapper");p(this,"nodePropertiesCanonKeyMapper");p(this,"graphStringBuilder");this.graph=o,this.nodeCount=o.adjacencyMatrix.length,this.hasNodeLabels=o.labels!==void 0,this.hasNodeProperties=o.nodeProperties!==void 0,this.hasEdgeLabels=o.edgeLabels!==void 0,this.nodePropertiesMapper=i,this.nodePropertiesCanonKeyMapper=e;let n=!0;for(let t=0;t<this.nodeCount;t++){const s=new Set;let a=0,l=0;for(let f=0;f<this.nodeCount;f++){const m=o.adjacencyMatrix[t][f],M=o.adjacencyMatrix[f][t];m===1&&(l++,s.add(f)),M===1&&(a++,s.add(f)),m!==M&&(n=!1)}this.nodeNeighbors.set(t,[...s]);const h=l+"|"+a+"|"+r(o,t);this.nodeKeys.set(t,h)}this.isSymmetric=n,this.graphStringBuilder=this.buildGraphStringCurry()}canonicalize(){const o=new Array(this.nodeCount).fill(1);this.partitionByPropertyKeys(o);let r=null,i=null,e=null;const n=[],t=new Map,s=Array.from({length:this.nodeCount},l=>new Set),a=new Set;return this.individualizeDFS(o,[],a,(l,h)=>{for(const c of n){const y=new Map;for(let u=0;u<l.length;u++){const d=c.get(l[u]);if(d!==u){const b=[d<u?d:u,u<d?d:u];y.set(b.join("|"),b)}}const g=[...y.values()];let L=!0;for(;L;){L=!1;for(let u=0;u<g.length;u++)for(let d=u+1;d<g.length;d++)if(g[u].some(b=>g[d].includes(b))){g[u]=Array.from(new Set([...g[u],...g[d]])).sort(),g.splice(d,1),L=!0;break}}const P=g.map(u=>"("+u.join(" ")+")").join("");t.set(P,g)}const f=new Map;l.forEach((c,y)=>f.set(c,y)),n.push(f);for(let c=0;c<l.length;c++)s[l[c]-1].add(c);for(let c=0;c<s.length;c++)s[c].size>1&&[...s[c]].sort();const m=this.buildRepresentationGraph(l),M=this.buildGraphString(m);(e===null||M.localeCompare(e)<0)&&(r=m,i=new Array(l.length),l.forEach((c,y)=>i[c-1]=y),e=M)}),[r,e,i,new A([...t.values()])]}aut(){const o=new Array(this.nodeCount).fill(1);this.partitionByPropertyKeys(o);const r=[],i=new Map,e=Array.from({length:this.nodeCount},t=>new Set),n=new Set;return this.individualizeDFS(o,[],n,(t,s)=>{for(const l of r){const h=new Map;for(let c=0;c<t.length;c++){const y=l.get(t[c]);if(y!==c){const g=[y<c?y:c,c<y?y:c];h.set(g.join("|"),g)}}const f=[...h.values()];let m=!0;for(;m;){m=!1;for(let c=0;c<f.length;c++)for(let y=c+1;y<f.length;y++)if(f[c].some(g=>f[y].includes(g))){f[c]=Array.from(new Set([...f[c],...f[y]])).sort(),f.splice(y,1),m=!0;break}}const M=f.map(c=>"("+c.join(" ")+")").join("");i.set(M,f)}const a=new Map;t.forEach((l,h)=>a.set(l,h)),r.push(a);for(let l=0;l<t.length;l++)e[t[l]-1].add(l);for(let l=0;l<e.length;l++)e[l].size>1&&[...e[l]].sort()}),new A([...i.values()])}partitionByPropertyKeys(o){const r=new Map;for(let e=0;e<this.nodeCount;e++){const n=this.nodeKeys.get(e);r.has(n)?r.get(n).push(e):r.set(n,[e])}let i=1;Array.from(r.keys()).sort((e,n)=>e.localeCompare(n)).forEach(e=>{const n=r.get(e);n.forEach(t=>o[t]=i),i+=n.length})}isCanon(o){return new Set(o).size===this.nodeCount}individualizeDFS(o,r,i,e){if(this.isCanon(o)){e(o,r);return}if(this.individualizationRefinement(o),this.isCanon(o)){e(o,r);return}const n=this.getCellToBreak(o);for(const t of n[1])o[t]=n[0]+1;for(const t of n[1])r.length===0&&i.has(t)||(o[t]=n[0],this.individualizeDFS([...o],[...r,t],i,e),o[t]=n[0]+1)}individualizationRefinement(o){let r=!1;for(;!r;){r=!0;const i=o.map((n,t)=>this.nodeNeighbors.get(t).map(a=>{if(this.hasEdgeLabels){const l=this.graph.edgeLabels;return this.isSymmetric?`${o[a]};${l[t][a]}`:`${o[a]};${l[t][a]};${l[a][t]}`}return o[a].toString()}).sort().join("|")),e=new Map;i.forEach((n,t)=>{const s=o[t];let a=e.get(s);a===void 0&&(a=new Map,e.set(s,a));let l=a.get(n);l===void 0&&(l=[],a.set(n,l)),l.push(t)});for(let n=1;n<=this.nodeCount;n++){const t=e.get(n);if(t===void 0||t.size<2)continue;r=!1;const s=Array.from(t.keys()).sort((l,h)=>h.localeCompare(l));let a=n;for(const l of s){const h=t.get(l);h.forEach(f=>o[f]=a),a+=h.length}break}}}getCellToBreak(o){const r=Array.from({length:o.length},()=>[]);o.forEach((i,e)=>r[i-1].push(e));for(let i=0;i<r.length;i++)if(r[i].length>1)return[i+1,r[i]];return[1,r[0]]}buildRepresentationGraph(o){const r=o.map(e=>e-1),i={adjacencyMatrix:Array.from({length:this.nodeCount},()=>new Array(this.nodeCount))};if(this.isSymmetric)for(let e=0;e<this.nodeCount;e++){const n=r[e],t=this.graph.adjacencyMatrix[e];for(let s=e;s<this.nodeCount;s++)i.adjacencyMatrix[n][r[s]]=t[s],i.adjacencyMatrix[r[s]][n]=t[s]}else for(let e=0;e<this.nodeCount;e++){const n=r[e],t=this.graph.adjacencyMatrix[e];for(let s=0;s<this.nodeCount;s++)i.adjacencyMatrix[n][r[s]]=t[s]}if(this.hasNodeLabels&&(i.labels=new Array(this.nodeCount),r.forEach((e,n)=>i.labels[e]=this.graph.labels[n])),this.hasNodeProperties&&(i.nodeProperties=new Array(this.nodeCount),r.forEach((e,n)=>i.nodeProperties[e]=this.nodePropertiesMapper(this.graph,n,r))),this.hasEdgeLabels)if(i.edgeLabels=Array.from({length:this.nodeCount},()=>new Array(this.nodeCount)),this.isSymmetric)for(let e=0;e<this.nodeCount;e++){const n=r[e],t=this.graph.edgeLabels[e];for(let s=e;s<this.nodeCount;s++)i.edgeLabels[n][r[s]]=t[s],i.edgeLabels[r[s]][n]=t[s]}else for(let e=0;e<this.nodeCount;e++){const n=r[e],t=this.graph.edgeLabels[e];for(let s=0;s<this.nodeCount;s++)i.edgeLabels[n][r[s]]=t[s]}return i}buildGraphStringCurry(){const o=this.hasEdgeLabels?(e,n,t)=>`${n}-${e.edgeLabels[n][t]}-${t}`:(e,n,t)=>`${n}-${t}`,r=this.hasNodeProperties?(e,n)=>{const t=this.nodePropertiesCanonKeyMapper(e,n);return t.length>0?`{${t}}`:""}:(e,n)=>"",i=this.hasNodeLabels?e=>";"+e.labels.map((n,t)=>n+r(e,t)).join("|"):this.hasNodeProperties?e=>";"+e.nodeProperties.map((n,t)=>this.nodePropertiesCanonKeyMapper(e,t)).join("|"):e=>"";return this.isSymmetric?e=>{const n=[];for(let t=0;t<this.nodeCount;t++){const s=e.adjacencyMatrix[t];for(let a=t;a<this.nodeCount;a++)s[a]===1&&n.push(o(e,t,a))}return n.join("|")+i(e)}:e=>{const n=[];for(let t=0;t<this.nodeCount;t++){const s=e.adjacencyMatrix[t];for(let a=0;a<this.nodeCount;a++)s[a]===1&&n.push(o(e,t,a))}return n.join("|")+i(e)}}buildGraphString(o){return this.graphStringBuilder(o)}};p(w,"DefaultNodeKeySuffixGenerator",(o,r)=>o.labels?o.labels[r]:""),p(w,"DefaultNodePropertiesMapper",(o,r,i)=>o.nodeProperties&&o.nodeProperties[r]?new Map(o.nodeProperties[r]):void 0),p(w,"DefaultNodePropertiesCanonKeyMapper",(o,r)=>"");let v=w;const K=Object.freeze(Object.defineProperty({__proto__:null,GraphCanon:v},Symbol.toStringTag,{value:"Module"}));class k{static find(o){const r=[],i=new Set,e=(n,t)=>{i.add(n),t.push(n);for(let s=0;s<o.adjacencyMatrix.length;s++)(o.adjacencyMatrix[n][s]===1||o.adjacencyMatrix[s][n]===1)&&(i.has(s)||e(s,t))};for(let n=0;n<o.adjacencyMatrix.length;n++)if(!i.has(n)){const t=[];e(n,t),r.push(t)}return r}}class A{constructor(o){p(this,"generators");this.generators=o}orbits(){const o=new Map;for(const e of this.generators)for(const n of e)for(let t=0;t<n.length;t++){let s=o.get(n[t]);s===void 0&&(s=new Set,o.set(n[t],s));for(let a=0;a<n.length;a++)t!==a&&s.add(n[a])}const r=[],i=new Set;for(const[e,n]of o.entries())if(!i.has(e)){i.add(e);for(const t of n)i.add(t);r.push([e,...n].sort())}return r}toString(){return"gen["+this.generators.map(o=>o.map(r=>"("+r.join(" ")+")").join("")).join(", ")+"], orb["+this.orbits().map(o=>"{"+o.join(" ")+"}").join(", ")+"]"}}const I=Object.freeze(Object.defineProperty({__proto__:null,AutomorphismGroup:A,ConnectedComponents:k,canon:K,matching:E},Symbol.toStringTag,{value:"Module"}));S.graph=I,Object.defineProperty(S,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=ac-graph-core-js.umd.cjs.map
