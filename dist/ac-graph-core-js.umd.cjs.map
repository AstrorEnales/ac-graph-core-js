{"version":3,"file":"ac-graph-core-js.umd.cjs","sources":["../src/graph/matching/GraphMatcher.ts","../src/graph/matching/UllmannGraphMatcher.ts","../src/graph/canon/GraphCanon.ts","../src/graph/ConnectedComponents.ts","../src/graph/index.ts"],"sourcesContent":["import {Mapping} from '.';\r\nimport {Graph} from '..';\r\n\r\nexport abstract class GraphMatcher {\r\n\t/**\r\n\t * Subgraph isomorphism check\r\n\t * @param pattern Pattern graph adjacency matrix\r\n\t * @param target Target graph adjacency matrix\r\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation.\r\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation. Encoded\r\n\t * as \"sourceIndex + ',' + targetIndex\".\r\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\r\n\t * find solutions containing this mapping. The array needs to follow the\r\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\r\n\t * are represented by -1.\r\n\t */\r\n\tpublic abstract isSubgraphIsomorphic(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tnodeLabelWildcards: number[],\r\n\t\tedgeLabelWildcards: string[],\r\n\t\tpartialMapping: number[] | null\r\n\t): boolean;\r\n\r\n\t/**\r\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\r\n\t * including symmetries\r\n\t * @param pattern Pattern graph adjacency matrix\r\n\t * @param target Target graph adjacency matrix\r\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation.\r\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation. Encoded\r\n\t * as \"sourceIndex + ',' + targetIndex\".\r\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\r\n\t * find solutions containing this mapping. The array needs to follow the\r\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\r\n\t * are represented by -1.\r\n\t */\r\n\tpublic abstract findAllSubgraphMonomorphisms(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tnodeLabelWildcards: number[],\r\n\t\tedgeLabelWildcards: string[],\r\n\t\tpartialMapping: number[] | null\r\n\t): Mapping[];\r\n}\r\n","import {Mapping} from '.';\r\nimport {Graph} from '..';\r\nimport {GraphMatcher} from './GraphMatcher';\r\n\r\nexport class UllmannGraphMatcher extends GraphMatcher {\r\n\t/**\r\n\t * Subgraph isomorphism check\r\n\t * @param pattern Pattern graph adjacency matrix\r\n\t * @param target Target graph adjacency matrix\r\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation.\r\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation. Encoded\r\n\t * as \"sourceIndex + ',' + targetIndex\".\r\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\r\n\t * find solutions containing this mapping. The array needs to follow the\r\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\r\n\t * are represented by -1.\r\n\t */\r\n\tpublic override isSubgraphIsomorphic(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tnodeLabelWildcards: number[] = [],\r\n\t\tedgeLabelWildcards: string[] = [],\r\n\t\tpartialMapping: number[] | null = null\r\n\t): boolean {\r\n\t\t// Number of nodes in the pattern graph\r\n\t\tconst n = pattern.adjacencyMatrix.length;\r\n\t\t// Number of nodes in the target graph\r\n\t\tconst m = target.adjacencyMatrix.length;\r\n\t\t// If pattern is larger than target, no mapping is possible\r\n\t\tif (n > m) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (partialMapping === null) {\r\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\r\n\t\t}\r\n\t\tconst isLabeled = pattern.labels && target.labels;\r\n\t\t// Track which target nodes are already used in the mapping\r\n\t\tconst used = Array(m).fill(false);\r\n\t\tconst mapping = Array(n).fill(-1);\r\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\r\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\r\n\t\t// Pre-compute degrees for pattern and target nodes\r\n\t\tconst [\r\n\t\t\tpatternInDegrees,\r\n\t\t\tpatternOutDegrees,\r\n\t\t\ttargetInDegrees,\r\n\t\t\ttargetOutDegrees,\r\n\t\t] = this.getInOutDegrees(pattern, target);\r\n\t\t// Pre-compute candidate domains for pattern nodes based on degree\r\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\r\n\t\t\ttargetInDegrees\r\n\t\t\t\t.map((td, j) => {\r\n\t\t\t\t\treturn td >= pd &&\r\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\r\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\r\n\t\t\t\t\t\t(!isLabeled ||\r\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\r\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\r\n\t\t\t\t\t\t? j\r\n\t\t\t\t\t\t: -1;\r\n\t\t\t\t})\r\n\t\t\t\t.filter((j) => j !== -1)\r\n\t\t);\r\n\t\t// Recursive backtracking function to try all injective mappings\r\n\t\tconst match = (depth: number): boolean => {\r\n\t\t\tif (depth === n) {\r\n\t\t\t\treturn this.checkCompatibility(\r\n\t\t\t\t\tpattern,\r\n\t\t\t\t\ttarget,\r\n\t\t\t\t\tmapping,\r\n\t\t\t\t\tedgeLabelWildcardsSet\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tfor (const candidate of domains[depth]) {\r\n\t\t\t\tif (!used[candidate]) {\r\n\t\t\t\t\tmapping[depth] = candidate;\r\n\t\t\t\t\tused[candidate] = true;\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tthis.isFeasible(\r\n\t\t\t\t\t\t\tpattern,\r\n\t\t\t\t\t\t\ttarget,\r\n\t\t\t\t\t\t\tmapping,\r\n\t\t\t\t\t\t\tdepth,\r\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\r\n\t\t\t\t\t\t) &&\r\n\t\t\t\t\t\tmatch(depth + 1)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Backtrack\r\n\t\t\t\t\tused[candidate] = false;\r\n\t\t\t\t\tmapping[depth] = -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\treturn match(0);\r\n\t}\r\n\r\n\tprivate getInOutDegrees(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph\r\n\t): [number[], number[], number[], number[]] {\r\n\t\tconst patternInDegrees = pattern.adjacencyMatrix.map((r) =>\r\n\t\t\tr.reduce((a, b) => a + b, 0)\r\n\t\t);\r\n\t\tconst patternOutDegrees: number[] = [];\r\n\t\tconst targetInDegrees = target.adjacencyMatrix.map((r) =>\r\n\t\t\tr.reduce((a, b) => a + b, 0)\r\n\t\t);\r\n\t\tconst targetOutDegrees: number[] = [];\r\n\t\tpattern.adjacencyMatrix.forEach((row, i) => {\r\n\t\t\tpatternOutDegrees.push(\r\n\t\t\t\trow\r\n\t\t\t\t\t.map((_, j) => pattern.adjacencyMatrix[j][i])\r\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\r\n\t\t\t);\r\n\t\t});\r\n\t\ttarget.adjacencyMatrix.forEach((row, i) => {\r\n\t\t\ttargetOutDegrees.push(\r\n\t\t\t\trow\r\n\t\t\t\t\t.map((_, j) => target.adjacencyMatrix[j][i])\r\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\r\n\t\t\t);\r\n\t\t});\r\n\t\treturn [\r\n\t\t\tpatternInDegrees,\r\n\t\t\tpatternOutDegrees,\r\n\t\t\ttargetInDegrees,\r\n\t\t\ttargetOutDegrees,\r\n\t\t];\r\n\t}\r\n\r\n\t/**\r\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\r\n\t * including symmetries\r\n\t * @param pattern Pattern graph adjacency matrix\r\n\t * @param target Target graph adjacency matrix\r\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation.\r\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation. Encoded\r\n\t * as \"sourceIndex + ',' + targetIndex\".\r\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\r\n\t * find solutions containing this mapping. The array needs to follow the\r\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\r\n\t * are represented by -1.\r\n\t */\r\n\tpublic override findAllSubgraphMonomorphisms(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tnodeLabelWildcards: number[] = [],\r\n\t\tedgeLabelWildcards: string[] = [],\r\n\t\tpartialMapping: number[] | null = null\r\n\t): Mapping[] {\r\n\t\tconst n = pattern.adjacencyMatrix.length;\r\n\t\tconst m = target.adjacencyMatrix.length;\r\n\t\tconst results: Mapping[] = [];\r\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\r\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\r\n\t\tif (n > m) {\r\n\t\t\treturn results;\r\n\t\t}\r\n\t\tif (partialMapping === null) {\r\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\r\n\t\t}\r\n\t\tconst isLabeled = pattern.labels && target.labels;\r\n\t\tconst used = Array(m).fill(false);\r\n\t\tconst mapping = Array(n).fill(-1);\r\n\t\tconst [\r\n\t\t\tpatternInDegrees,\r\n\t\t\tpatternOutDegrees,\r\n\t\t\ttargetInDegrees,\r\n\t\t\ttargetOutDegrees,\r\n\t\t] = this.getInOutDegrees(pattern, target);\r\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\r\n\t\t\ttargetInDegrees\r\n\t\t\t\t.map((td, j) => {\r\n\t\t\t\t\treturn td >= pd &&\r\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\r\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\r\n\t\t\t\t\t\t(!isLabeled ||\r\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\r\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\r\n\t\t\t\t\t\t? j\r\n\t\t\t\t\t\t: -1;\r\n\t\t\t\t})\r\n\t\t\t\t.filter((j) => j !== -1)\r\n\t\t);\r\n\t\tconst match = (depth: number): void => {\r\n\t\t\tif (depth === n) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tthis.checkCompatibility(\r\n\t\t\t\t\t\tpattern,\r\n\t\t\t\t\t\ttarget,\r\n\t\t\t\t\t\tmapping,\r\n\t\t\t\t\t\tedgeLabelWildcardsSet\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\t\t\t\t\tresults.push([...mapping]);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tfor (const candidate of domains[depth]) {\r\n\t\t\t\tif (!used[candidate]) {\r\n\t\t\t\t\tmapping[depth] = candidate;\r\n\t\t\t\t\tused[candidate] = true;\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tthis.isFeasible(\r\n\t\t\t\t\t\t\tpattern,\r\n\t\t\t\t\t\t\ttarget,\r\n\t\t\t\t\t\t\tmapping,\r\n\t\t\t\t\t\t\tdepth,\r\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tmatch(depth + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tused[candidate] = false;\r\n\t\t\t\t\tmapping[depth] = -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tmatch(0);\r\n\t\treturn results;\r\n\t}\r\n\r\n\t/**\r\n\t * Feasibility check for current depth: preserve pattern edges\r\n\t * and edge labels if present\r\n\t */\r\n\tprivate isFeasible(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tmapping: Mapping,\r\n\t\tdepth: number,\r\n\t\tedgeLabelWildcardsSet: Set<string>\r\n\t): boolean {\r\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\r\n\t\t// Check that all edges in the current partial mapping are preserved\r\n\t\tfor (let i = 0; i < depth; i++) {\r\n\t\t\tif (pattern.adjacencyMatrix[depth][i]) {\r\n\t\t\t\tif (!target.adjacencyMatrix[mapping[depth]][mapping[i]]) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t// Check edge labels if present\r\n\t\t\t\tif (\r\n\t\t\t\t\tisEdgeLabeled &&\r\n\t\t\t\t\t!edgeLabelWildcardsSet.has(depth + ',' + i) &&\r\n\t\t\t\t\tpattern.edgeLabels![depth][i] !==\r\n\t\t\t\t\t\ttarget.edgeLabels![mapping[depth]][mapping[i]]\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (pattern.adjacencyMatrix[i][depth]) {\r\n\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[depth]]) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t// Check edge labels if present\r\n\t\t\t\tif (\r\n\t\t\t\t\tisEdgeLabeled &&\r\n\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + depth) &&\r\n\t\t\t\t\tpattern.edgeLabels![i][depth] !==\r\n\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[depth]]\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Verifies full structural consistency of the mapping\r\n\t */\r\n\tprivate checkCompatibility(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tmapping: Mapping,\r\n\t\tedgeLabelWildcardsSet: Set<string>\r\n\t): boolean {\r\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\r\n\t\tconst n = pattern.adjacencyMatrix.length;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tfor (let j = 0; j < n; j++) {\r\n\t\t\t\tif (pattern.adjacencyMatrix[i][j]) {\r\n\t\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[j]]) {\r\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tisEdgeLabeled &&\r\n\t\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + j) &&\r\n\t\t\t\t\t\tpattern.edgeLabels![i][j] !==\r\n\t\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[j]]\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge label\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n}\r\n","import {Automorphism, AutomorphismGroup, Graph} from '..';\r\nimport {Mapping} from '../matching';\r\n\r\nexport type NodeKeySuffixGenerator = (\r\n\tgraph: Graph,\r\n\tnodeIndex: number\r\n) => string;\r\nexport type NodePropertiesMapper = (\r\n\tgraph: Graph,\r\n\tnodeIndex: number,\r\n\tnodeMapping: number[]\r\n) => Map<string, any> | undefined;\r\nexport type NodePropertiesCanonKeyMapper = (\r\n\tgraph: Graph,\r\n\tnodeIndex: number\r\n) => string;\r\n\r\n/**\r\n * Nauty graph canonicalization using the following graph properties\r\n * for ordering and selection:\r\n * - First, node cell membership is sorted ascending by \"outDegree|inDegree|label?\"\r\n * - Second, direct neighborhood cell memberships and optional edge labels are sorted\r\n *   ascending, concatenated, and used to further split cells.\r\n *   \"neighborCell_1;outEdgeLabel_1?;inEdgeLabel_1?|neighborCell_2;outEdgeLabel_2?;inEdgeLabel_2?|...\"\r\n *   New cell IDs of the split are assigned by descending key order.\r\n * - Target cell selection in the search tree is performed by selecting the leftmost (smallest) cell ID\r\n *   with at least two members.\r\n */\r\nexport class GraphCanon {\r\n\tpublic static readonly DefaultNodeKeySuffixGenerator: NodeKeySuffixGenerator =\r\n\t\t(graph: Graph, nodeIndex: number) => {\r\n\t\t\treturn graph.labels ? graph.labels[nodeIndex] : '';\r\n\t\t};\r\n\tpublic static readonly DefaultNodePropertiesMapper: NodePropertiesMapper = (\r\n\t\tgraph: Graph,\r\n\t\tnodeIndex: number,\r\n\t\t_nodeMapping: number[]\r\n\t) => {\r\n\t\treturn graph.nodeProperties && graph.nodeProperties[nodeIndex]\r\n\t\t\t? new Map(graph.nodeProperties[nodeIndex])\r\n\t\t\t: undefined;\r\n\t};\r\n\tpublic static readonly DefaultNodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper =\r\n\t\t(_graph: Graph, _nodeIndex: number) => {\r\n\t\t\treturn '';\r\n\t\t};\r\n\r\n\tprivate readonly nodeCount: number;\r\n\tprivate readonly hasNodeLabels: boolean;\r\n\tprivate readonly hasNodeProperties: boolean;\r\n\tprivate readonly hasEdgeLabels: boolean;\r\n\tprivate readonly isSymmetric: boolean;\r\n\tprivate readonly graph: Graph;\r\n\tprivate readonly nodeNeighbors = new Map<number, number[]>();\r\n\tprivate readonly nodeKeys = new Map<number, string>();\r\n\tprivate readonly nodePropertiesMapper: NodePropertiesMapper;\r\n\tprivate readonly nodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper;\r\n\tprivate readonly graphStringBuilder: (graph: Graph) => string;\r\n\r\n\tpublic constructor(\r\n\t\tgraph: Graph,\r\n\t\tnodeKeySuffixGenerator: NodeKeySuffixGenerator = GraphCanon.DefaultNodeKeySuffixGenerator,\r\n\t\tnodePropertiesMapper: NodePropertiesMapper = GraphCanon.DefaultNodePropertiesMapper,\r\n\t\tnodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper = GraphCanon.DefaultNodePropertiesCanonKeyMapper\r\n\t) {\r\n\t\tthis.graph = graph;\r\n\t\tthis.nodeCount = graph.adjacencyMatrix.length;\r\n\t\tthis.hasNodeLabels = graph.labels !== undefined;\r\n\t\tthis.hasNodeProperties = graph.nodeProperties !== undefined;\r\n\t\tthis.hasEdgeLabels = graph.edgeLabels !== undefined;\r\n\t\tthis.nodePropertiesMapper = nodePropertiesMapper;\r\n\t\tthis.nodePropertiesCanonKeyMapper = nodePropertiesCanonKeyMapper;\r\n\t\tlet isSymmetric = true;\r\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\tconst neighbors = new Set<number>();\r\n\t\t\tlet inDegree = 0;\r\n\t\t\tlet outDegree = 0;\r\n\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\tconst isOut = graph.adjacencyMatrix[i][j];\r\n\t\t\t\tconst isIn = graph.adjacencyMatrix[j][i];\r\n\t\t\t\tif (isOut === 1) {\r\n\t\t\t\t\toutDegree++;\r\n\t\t\t\t\tneighbors.add(j);\r\n\t\t\t\t}\r\n\t\t\t\tif (isIn === 1) {\r\n\t\t\t\t\tinDegree++;\r\n\t\t\t\t\tneighbors.add(j);\r\n\t\t\t\t}\r\n\t\t\t\tif (isOut !== isIn) {\r\n\t\t\t\t\tisSymmetric = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.nodeNeighbors.set(i, [...neighbors]);\r\n\t\t\tconst nodeKey =\r\n\t\t\t\toutDegree + '|' + inDegree + '|' + nodeKeySuffixGenerator(graph, i);\r\n\t\t\tthis.nodeKeys.set(i, nodeKey);\r\n\t\t}\r\n\t\tthis.isSymmetric = isSymmetric;\r\n\t\t// Finally build the curried graph key function\r\n\t\tthis.graphStringBuilder = this.buildGraphStringCurry();\r\n\t}\r\n\r\n\t/**\r\n\t * Canonicalize the graph\r\n\t * @returns\r\n\t * 1. canonical graph representation\r\n\t * 2. graph key\r\n\t * 3. node mapping from the original to the canonical graph\r\n\t * 4. automorphisms\r\n\t */\r\n\tpublic canonicalize(): [Graph, string, Mapping, AutomorphismGroup] {\r\n\t\tconst nodeCells = new Array(this.nodeCount).fill(1);\r\n\t\tthis.partitionByPropertyKeys(nodeCells);\r\n\t\tlet lexSmallestGraph: Graph | null = null;\r\n\t\tlet lexSmallestMapping: Mapping | null = null;\r\n\t\tlet lexSmallestGraphString: string | null = null;\r\n\r\n\t\tconst partitions: Map<number, number>[] = [];\r\n\t\tconst automorphisms = new Map<string, Automorphism>();\r\n\t\tconst automorphismGroups = Array.from(\r\n\t\t\t{length: this.nodeCount},\r\n\t\t\t(_) => new Set<number>()\r\n\t\t);\r\n\t\tconst prunedSubtrees = new Set<number>();\r\n\r\n\t\tthis.individualizeDFS(nodeCells, [], prunedSubtrees, (repNodeCells, _) => {\r\n\t\t\tfor (const partition of partitions) {\r\n\t\t\t\tconst automorphismMap = new Map<string, number[]>();\r\n\t\t\t\tfor (let i = 0; i < repNodeCells.length; i++) {\r\n\t\t\t\t\tconst partitionIndex = partition.get(repNodeCells[i])!;\r\n\t\t\t\t\tif (partitionIndex !== i) {\r\n\t\t\t\t\t\tconst match = [\r\n\t\t\t\t\t\t\tpartitionIndex < i ? partitionIndex : i,\r\n\t\t\t\t\t\t\ti < partitionIndex ? partitionIndex : i,\r\n\t\t\t\t\t\t];\r\n\t\t\t\t\t\tautomorphismMap.set(match.join('|'), match);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tconst automorphism = [...automorphismMap.values()];\r\n\t\t\t\tlet changed = true;\r\n\t\t\t\twhile (changed) {\r\n\t\t\t\t\tchanged = false;\r\n\t\t\t\t\tfor (let i = 0; i < automorphism.length; i++) {\r\n\t\t\t\t\t\tfor (let j = i + 1; j < automorphism.length; j++) {\r\n\t\t\t\t\t\t\tif (automorphism[i].some((x) => automorphism[j].includes(x))) {\r\n\t\t\t\t\t\t\t\tautomorphism[i] = Array.from(\r\n\t\t\t\t\t\t\t\t\tnew Set([...automorphism[i], ...automorphism[j]])\r\n\t\t\t\t\t\t\t\t).sort();\r\n\t\t\t\t\t\t\t\tautomorphism.splice(j, 1);\r\n\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tconst automorphismKey = automorphism\r\n\t\t\t\t\t.map((x) => '(' + x.join(' ') + ')')\r\n\t\t\t\t\t.join('');\r\n\t\t\t\tautomorphisms.set(automorphismKey, automorphism);\r\n\t\t\t}\r\n\r\n\t\t\tconst partition = new Map<number, number>();\r\n\t\t\trepNodeCells.forEach((c, i) => partition.set(c, i));\r\n\t\t\tpartitions.push(partition);\r\n\r\n\t\t\tfor (let i = 0; i < repNodeCells.length; i++) {\r\n\t\t\t\tautomorphismGroups[repNodeCells[i] - 1].add(i);\r\n\t\t\t}\r\n\t\t\tfor (let i = 0; i < automorphismGroups.length; i++) {\r\n\t\t\t\t// Update pruned subtrees\r\n\t\t\t\tif (automorphismGroups[i].size > 1) {\r\n\t\t\t\t\tconst group = [...automorphismGroups[i]].sort();\r\n\t\t\t\t\tfor (let j = 1; j < group.length; j++) {\r\n\t\t\t\t\t\t//prunedSubtrees.add(group[j]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tconst repGraph = this.buildRepresentationGraph(repNodeCells);\r\n\t\t\tconst repGraphString = this.buildGraphString(repGraph);\r\n\t\t\tif (\r\n\t\t\t\tlexSmallestGraphString === null ||\r\n\t\t\t\trepGraphString.localeCompare(lexSmallestGraphString) < 0\r\n\t\t\t) {\r\n\t\t\t\tlexSmallestGraph = repGraph;\r\n\t\t\t\tlexSmallestMapping = new Array(repNodeCells.length);\r\n\t\t\t\trepNodeCells.forEach((cell, i) => (lexSmallestMapping![cell - 1] = i));\r\n\t\t\t\tlexSmallestGraphString = repGraphString;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn [\r\n\t\t\tlexSmallestGraph!,\r\n\t\t\tlexSmallestGraphString!,\r\n\t\t\tlexSmallestMapping!,\r\n\t\t\tnew AutomorphismGroup([...automorphisms.values()]),\r\n\t\t];\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates only the automorphisms of the graph.\r\n\t *\r\n\t * Note: if any of the graph, graph key, or node mapping are needed as well,\r\n\t * use the canonicalize() function.\r\n\t */\r\n\tpublic aut(): AutomorphismGroup {\r\n\t\tconst nodeCells = new Array(this.nodeCount).fill(1);\r\n\t\tthis.partitionByPropertyKeys(nodeCells);\r\n\r\n\t\tconst partitions: Map<number, number>[] = [];\r\n\t\tconst automorphisms = new Map<string, Automorphism>();\r\n\t\tconst automorphismGroups = Array.from(\r\n\t\t\t{length: this.nodeCount},\r\n\t\t\t(_) => new Set<number>()\r\n\t\t);\r\n\t\tconst prunedSubtrees = new Set<number>();\r\n\r\n\t\tthis.individualizeDFS(nodeCells, [], prunedSubtrees, (repNodeCells, _) => {\r\n\t\t\tfor (const partition of partitions) {\r\n\t\t\t\tconst automorphismMap = new Map<string, number[]>();\r\n\t\t\t\tfor (let i = 0; i < repNodeCells.length; i++) {\r\n\t\t\t\t\tconst partitionIndex = partition.get(repNodeCells[i])!;\r\n\t\t\t\t\tif (partitionIndex !== i) {\r\n\t\t\t\t\t\tconst match = [\r\n\t\t\t\t\t\t\tpartitionIndex < i ? partitionIndex : i,\r\n\t\t\t\t\t\t\ti < partitionIndex ? partitionIndex : i,\r\n\t\t\t\t\t\t];\r\n\t\t\t\t\t\tautomorphismMap.set(match.join('|'), match);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tconst automorphism = [...automorphismMap.values()];\r\n\t\t\t\tlet changed = true;\r\n\t\t\t\twhile (changed) {\r\n\t\t\t\t\tchanged = false;\r\n\t\t\t\t\tfor (let i = 0; i < automorphism.length; i++) {\r\n\t\t\t\t\t\tfor (let j = i + 1; j < automorphism.length; j++) {\r\n\t\t\t\t\t\t\tif (automorphism[i].some((x) => automorphism[j].includes(x))) {\r\n\t\t\t\t\t\t\t\tautomorphism[i] = Array.from(\r\n\t\t\t\t\t\t\t\t\tnew Set([...automorphism[i], ...automorphism[j]])\r\n\t\t\t\t\t\t\t\t).sort();\r\n\t\t\t\t\t\t\t\tautomorphism.splice(j, 1);\r\n\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tconst automorphismKey = automorphism\r\n\t\t\t\t\t.map((x) => '(' + x.join(' ') + ')')\r\n\t\t\t\t\t.join('');\r\n\t\t\t\tautomorphisms.set(automorphismKey, automorphism);\r\n\t\t\t}\r\n\r\n\t\t\tconst partition = new Map<number, number>();\r\n\t\t\trepNodeCells.forEach((c, i) => partition.set(c, i));\r\n\t\t\tpartitions.push(partition);\r\n\r\n\t\t\tfor (let i = 0; i < repNodeCells.length; i++) {\r\n\t\t\t\tautomorphismGroups[repNodeCells[i] - 1].add(i);\r\n\t\t\t}\r\n\t\t\tfor (let i = 0; i < automorphismGroups.length; i++) {\r\n\t\t\t\t// Update pruned subtrees\r\n\t\t\t\tif (automorphismGroups[i].size > 1) {\r\n\t\t\t\t\tconst group = [...automorphismGroups[i]].sort();\r\n\t\t\t\t\tfor (let j = 1; j < group.length; j++) {\r\n\t\t\t\t\t\t//prunedSubtrees.add(group[j]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn new AutomorphismGroup([...automorphisms.values()]);\r\n\t}\r\n\r\n\tprivate partitionByPropertyKeys(nodeCells: number[]) {\r\n\t\tconst propertyKeyNodeIndices = new Map<string, number[]>();\r\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\tconst key = this.nodeKeys.get(i)!;\r\n\t\t\tif (propertyKeyNodeIndices.has(key)) {\r\n\t\t\t\tpropertyKeyNodeIndices.get(key)!.push(i);\r\n\t\t\t} else {\r\n\t\t\t\tpropertyKeyNodeIndices.set(key, [i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet nextFreeCell = 1;\r\n\t\tArray.from(propertyKeyNodeIndices.keys())\r\n\t\t\t.sort((a, b) => a.localeCompare(b))\r\n\t\t\t.forEach((k) => {\r\n\t\t\t\tconst nodesInNextCell = propertyKeyNodeIndices.get(k)!;\r\n\t\t\t\tnodesInNextCell.forEach((i) => (nodeCells[i] = nextFreeCell));\r\n\t\t\t\tnextFreeCell += nodesInNextCell.length;\r\n\t\t\t});\r\n\t}\r\n\r\n\tprivate isCanon(nodeCells: number[]): boolean {\r\n\t\treturn new Set<number>(nodeCells).size === this.nodeCount;\r\n\t}\r\n\r\n\tprivate individualizeDFS(\r\n\t\tnodeCells: number[],\r\n\t\tsuffix: number[],\r\n\t\tprunedSubtrees: Set<number>,\r\n\t\thandleRepresentation: (nodeCells: number[], suffix: number[]) => void\r\n\t) {\r\n\t\tif (this.isCanon(nodeCells)) {\r\n\t\t\thandleRepresentation(nodeCells, suffix);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.individualizationRefinement(nodeCells);\r\n\t\tif (this.isCanon(nodeCells)) {\r\n\t\t\thandleRepresentation(nodeCells, suffix);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst cellToBreak = this.getCellToBreak(nodeCells);\r\n\t\tfor (const n of cellToBreak[1]) {\r\n\t\t\tnodeCells[n] = cellToBreak[0] + 1;\r\n\t\t}\r\n\t\tfor (const nodeId of cellToBreak[1]) {\r\n\t\t\t// Check if subtree is pruned\r\n\t\t\tif (suffix.length === 0 && prunedSubtrees.has(nodeId)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tnodeCells[nodeId] = cellToBreak[0];\r\n\t\t\tthis.individualizeDFS(\r\n\t\t\t\t[...nodeCells],\r\n\t\t\t\t[...suffix, nodeId],\r\n\t\t\t\tprunedSubtrees,\r\n\t\t\t\thandleRepresentation\r\n\t\t\t);\r\n\t\t\tnodeCells[nodeId] = cellToBreak[0] + 1;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate individualizationRefinement(nodeCells: number[]) {\r\n\t\tlet isEquitable = false;\r\n\t\twhile (!isEquitable) {\r\n\t\t\tisEquitable = true;\r\n\t\t\t// Build signature for each node\r\n\t\t\tconst signatures: string[] = nodeCells.map((_, i) => {\r\n\t\t\t\tconst neighborCells = this.nodeNeighbors.get(i)!.map((n) => {\r\n\t\t\t\t\tif (this.hasEdgeLabels) {\r\n\t\t\t\t\t\tconst edgeLabels = this.graph.edgeLabels!;\r\n\t\t\t\t\t\tif (this.isSymmetric) {\r\n\t\t\t\t\t\t\treturn `${nodeCells[n]};${edgeLabels[i][n]}`;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn `${nodeCells[n]};${edgeLabels[i][n]};${edgeLabels[n][i]}`;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn nodeCells[n].toString();\r\n\t\t\t\t});\r\n\t\t\t\treturn neighborCells.sort().join('|');\r\n\t\t\t});\r\n\t\t\t// Group by current cell and signature\r\n\t\t\tconst partitionMap = new Map<number, Map<string, number[]>>();\r\n\t\t\tsignatures.forEach((signature, nodeIndex) => {\r\n\t\t\t\tconst cell = nodeCells[nodeIndex];\r\n\t\t\t\tlet cellMap = partitionMap.get(cell);\r\n\t\t\t\tif (cellMap === undefined) {\r\n\t\t\t\t\tcellMap = new Map();\r\n\t\t\t\t\tpartitionMap.set(cell, cellMap);\r\n\t\t\t\t}\r\n\t\t\t\tlet nodeIndices = cellMap.get(signature);\r\n\t\t\t\tif (nodeIndices === undefined) {\r\n\t\t\t\t\tnodeIndices = [];\r\n\t\t\t\t\tcellMap.set(signature, nodeIndices);\r\n\t\t\t\t}\r\n\t\t\t\tnodeIndices.push(nodeIndex);\r\n\t\t\t});\r\n\t\t\t// Partition cells based on signature blocks\r\n\t\t\tfor (let cellId = 1; cellId <= this.nodeCount; cellId++) {\r\n\t\t\t\tconst value = partitionMap.get(cellId);\r\n\t\t\t\tif (value === undefined || value.size < 2) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tisEquitable = false;\r\n\t\t\t\t// Sort block signatures descending\r\n\t\t\t\tconst blockKeys = Array.from(value.keys()).sort((sigA, sigB) =>\r\n\t\t\t\t\tsigB.localeCompare(sigA)\r\n\t\t\t\t);\r\n\t\t\t\tlet newCellId = cellId;\r\n\t\t\t\tfor (const key of blockKeys) {\r\n\t\t\t\t\tconst nodes = value.get(key)!;\r\n\t\t\t\t\tnodes.forEach((n) => (nodeCells[n] = newCellId));\r\n\t\t\t\t\tnewCellId += nodes.length;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate getCellToBreak(nodeCells: number[]): [number, number[]] {\r\n\t\tconst cells: number[][] = Array.from({length: nodeCells.length}, () => []);\r\n\t\tnodeCells.forEach((c, i) => cells[c - 1].push(i));\r\n\t\tfor (let i = 0; i < cells.length; i++) {\r\n\t\t\tif (cells[i].length > 1) {\r\n\t\t\t\treturn [i + 1, cells[i]];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn [1, cells[0]];\r\n\t}\r\n\r\n\tprivate buildRepresentationGraph(nodeCells: number[]): Graph {\r\n\t\tconst nodeMapping = nodeCells.map((c) => c - 1);\r\n\t\tconst graph: Graph = {\r\n\t\t\tadjacencyMatrix: Array.from(\r\n\t\t\t\t{length: this.nodeCount},\r\n\t\t\t\t() => new Array(this.nodeCount)\r\n\t\t\t),\r\n\t\t};\r\n\t\tif (this.isSymmetric) {\r\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\tconst mi = nodeMapping[i];\r\n\t\t\t\tconst row = this.graph.adjacencyMatrix[i];\r\n\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\r\n\t\t\t\t\tgraph.adjacencyMatrix[mi][nodeMapping[j]] = row[j];\r\n\t\t\t\t\tgraph.adjacencyMatrix[nodeMapping[j]][mi] = row[j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\tconst mi = nodeMapping[i];\r\n\t\t\t\tconst row = this.graph.adjacencyMatrix[i];\r\n\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\t\tgraph.adjacencyMatrix[mi][nodeMapping[j]] = row[j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this.hasNodeLabels) {\r\n\t\t\tgraph.labels = new Array(this.nodeCount);\r\n\t\t\tnodeMapping.forEach((c, i) => (graph.labels![c] = this.graph.labels![i]));\r\n\t\t}\r\n\t\tif (this.hasNodeProperties) {\r\n\t\t\tgraph.nodeProperties = new Array(this.nodeCount);\r\n\t\t\tnodeMapping.forEach(\r\n\t\t\t\t(c, i) =>\r\n\t\t\t\t\t(graph.nodeProperties![c] = this.nodePropertiesMapper(\r\n\t\t\t\t\t\tthis.graph,\r\n\t\t\t\t\t\ti,\r\n\t\t\t\t\t\tnodeMapping\r\n\t\t\t\t\t))\r\n\t\t\t);\r\n\t\t}\r\n\t\tif (this.hasEdgeLabels) {\r\n\t\t\tgraph.edgeLabels = Array.from(\r\n\t\t\t\t{length: this.nodeCount},\r\n\t\t\t\t() => new Array(this.nodeCount)\r\n\t\t\t);\r\n\t\t\tif (this.isSymmetric) {\r\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\t\tconst mi = nodeMapping[i];\r\n\t\t\t\t\tconst row = this.graph.edgeLabels![i];\r\n\t\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\r\n\t\t\t\t\t\tgraph.edgeLabels[mi][nodeMapping[j]] = row[j];\r\n\t\t\t\t\t\tgraph.edgeLabels[nodeMapping[j]][mi] = row[j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\t\tconst mi = nodeMapping[i];\r\n\t\t\t\t\tconst row = this.graph.edgeLabels![i];\r\n\t\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\t\t\tgraph.edgeLabels[mi][nodeMapping[j]] = row[j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn graph;\r\n\t}\r\n\r\n\tprivate buildGraphStringCurry() {\r\n\t\tconst edgeCallback = this.hasEdgeLabels\r\n\t\t\t? (graph: Graph, i: number, j: number) =>\r\n\t\t\t\t\t`${i}-${graph.edgeLabels![i][j]}-${j}`\r\n\t\t\t: (_: Graph, i: number, j: number) => `${i}-${j}`;\r\n\t\tconst nodePropertyCallback = this.hasNodeProperties\r\n\t\t\t? (graph: Graph, i: number): string => {\r\n\t\t\t\t\tconst nodePropertyCanonKey = this.nodePropertiesCanonKeyMapper(\r\n\t\t\t\t\t\tgraph,\r\n\t\t\t\t\t\ti\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn nodePropertyCanonKey.length > 0\r\n\t\t\t\t\t\t? `{${nodePropertyCanonKey}}`\r\n\t\t\t\t\t\t: '';\r\n\t\t\t\t}\r\n\t\t\t: (_graph: Graph, _i: number): string => '';\r\n\t\tconst nodeCallback = this.hasNodeLabels\r\n\t\t\t? (graph: Graph): string =>\r\n\t\t\t\t\t';' +\r\n\t\t\t\t\tgraph\r\n\t\t\t\t\t\t.labels!.map((l, i) => l + nodePropertyCallback(graph, i))\r\n\t\t\t\t\t\t.join('|')\r\n\t\t\t: this.hasNodeProperties\r\n\t\t\t\t? (graph: Graph): string =>\r\n\t\t\t\t\t\t';' +\r\n\t\t\t\t\t\tgraph\r\n\t\t\t\t\t\t\t.nodeProperties!.map((_, i) =>\r\n\t\t\t\t\t\t\t\tthis.nodePropertiesCanonKeyMapper(graph, i)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t.join('|')\r\n\t\t\t\t: (_: Graph): string => '';\r\n\r\n\t\tif (this.isSymmetric) {\r\n\t\t\treturn (graph: Graph): string => {\r\n\t\t\t\tconst edges = [];\r\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\t\tconst row = graph.adjacencyMatrix[i];\r\n\t\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\r\n\t\t\t\t\t\tif (row[j] === 1) {\r\n\t\t\t\t\t\t\tedges.push(edgeCallback(graph, i, j));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn edges.join('|') + nodeCallback(graph);\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn (graph: Graph): string => {\r\n\t\t\tconst edges = [];\r\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\tconst row = graph.adjacencyMatrix[i];\r\n\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\t\tif (row[j] === 1) {\r\n\t\t\t\t\t\tedges.push(edgeCallback(graph, i, j));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn edges.join('|') + nodeCallback(graph);\r\n\t\t};\r\n\t}\r\n\r\n\tpublic buildGraphString(graph: Graph): string {\r\n\t\treturn this.graphStringBuilder(graph);\r\n\t}\r\n}\r\n","import {Graph} from '.';\r\n\r\nexport class ConnectedComponents {\r\n\tpublic static find(graph: Graph): number[][] {\r\n\t\tconst result: number[][] = [];\r\n\t\tconst visited = new Set<number>();\r\n\r\n\t\tconst dfs = (node: number, component: number[]) => {\r\n\t\t\tvisited.add(node);\r\n\t\t\tcomponent.push(node);\r\n\t\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tgraph.adjacencyMatrix[node][i] === 1 ||\r\n\t\t\t\t\tgraph.adjacencyMatrix[i][node] === 1\r\n\t\t\t\t) {\r\n\t\t\t\t\tif (!visited.has(i)) {\r\n\t\t\t\t\t\tdfs(i, component);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\tif (!visited.has(i)) {\r\n\t\t\t\tconst component: number[] = [];\r\n\t\t\t\tdfs(i, component);\r\n\t\t\t\tresult.push(component);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n","export * as matching from './matching';\r\nexport * as canon from './canon';\r\nexport * from './ConnectedComponents';\r\n\r\nexport interface Graph {\r\n\t/**\r\n\t * N x N adjacency matrix of the graph. Must be symmetric if directed is true.\r\n\t */\r\n\tadjacencyMatrix: number[][];\r\n\t/**\r\n\t * Optional node labels\r\n\t */\r\n\tlabels?: string[];\r\n\t/**\r\n\t * Optional node properties\r\n\t */\r\n\tnodeProperties?: (Map<string, any> | undefined)[];\r\n\t/**\r\n\t * Optional edge labels\r\n\t */\r\n\tedgeLabels?: string[][];\r\n}\r\n\r\nexport type Automorphism = number[][];\r\n\r\nexport class AutomorphismGroup {\r\n\tpublic readonly generators: Automorphism[];\r\n\r\n\tconstructor(generators: Automorphism[]) {\r\n\t\tthis.generators = generators;\r\n\t}\r\n\r\n\tpublic orbits(): number[][] {\r\n\t\tconst mappings = new Map<number, Set<number>>();\r\n\t\tfor (const generator of this.generators) {\r\n\t\t\tfor (const nodes of generator) {\r\n\t\t\t\tfor (let i = 0; i < nodes.length; i++) {\r\n\t\t\t\t\tlet s = mappings.get(nodes[i]);\r\n\t\t\t\t\tif (s === undefined) {\r\n\t\t\t\t\t\ts = new Set<number>();\r\n\t\t\t\t\t\tmappings.set(nodes[i], s);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (let j = 0; j < nodes.length; j++) {\r\n\t\t\t\t\t\tif (i !== j) {\r\n\t\t\t\t\t\t\ts.add(nodes[j]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst orbits = [];\r\n\t\tconst visited = new Set<number>();\r\n\t\tfor (const [key, nodes] of mappings.entries()) {\r\n\t\t\tif (!visited.has(key)) {\r\n\t\t\t\tvisited.add(key);\r\n\t\t\t\tfor (const node of nodes) {\r\n\t\t\t\t\tvisited.add(node);\r\n\t\t\t\t}\r\n\t\t\t\torbits.push([key, ...nodes].sort());\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn orbits;\r\n\t}\r\n\r\n\tpublic toString(): string {\r\n\t\treturn (\r\n\t\t\t'gen[' +\r\n\t\t\tthis.generators\r\n\t\t\t\t.map((g) => g.map((x) => '(' + x.join(' ') + ')').join(''))\r\n\t\t\t\t.join(', ') +\r\n\t\t\t'], orb[' +\r\n\t\t\tthis.orbits()\r\n\t\t\t\t.map((x) => '{' + x.join(' ') + '}')\r\n\t\t\t\t.join(', ') +\r\n\t\t\t']'\r\n\t\t);\r\n\t}\r\n}\r\n"],"names":["GraphMatcher","UllmannGraphMatcher","pattern","target","nodeLabelWildcards","edgeLabelWildcards","partialMapping","n","m","isLabeled","used","mapping","nodeLabelWildcardsSet","edgeLabelWildcardsSet","patternInDegrees","patternOutDegrees","targetInDegrees","targetOutDegrees","domains","pd","i","td","j","match","depth","candidate","r","b","row","_","a","results","isEdgeLabeled","_GraphCanon","graph","nodeKeySuffixGenerator","nodePropertiesMapper","nodePropertiesCanonKeyMapper","__publicField","isSymmetric","neighbors","inDegree","outDegree","isOut","isIn","nodeKey","nodeCells","lexSmallestGraph","lexSmallestMapping","lexSmallestGraphString","partitions","automorphisms","automorphismGroups","prunedSubtrees","repNodeCells","partition","automorphismMap","partitionIndex","automorphism","changed","x","automorphismKey","repGraph","repGraphString","cell","AutomorphismGroup","c","propertyKeyNodeIndices","key","nextFreeCell","k","nodesInNextCell","suffix","handleRepresentation","cellToBreak","nodeId","isEquitable","signatures","edgeLabels","partitionMap","signature","nodeIndex","cellMap","nodeIndices","cellId","value","blockKeys","sigA","sigB","newCellId","nodes","cells","nodeMapping","mi","edgeCallback","nodePropertyCallback","nodePropertyCanonKey","_graph","_i","nodeCallback","l","edges","_nodeMapping","_nodeIndex","GraphCanon","ConnectedComponents","result","visited","dfs","node","component","generators","mappings","generator","orbits","g"],"mappings":"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"}