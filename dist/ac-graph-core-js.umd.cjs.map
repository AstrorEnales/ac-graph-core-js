{"version":3,"file":"ac-graph-core-js.umd.cjs","sources":["../src/graph/matching/GraphMatcher.ts","../src/graph/matching/UllmannGraphMatcher.ts","../src/graph/canon/GraphCanon.ts","../src/graph/ConnectedComponents.ts"],"sourcesContent":["import {Mapping} from '.';\nimport {Graph} from '..';\n\nexport abstract class GraphMatcher {\n\t/**\n\t * Subgraph isomorphism check\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic abstract isSubgraphIsomorphic(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[],\n\t\tedgeLabelWildcards: string[],\n\t\tpartialMapping: number[] | null\n\t): boolean;\n\n\t/**\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\n\t * including symmetries\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic abstract findAllSubgraphMonomorphisms(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[],\n\t\tedgeLabelWildcards: string[],\n\t\tpartialMapping: number[] | null\n\t): Mapping[];\n}\n","import {Mapping} from '.';\nimport {Graph} from '..';\nimport {GraphMatcher} from './GraphMatcher';\n\nexport class UllmannGraphMatcher extends GraphMatcher {\n\t/**\n\t * Subgraph isomorphism check\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic override isSubgraphIsomorphic(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[] = [],\n\t\tedgeLabelWildcards: string[] = [],\n\t\tpartialMapping: number[] | null = null\n\t): boolean {\n\t\t// Number of nodes in the pattern graph\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\t// Number of nodes in the target graph\n\t\tconst m = target.adjacencyMatrix.length;\n\t\t// If pattern is larger than target, no mapping is possible\n\t\tif (n > m) {\n\t\t\treturn false;\n\t\t}\n\t\tif (partialMapping === null) {\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\n\t\t}\n\t\tconst isLabeled = pattern.labels && target.labels;\n\t\t// Track which target nodes are already used in the mapping\n\t\tconst used = Array(m).fill(false);\n\t\tconst mapping = Array(n).fill(-1);\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\n\t\t// Pre-compute degrees for pattern and target nodes\n\t\tconst [\n\t\t\tpatternInDegrees,\n\t\t\tpatternOutDegrees,\n\t\t\ttargetInDegrees,\n\t\t\ttargetOutDegrees,\n\t\t] = this.getInOutDegrees(pattern, target);\n\t\t// Pre-compute candidate domains for pattern nodes based on degree\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\n\t\t\ttargetInDegrees\n\t\t\t\t.map((td, j) => {\n\t\t\t\t\treturn td >= pd &&\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\n\t\t\t\t\t\t(!isLabeled ||\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\n\t\t\t\t\t\t? j\n\t\t\t\t\t\t: -1;\n\t\t\t\t})\n\t\t\t\t.filter((j) => j !== -1)\n\t\t);\n\t\t// Recursive backtracking function to try all injective mappings\n\t\tconst match = (depth: number): boolean => {\n\t\t\tif (depth === n) {\n\t\t\t\treturn this.checkCompatibility(\n\t\t\t\t\tpattern,\n\t\t\t\t\ttarget,\n\t\t\t\t\tmapping,\n\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t);\n\t\t\t}\n\t\t\tfor (const candidate of domains[depth]) {\n\t\t\t\tif (!used[candidate]) {\n\t\t\t\t\tmapping[depth] = candidate;\n\t\t\t\t\tused[candidate] = true;\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.isFeasible(\n\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tmapping,\n\t\t\t\t\t\t\tdepth,\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t\t\t) &&\n\t\t\t\t\t\tmatch(depth + 1)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// Backtrack\n\t\t\t\t\tused[candidate] = false;\n\t\t\t\t\tmapping[depth] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\treturn match(0);\n\t}\n\n\tprivate getInOutDegrees(\n\t\tpattern: Graph,\n\t\ttarget: Graph\n\t): [number[], number[], number[], number[]] {\n\t\tconst patternInDegrees = pattern.adjacencyMatrix.map((r) =>\n\t\t\tr.reduce((a, b) => a + b, 0)\n\t\t);\n\t\tconst patternOutDegrees: number[] = [];\n\t\tconst targetInDegrees = target.adjacencyMatrix.map((r) =>\n\t\t\tr.reduce((a, b) => a + b, 0)\n\t\t);\n\t\tconst targetOutDegrees: number[] = [];\n\t\tpattern.adjacencyMatrix.forEach((row, i) => {\n\t\t\tpatternOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => pattern.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t});\n\t\ttarget.adjacencyMatrix.forEach((row, i) => {\n\t\t\ttargetOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => target.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t});\n\t\treturn [\n\t\t\tpatternInDegrees,\n\t\t\tpatternOutDegrees,\n\t\t\ttargetInDegrees,\n\t\t\ttargetOutDegrees,\n\t\t];\n\t}\n\n\t/**\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\n\t * including symmetries\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic override findAllSubgraphMonomorphisms(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[] = [],\n\t\tedgeLabelWildcards: string[] = [],\n\t\tpartialMapping: number[] | null = null\n\t): Mapping[] {\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\tconst m = target.adjacencyMatrix.length;\n\t\tconst results: Mapping[] = [];\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\n\t\tif (n > m) {\n\t\t\treturn results;\n\t\t}\n\t\tif (partialMapping === null) {\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\n\t\t}\n\t\tconst isLabeled = pattern.labels && target.labels;\n\t\tconst used = Array(m).fill(false);\n\t\tconst mapping = Array(n).fill(-1);\n\t\tconst [\n\t\t\tpatternInDegrees,\n\t\t\tpatternOutDegrees,\n\t\t\ttargetInDegrees,\n\t\t\ttargetOutDegrees,\n\t\t] = this.getInOutDegrees(pattern, target);\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\n\t\t\ttargetInDegrees\n\t\t\t\t.map((td, j) => {\n\t\t\t\t\treturn td >= pd &&\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\n\t\t\t\t\t\t(!isLabeled ||\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\n\t\t\t\t\t\t? j\n\t\t\t\t\t\t: -1;\n\t\t\t\t})\n\t\t\t\t.filter((j) => j !== -1)\n\t\t);\n\t\tconst match = (depth: number): void => {\n\t\t\tif (depth === n) {\n\t\t\t\tif (\n\t\t\t\t\tthis.checkCompatibility(\n\t\t\t\t\t\tpattern,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tmapping,\n\t\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tresults.push([...mapping]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (const candidate of domains[depth]) {\n\t\t\t\tif (!used[candidate]) {\n\t\t\t\t\tmapping[depth] = candidate;\n\t\t\t\t\tused[candidate] = true;\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.isFeasible(\n\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tmapping,\n\t\t\t\t\t\t\tdepth,\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tmatch(depth + 1);\n\t\t\t\t\t}\n\t\t\t\t\tused[candidate] = false;\n\t\t\t\t\tmapping[depth] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmatch(0);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Feasibility check for current depth: preserve pattern edges\n\t * and edge labels if present\n\t */\n\tprivate isFeasible(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tmapping: Mapping,\n\t\tdepth: number,\n\t\tedgeLabelWildcardsSet: Set<string>\n\t): boolean {\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\n\t\t// Check that all edges in the current partial mapping are preserved\n\t\tfor (let i = 0; i < depth; i++) {\n\t\t\tif (pattern.adjacencyMatrix[depth][i]) {\n\t\t\t\tif (!target.adjacencyMatrix[mapping[depth]][mapping[i]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check edge labels if present\n\t\t\t\tif (\n\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t!edgeLabelWildcardsSet.has(depth + ',' + i) &&\n\t\t\t\t\tpattern.edgeLabels![depth][i] !==\n\t\t\t\t\t\ttarget.edgeLabels![mapping[depth]][mapping[i]]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pattern.adjacencyMatrix[i][depth]) {\n\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[depth]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check edge labels if present\n\t\t\t\tif (\n\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + depth) &&\n\t\t\t\t\tpattern.edgeLabels![i][depth] !==\n\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[depth]]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Verifies full structural consistency of the mapping\n\t */\n\tprivate checkCompatibility(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tmapping: Mapping,\n\t\tedgeLabelWildcardsSet: Set<string>\n\t): boolean {\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tfor (let j = 0; j < n; j++) {\n\t\t\t\tif (pattern.adjacencyMatrix[i][j]) {\n\t\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[j]]) {\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + j) &&\n\t\t\t\t\t\tpattern.edgeLabels![i][j] !==\n\t\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[j]]\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge label\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n","import {Graph} from '..';\nimport {Mapping} from '../matching';\n\nexport type NodeKeySuffixGenerator = (\n\tgraph: Graph,\n\tnodeIndex: number\n) => string;\nexport type NodePropertiesMapper = (\n\tgraph: Graph,\n\tnodeIndex: number,\n\tnodeMapping: number[]\n) => Map<string, any> | undefined;\nexport type NodePropertiesCanonKeyMapper = (\n\tgraph: Graph,\n\tnodeIndex: number\n) => string;\n\n/**\n * Nauty graph canonicalization using the following graph properties\n * for ordering and selection:\n * - First, node cell membership is sorted ascending by \"outDegree|inDegree|label?\"\n * - Second, direct neighborhood cell memberships and optional edge labels are sorted\n *   ascending, concatenated, and used to further split cells.\n *   \"neighborCell_1;outEdgeLabel_1?;inEdgeLabel_1?|neighborCell_2;outEdgeLabel_2?;inEdgeLabel_2?|...\"\n *   New cell IDs of the split are assigned by descending key order.\n * - Target cell selection in the search tree is performed by selecting the leftmost (smallest) cell ID\n *   with at least two members.\n */\nexport class GraphCanon {\n\tpublic static readonly DefaultNodeKeySuffixGenerator: NodeKeySuffixGenerator =\n\t\t(graph: Graph, nodeIndex: number) => {\n\t\t\treturn graph.labels ? graph.labels[nodeIndex] : '';\n\t\t};\n\tpublic static readonly DefaultNodePropertiesMapper: NodePropertiesMapper = (\n\t\tgraph: Graph,\n\t\tnodeIndex: number,\n\t\t_nodeMapping: number[]\n\t) => {\n\t\treturn graph.nodeProperties && graph.nodeProperties[nodeIndex]\n\t\t\t? new Map(graph.nodeProperties[nodeIndex])\n\t\t\t: undefined;\n\t};\n\tpublic static readonly DefaultNodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper =\n\t\t(_graph: Graph, _nodeIndex: number) => {\n\t\t\treturn '';\n\t\t};\n\n\tprivate readonly nodeCount: number;\n\tprivate readonly hasNodeLabels: boolean;\n\tprivate readonly hasNodeProperties: boolean;\n\tprivate readonly hasEdgeLabels: boolean;\n\tprivate readonly graph: Graph;\n\tprivate readonly nodeNeighbors = new Map<number, number[]>();\n\tprivate readonly nodeKeys = new Map<number, string>();\n\tprivate readonly inDegrees = new Map<number, number>();\n\tprivate readonly outDegrees = new Map<number, number>();\n\tprivate readonly nodePropertiesMapper: NodePropertiesMapper;\n\tprivate readonly nodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper;\n\n\tpublic constructor(\n\t\tgraph: Graph,\n\t\tnodeKeySuffixGenerator: NodeKeySuffixGenerator = GraphCanon.DefaultNodeKeySuffixGenerator,\n\t\tnodePropertiesMapper: NodePropertiesMapper = GraphCanon.DefaultNodePropertiesMapper,\n\t\tnodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper = GraphCanon.DefaultNodePropertiesCanonKeyMapper\n\t) {\n\t\tthis.graph = graph;\n\t\tthis.nodeCount = graph.adjacencyMatrix.length;\n\t\tthis.hasNodeLabels = graph.labels !== undefined;\n\t\tthis.hasNodeProperties = graph.nodeProperties !== undefined;\n\t\tthis.hasEdgeLabels = graph.edgeLabels !== undefined;\n\t\tthis.nodePropertiesMapper = nodePropertiesMapper;\n\t\tthis.nodePropertiesCanonKeyMapper = nodePropertiesCanonKeyMapper;\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\tconst neighbors = new Set<number>();\n\t\t\tlet inDegree = 0;\n\t\t\tlet outDegree = 0;\n\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\tif (graph.adjacencyMatrix[i][j] === 1) {\n\t\t\t\t\toutDegree++;\n\t\t\t\t\tneighbors.add(j);\n\t\t\t\t}\n\t\t\t\tif (graph.adjacencyMatrix[j][i] === 1) {\n\t\t\t\t\tinDegree++;\n\t\t\t\t\tneighbors.add(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.inDegrees.set(i, inDegree);\n\t\t\tthis.outDegrees.set(i, outDegree);\n\t\t\tthis.nodeNeighbors.set(i, [...neighbors]);\n\t\t\tconst nodeKey =\n\t\t\t\toutDegree + '|' + inDegree + '|' + nodeKeySuffixGenerator(graph, i);\n\t\t\tthis.nodeKeys.set(i, nodeKey);\n\t\t}\n\t}\n\n\tpublic canonicalize(): [Graph, string, Mapping] {\n\t\tconst nodeCells = new Array(this.nodeCount).fill(1);\n\t\tthis.partitionByPropertyKeys(nodeCells);\n\t\tlet lexSmallestGraph: Graph | null = null;\n\t\tlet lexSmallestMapping: Mapping | null = null;\n\t\tlet lexSmallestGraphString: string | null = null;\n\n\t\tconst automorphismGroups = Array.from(\n\t\t\t{length: this.nodeCount},\n\t\t\t(_) => new Set<number>()\n\t\t);\n\t\tconst prunedSubtrees = new Set<number>();\n\n\t\tthis.individualizeDFS(\n\t\t\tnodeCells,\n\t\t\t[],\n\t\t\tprunedSubtrees,\n\t\t\t(repNodeCells, _repSuffix) => {\n\t\t\t\tfor (let i = 0; i < repNodeCells.length; i++) {\n\t\t\t\t\tautomorphismGroups[repNodeCells[i] - 1].add(i);\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < automorphismGroups.length; i++) {\n\t\t\t\t\t// Update pruned subtrees\n\t\t\t\t\tif (automorphismGroups[i].size > 1) {\n\t\t\t\t\t\tconst group = [...automorphismGroups[i]].sort();\n\t\t\t\t\t\tfor (let j = 1; j < group.length; j++) {\n\t\t\t\t\t\t\tprunedSubtrees.add(group[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst repGraph = this.buildRepresentationGraph(repNodeCells);\n\t\t\t\tconst repGraphString = this.buildGraphString(repGraph);\n\t\t\t\tif (\n\t\t\t\t\tlexSmallestGraphString === null ||\n\t\t\t\t\trepGraphString.localeCompare(lexSmallestGraphString) < 0\n\t\t\t\t) {\n\t\t\t\t\tlexSmallestGraph = repGraph;\n\t\t\t\t\tlexSmallestMapping = new Array(repNodeCells.length);\n\t\t\t\t\trepNodeCells.forEach(\n\t\t\t\t\t\t(cell, i) => (lexSmallestMapping![cell - 1] = i)\n\t\t\t\t\t);\n\t\t\t\t\tlexSmallestGraphString = repGraphString;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn [lexSmallestGraph!, lexSmallestGraphString!, lexSmallestMapping!];\n\t}\n\n\tprivate partitionByPropertyKeys(nodeCells: number[]) {\n\t\tconst propertyKeyNodeIndices = new Map<string, number[]>();\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\tconst key = this.nodeKeys.get(i)!;\n\t\t\tif (propertyKeyNodeIndices.has(key)) {\n\t\t\t\tpropertyKeyNodeIndices.get(key)!.push(i);\n\t\t\t} else {\n\t\t\t\tpropertyKeyNodeIndices.set(key, [i]);\n\t\t\t}\n\t\t}\n\t\tlet nextFreeCell = 1;\n\t\tArray.from(propertyKeyNodeIndices.keys())\n\t\t\t.sort((a, b) => a.localeCompare(b))\n\t\t\t.forEach((k) => {\n\t\t\t\tconst nodesInNextCell = propertyKeyNodeIndices.get(k)!;\n\t\t\t\tnodesInNextCell.forEach((i) => (nodeCells[i] = nextFreeCell));\n\t\t\t\tnextFreeCell += nodesInNextCell.length;\n\t\t\t});\n\t}\n\n\tprivate isCanon(nodeCells: number[]): boolean {\n\t\treturn new Set<number>(nodeCells).size === this.nodeCount;\n\t}\n\n\tprivate individualizeDFS(\n\t\tnodeCells: number[],\n\t\tsuffix: number[],\n\t\tprunedSubtrees: Set<number>,\n\t\thandleRepresentation: (nodeCells: number[], suffix: number[]) => void\n\t) {\n\t\tif (this.isCanon(nodeCells)) {\n\t\t\thandleRepresentation(nodeCells, suffix);\n\t\t\treturn;\n\t\t}\n\t\tthis.individualizationRefinement(nodeCells);\n\t\tif (this.isCanon(nodeCells)) {\n\t\t\thandleRepresentation(nodeCells, suffix);\n\t\t\treturn;\n\t\t}\n\t\tconst cells = this.getCurrentCells(nodeCells);\n\t\tconst cellToBreak = Array.from(cells.entries())\n\t\t\t.sort(([a], [b]) => a - b)\n\t\t\t.filter(([, nodes]) => nodes.length > 1)[0];\n\t\tfor (const nodeId of cellToBreak[1]) {\n\t\t\t// Check if subtree is pruned\n\t\t\tif (prunedSubtrees.has(nodeId)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst newNodeCells = [...nodeCells];\n\t\t\tcellToBreak[1].forEach((n) => {\n\t\t\t\tif (n !== nodeId) {\n\t\t\t\t\tnewNodeCells[n] = cellToBreak[0] + 1;\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst newSuffix = [...suffix, nodeId];\n\t\t\tthis.individualizeDFS(\n\t\t\t\tnewNodeCells,\n\t\t\t\tnewSuffix,\n\t\t\t\tprunedSubtrees,\n\t\t\t\thandleRepresentation\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate individualizationRefinement(nodeCells: number[]) {\n\t\tlet isEquitable = false;\n\t\twhile (!isEquitable) {\n\t\t\tisEquitable = true;\n\t\t\t// Build signature for each node\n\t\t\tconst signatures: [string, number][] = nodeCells.map((_, i) => {\n\t\t\t\tconst neighborCells = this.nodeNeighbors.get(i)!.map((n) => {\n\t\t\t\t\tlet cellInfo = nodeCells[n].toString();\n\t\t\t\t\tif (this.hasEdgeLabels) {\n\t\t\t\t\t\tcellInfo +=\n\t\t\t\t\t\t\t';' +\n\t\t\t\t\t\t\tthis.graph.edgeLabels![i][n] +\n\t\t\t\t\t\t\t';' +\n\t\t\t\t\t\t\tthis.graph.edgeLabels![n][i];\n\t\t\t\t\t}\n\t\t\t\t\treturn cellInfo;\n\t\t\t\t});\n\t\t\t\tconst signature = neighborCells.sort().join('|');\n\t\t\t\treturn [signature, i];\n\t\t\t});\n\t\t\t// Group by current cell and signature\n\t\t\tconst partitionMap = new Map<number, Map<string, number[]>>();\n\t\t\tfor (const [signature, nodeIndex] of signatures) {\n\t\t\t\tconst cell = nodeCells[nodeIndex];\n\t\t\t\tif (!partitionMap.has(cell)) {\n\t\t\t\t\tpartitionMap.set(cell, new Map());\n\t\t\t\t}\n\t\t\t\tconst cellMap = partitionMap.get(cell)!;\n\t\t\t\tif (!cellMap.has(signature)) {\n\t\t\t\t\tcellMap.set(signature, []);\n\t\t\t\t}\n\t\t\t\tcellMap.get(signature)!.push(nodeIndex);\n\t\t\t}\n\t\t\t// Partition cells based on signature blocks\n\t\t\tconst cellIds = Array.from(partitionMap.keys()).sort();\n\t\t\tfor (const cellId of cellIds) {\n\t\t\t\tconst blocks = Array.from(partitionMap.get(cellId)!.entries());\n\t\t\t\tif (blocks.length > 1) {\n\t\t\t\t\tisEquitable = false;\n\t\t\t\t\t// Sort block signatures descending\n\t\t\t\t\tblocks.sort(([sigA], [sigB]) => sigB.localeCompare(sigA));\n\t\t\t\t\tlet newCellId = cellId;\n\t\t\t\t\tblocks.forEach(([, nodes]) => {\n\t\t\t\t\t\tnodes.forEach((n) => (nodeCells[n] = newCellId));\n\t\t\t\t\t\tnewCellId += nodes.length;\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getCurrentCells(nodeCells: number[]): Map<number, number[]> {\n\t\tconst cells = new Map<number, number[]>();\n\t\tnodeCells.forEach((c, i) => {\n\t\t\tif (cells.has(c)) {\n\t\t\t\tcells.get(c)!.push(i);\n\t\t\t} else {\n\t\t\t\tcells.set(c, [i]);\n\t\t\t}\n\t\t});\n\t\treturn cells;\n\t}\n\n\t/*private getCellsString(nodeCells: number[]): string {\n\t\tconst cells = this.getCurrentCells(nodeCells);\n\t\tconst cellIds = Array.from(cells.keys()).sort();\n\t\tlet text = '[';\n\t\tfor (const cellId of cellIds) {\n\t\t\tconst nodeIds = Array.from(cells.get(cellId)!.values()).sort();\n\t\t\tif (text.length > 1) {\n\t\t\t\ttext += '|';\n\t\t\t}\n\t\t\ttext += nodeIds.join(' ');\n\t\t}\n\t\treturn text + ']';\n\t}*/\n\n\tprivate buildRepresentationGraph(nodeCells: number[]): Graph {\n\t\tconst nodeMapping = nodeCells.map((c) => c - 1);\n\t\tconst graph: Graph = {\n\t\t\tadjacencyMatrix: Array.from(\n\t\t\t\t{length: this.nodeCount},\n\t\t\t\t() => new Array(this.nodeCount)\n\t\t\t),\n\t\t};\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\tgraph.adjacencyMatrix[nodeMapping[i]][nodeMapping[j]] =\n\t\t\t\t\tthis.graph.adjacencyMatrix[i][j];\n\t\t\t}\n\t\t}\n\t\tif (this.hasNodeLabels) {\n\t\t\tgraph.labels = new Array(this.nodeCount);\n\t\t\tnodeMapping.forEach((c, i) => (graph.labels![c] = this.graph.labels![i]));\n\t\t}\n\t\tif (this.hasNodeProperties) {\n\t\t\tgraph.nodeProperties = new Array(this.nodeCount);\n\t\t\tnodeMapping.forEach(\n\t\t\t\t(c, i) =>\n\t\t\t\t\t(graph.nodeProperties![c] = this.nodePropertiesMapper(\n\t\t\t\t\t\tthis.graph,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\tnodeMapping\n\t\t\t\t\t))\n\t\t\t);\n\t\t}\n\t\tif (this.hasEdgeLabels) {\n\t\t\tgraph.edgeLabels = Array.from(\n\t\t\t\t{length: this.nodeCount},\n\t\t\t\t() => new Array(this.nodeCount)\n\t\t\t);\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\t\tgraph.edgeLabels[nodeMapping[i]][nodeMapping[j]] =\n\t\t\t\t\t\tthis.graph.edgeLabels![i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\n\tpublic buildGraphString(graph: Graph): string {\n\t\tconst edges: string[] = [];\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\tif (graph.adjacencyMatrix[i][j] === 1) {\n\t\t\t\t\tif (this.hasEdgeLabels) {\n\t\t\t\t\t\tedges.push(i + '-' + graph.edgeLabels![i][j] + '-' + j);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tedges.push(i + '-' + j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet result = edges.join('|');\n\t\tif (this.hasNodeLabels && this.hasNodeProperties) {\n\t\t\treturn (\n\t\t\t\tedges.join('|') +\n\t\t\t\t';' +\n\t\t\t\tgraph\n\t\t\t\t\t.labels!.map((l, i) => {\n\t\t\t\t\t\tconst nodePropertyCanonKey = this.nodePropertiesCanonKeyMapper(\n\t\t\t\t\t\t\tgraph,\n\t\t\t\t\t\t\ti\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\tl +\n\t\t\t\t\t\t\t(nodePropertyCanonKey.length > 0\n\t\t\t\t\t\t\t\t? '{' + nodePropertyCanonKey + '}'\n\t\t\t\t\t\t\t\t: '')\n\t\t\t\t\t\t);\n\t\t\t\t\t})\n\t\t\t\t\t.join('|')\n\t\t\t);\n\t\t} else if (this.hasNodeLabels) {\n\t\t\tresult += ';' + graph.labels!.join('|');\n\t\t} else if (this.hasNodeProperties) {\n\t\t\tresult +=\n\t\t\t\t';' +\n\t\t\t\tgraph\n\t\t\t\t\t.nodeProperties!.map((_, i) =>\n\t\t\t\t\t\tthis.nodePropertiesCanonKeyMapper(graph, i)\n\t\t\t\t\t)\n\t\t\t\t\t.join('|');\n\t\t}\n\t\treturn result;\n\t}\n}\n","import {Graph} from '.';\r\n\r\nexport class ConnectedComponents {\r\n\tpublic static find(graph: Graph): number[][] {\r\n\t\tconst result: number[][] = [];\r\n\t\tconst visited = new Set<number>();\r\n\r\n\t\tconst dfs = (node: number, component: number[]) => {\r\n\t\t\tvisited.add(node);\r\n\t\t\tcomponent.push(node);\r\n\t\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tgraph.adjacencyMatrix[node][i] === 1 ||\r\n\t\t\t\t\tgraph.adjacencyMatrix[i][node] === 1\r\n\t\t\t\t) {\r\n\t\t\t\t\tif (!visited.has(i)) {\r\n\t\t\t\t\t\tdfs(i, component);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\tif (!visited.has(i)) {\r\n\t\t\t\tconst component: number[] = [];\r\n\t\t\t\tdfs(i, component);\r\n\t\t\t\tresult.push(component);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n"],"names":["GraphMatcher","UllmannGraphMatcher","pattern","target","nodeLabelWildcards","edgeLabelWildcards","partialMapping","n","m","isLabeled","used","mapping","nodeLabelWildcardsSet","edgeLabelWildcardsSet","patternInDegrees","patternOutDegrees","targetInDegrees","targetOutDegrees","domains","pd","i","td","j","match","depth","candidate","b","row","_","a","results","isEdgeLabeled","_GraphCanon","graph","nodeKeySuffixGenerator","nodePropertiesMapper","nodePropertiesCanonKeyMapper","__publicField","neighbors","inDegree","outDegree","nodeKey","nodeCells","lexSmallestGraph","lexSmallestMapping","lexSmallestGraphString","automorphismGroups","prunedSubtrees","repNodeCells","_repSuffix","group","repGraph","repGraphString","cell","propertyKeyNodeIndices","key","nextFreeCell","k","nodesInNextCell","suffix","handleRepresentation","cells","cellToBreak","nodes","nodeId","newNodeCells","newSuffix","isEquitable","signatures","cellInfo","partitionMap","signature","nodeIndex","cellMap","cellIds","cellId","blocks","sigA","sigB","newCellId","c","nodeMapping","edges","result","l","nodePropertyCanonKey","_nodeMapping","_graph","_nodeIndex","GraphCanon","ConnectedComponents","visited","dfs","node","component"],"mappings":"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"}