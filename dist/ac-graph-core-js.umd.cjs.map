{"version":3,"file":"ac-graph-core-js.umd.cjs","sources":["../src/graph/matching/GraphMatcher.ts","../src/graph/matching/UllmannGraphMatcher.ts"],"sourcesContent":["import {Mapping} from '.';\nimport {Graph} from '..';\n\nexport abstract class GraphMatcher {\n\tpublic abstract isSubgraphIsomorphic(pattern: Graph, target: Graph): boolean;\n\n\tpublic abstract findAllSubgraphMonomorphisms(\n\t\tpattern: Graph,\n\t\ttarget: Graph\n\t): Mapping[];\n}\n","import {Mapping} from '.';\nimport {Graph} from '..';\nimport {GraphMatcher} from './GraphMatcher';\n\nexport class UllmannGraphMatcher extends GraphMatcher {\n\t/**\n\t * Subgraph isomorphism check\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t */\n\tpublic override isSubgraphIsomorphic(pattern: Graph, target: Graph): boolean {\n\t\t// Number of nodes in the pattern graph\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\t// Number of nodes in the target graph\n\t\tconst m = target.adjacencyMatrix.length;\n\t\t// If pattern is larger than target, no mapping is possible\n\t\tif (n > m) {\n\t\t\treturn false;\n\t\t}\n\t\tconst isLabeled = pattern.labels && target.labels;\n\t\t// Track which target nodes are already used in the mapping\n\t\tconst used = Array(m).fill(false);\n\t\tconst mapping = Array(n).fill(-1);\n\t\t// Pre-compute degrees for pattern and target nodes\n\t\tconst patternInDegrees: number[] = [];\n\t\tconst patternOutDegrees: number[] = [];\n\t\tconst targetInDegrees: number[] = [];\n\t\tconst targetOutDegrees: number[] = [];\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tconst row = pattern.adjacencyMatrix[i];\n\t\t\tpatternInDegrees.push(row.reduce((a, b) => a + b, 0));\n\t\t\tpatternOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => pattern.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t}\n\t\tfor (let i = 0; i < m; i++) {\n\t\t\tconst row = target.adjacencyMatrix[i];\n\t\t\ttargetInDegrees.push(row.reduce((a, b) => a + b, 0));\n\t\t\ttargetOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => target.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t}\n\t\t// Pre-compute candidate domains for pattern nodes based on degree\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\n\t\t\ttargetInDegrees\n\t\t\t\t.map((td, j) => {\n\t\t\t\t\treturn td >= pd &&\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\n\t\t\t\t\t\t(!isLabeled || pattern.labels![i] === target.labels![j])\n\t\t\t\t\t\t? j\n\t\t\t\t\t\t: -1;\n\t\t\t\t})\n\t\t\t\t.filter((j) => j !== -1)\n\t\t);\n\t\t// Recursive backtracking function to try all injective mappings\n\t\tconst match = (depth: number): boolean => {\n\t\t\tif (depth === n) {\n\t\t\t\treturn this.checkCompatibility(pattern, target, mapping);\n\t\t\t}\n\t\t\tfor (const candidate of domains[depth]) {\n\t\t\t\tif (!used[candidate]) {\n\t\t\t\t\tmapping[depth] = candidate;\n\t\t\t\t\tused[candidate] = true;\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.isFeasible(pattern, target, mapping, depth) &&\n\t\t\t\t\t\tmatch(depth + 1)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// Backtrack\n\t\t\t\t\tused[candidate] = false;\n\t\t\t\t\tmapping[depth] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\treturn match(0);\n\t}\n\n\t/**\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\n\t * including symmetries\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t */\n\tpublic override findAllSubgraphMonomorphisms(\n\t\tpattern: Graph,\n\t\ttarget: Graph\n\t): Mapping[] {\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\tconst m = target.adjacencyMatrix.length;\n\t\tconst results: Mapping[] = [];\n\t\tif (n > m) {\n\t\t\treturn results;\n\t\t}\n\t\tconst isLabeled = pattern.labels && target.labels;\n\t\tconst used = Array(m).fill(false);\n\t\tconst mapping = Array(n).fill(-1);\n\t\tconst patternInDegrees: number[] = [];\n\t\tconst patternOutDegrees: number[] = [];\n\t\tconst targetInDegrees: number[] = [];\n\t\tconst targetOutDegrees: number[] = [];\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tconst row = pattern.adjacencyMatrix[i];\n\t\t\tpatternInDegrees.push(row.reduce((a, b) => a + b, 0));\n\t\t\tpatternOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => pattern.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t}\n\t\tfor (let i = 0; i < m; i++) {\n\t\t\tconst row = target.adjacencyMatrix[i];\n\t\t\ttargetInDegrees.push(row.reduce((a, b) => a + b, 0));\n\t\t\ttargetOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => target.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t}\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\n\t\t\ttargetInDegrees\n\t\t\t\t.map((td, j) => {\n\t\t\t\t\treturn td >= pd &&\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\n\t\t\t\t\t\t(!isLabeled || pattern.labels![i] === target.labels![j])\n\t\t\t\t\t\t? j\n\t\t\t\t\t\t: -1;\n\t\t\t\t})\n\t\t\t\t.filter((j) => j !== -1)\n\t\t);\n\t\tconst match = (depth: number): void => {\n\t\t\tif (depth === n) {\n\t\t\t\tif (this.checkCompatibility(pattern, target, mapping)) {\n\t\t\t\t\tresults.push([...mapping]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (const candidate of domains[depth]) {\n\t\t\t\tif (!used[candidate]) {\n\t\t\t\t\tmapping[depth] = candidate;\n\t\t\t\t\tused[candidate] = true;\n\t\t\t\t\tif (this.isFeasible(pattern, target, mapping, depth)) {\n\t\t\t\t\t\tmatch(depth + 1);\n\t\t\t\t\t}\n\t\t\t\t\tused[candidate] = false;\n\t\t\t\t\tmapping[depth] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmatch(0);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Feasibility check for current depth: preserve pattern edges\n\t * and edge labels if present\n\t */\n\tprivate isFeasible(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tmapping: Mapping,\n\t\tdepth: number\n\t): boolean {\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\n\t\t// Check that all edges in the current partial mapping are preserved\n\t\tfor (let i = 0; i < depth; i++) {\n\t\t\tif (pattern.adjacencyMatrix[depth][i]) {\n\t\t\t\tif (!target.adjacencyMatrix[mapping[depth]][mapping[i]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check edge labels if present\n\t\t\t\tif (\n\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\tpattern.edgeLabels![depth][i] !==\n\t\t\t\t\t\ttarget.edgeLabels![mapping[depth]][mapping[i]]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pattern.adjacencyMatrix[i][depth]) {\n\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[depth]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check edge labels if present\n\t\t\t\tif (\n\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\tpattern.edgeLabels![i][depth] !==\n\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[depth]]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Verifies full structural consistency of the mapping\n\t */\n\tprivate checkCompatibility(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tmapping: Mapping\n\t): boolean {\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tfor (let j = 0; j < n; j++) {\n\t\t\t\tif (pattern.adjacencyMatrix[i][j]) {\n\t\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[j]]) {\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t\tpattern.edgeLabels![i][j] !==\n\t\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[j]]\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge label\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n"],"names":["GraphMatcher","UllmannGraphMatcher","pattern","target","m","isLabeled","used","mapping","patternInDegrees","patternOutDegrees","targetInDegrees","targetOutDegrees","i","row","a","b","_","j","domains","pd","td","match","depth","candidate","results","isEdgeLabeled","n"],"mappings":"mOAGO,MAAeA,CAAa,CAOnC,CCNO,MAAMC,UAA4BD,CAAa,CAMrC,qBAAqBE,EAAgBC,EAAwB,CAEtE,MAAA,EAAID,EAAQ,gBAAgB,OAE5BE,EAAID,EAAO,gBAAgB,OAEjC,GAAI,EAAIC,EACA,MAAA,GAEF,MAAAC,EAAYH,EAAQ,QAAUC,EAAO,OAErCG,EAAO,MAAMF,CAAC,EAAE,KAAK,EAAK,EAC1BG,EAAU,MAAM,CAAC,EAAE,KAAK,EAAE,EAE1BC,EAA6B,CAAC,EAC9BC,EAA8B,CAAC,EAC/BC,EAA4B,CAAC,EAC7BC,EAA6B,CAAC,EACpC,QAASC,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACrB,MAAAC,EAAMX,EAAQ,gBAAgBU,CAAC,EACpBJ,EAAA,KAAKK,EAAI,OAAO,CAACC,EAAGC,IAAMD,EAAIC,EAAG,CAAC,CAAC,EAClCN,EAAA,KACjBI,EACE,IAAI,CAACG,EAAGC,IAAMf,EAAQ,gBAAgBe,CAAC,EAAEL,CAAC,CAAC,EAC3C,OAAO,CAACE,EAAGC,IAAMD,EAAIC,EAAG,CAAC,CAC5B,CAAA,CAED,QAASH,EAAI,EAAGA,EAAIR,EAAGQ,IAAK,CACrB,MAAAC,EAAMV,EAAO,gBAAgBS,CAAC,EACpBF,EAAA,KAAKG,EAAI,OAAO,CAACC,EAAGC,IAAMD,EAAIC,EAAG,CAAC,CAAC,EAClCJ,EAAA,KAChBE,EACE,IAAI,CAACG,EAAGC,IAAMd,EAAO,gBAAgBc,CAAC,EAAEL,CAAC,CAAC,EAC1C,OAAO,CAACE,EAAGC,IAAMD,EAAIC,EAAG,CAAC,CAC5B,CAAA,CAGD,MAAMG,EAAsBV,EAAiB,IAAI,CAACW,EAAIP,IACrDF,EACE,IAAI,CAACU,EAAIH,IACFG,GAAMD,GACZR,EAAiBM,CAAC,GAAKR,EAAkBG,CAAC,IACzC,CAACP,GAAaH,EAAQ,OAAQU,CAAC,IAAMT,EAAO,OAAQc,CAAC,GACpDA,EACA,EACH,EACA,OAAQA,GAAMA,IAAM,EAAE,CACzB,EAEMI,EAASC,GAA2B,CACzC,GAAIA,IAAU,EACb,OAAO,KAAK,mBAAmBpB,EAASC,EAAQI,CAAO,EAE7C,UAAAgB,KAAaL,EAAQI,CAAK,EAChC,GAAA,CAAChB,EAAKiB,CAAS,EAAG,CAIpB,GAHDhB,EAAQe,CAAK,EAAIC,EACjBjB,EAAKiB,CAAS,EAAI,GAEjB,KAAK,WAAWrB,EAASC,EAAQI,EAASe,CAAK,GAC/CD,EAAMC,EAAQ,CAAC,EAER,MAAA,GAGRhB,EAAKiB,CAAS,EAAI,GAClBhB,EAAQe,CAAK,EAAI,EAAA,CAGZ,MAAA,EACR,EACA,OAAOD,EAAM,CAAC,CAAA,CASC,6BACfnB,EACAC,EACY,CACN,MAAA,EAAID,EAAQ,gBAAgB,OAC5BE,EAAID,EAAO,gBAAgB,OAC3BqB,EAAqB,CAAC,EAC5B,GAAI,EAAIpB,EACA,OAAAoB,EAEF,MAAAnB,EAAYH,EAAQ,QAAUC,EAAO,OACrCG,EAAO,MAAMF,CAAC,EAAE,KAAK,EAAK,EAC1BG,EAAU,MAAM,CAAC,EAAE,KAAK,EAAE,EAC1BC,EAA6B,CAAC,EAC9BC,EAA8B,CAAC,EAC/BC,EAA4B,CAAC,EAC7BC,EAA6B,CAAC,EACpC,QAASC,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACrB,MAAAC,EAAMX,EAAQ,gBAAgBU,CAAC,EACpBJ,EAAA,KAAKK,EAAI,OAAO,CAACC,EAAGC,IAAMD,EAAIC,EAAG,CAAC,CAAC,EAClCN,EAAA,KACjBI,EACE,IAAI,CAACG,EAAGC,IAAMf,EAAQ,gBAAgBe,CAAC,EAAEL,CAAC,CAAC,EAC3C,OAAO,CAACE,EAAGC,IAAMD,EAAIC,EAAG,CAAC,CAC5B,CAAA,CAED,QAASH,EAAI,EAAGA,EAAIR,EAAGQ,IAAK,CACrB,MAAAC,EAAMV,EAAO,gBAAgBS,CAAC,EACpBF,EAAA,KAAKG,EAAI,OAAO,CAACC,EAAGC,IAAMD,EAAIC,EAAG,CAAC,CAAC,EAClCJ,EAAA,KAChBE,EACE,IAAI,CAACG,EAAGC,IAAMd,EAAO,gBAAgBc,CAAC,EAAEL,CAAC,CAAC,EAC1C,OAAO,CAACE,EAAGC,IAAMD,EAAIC,EAAG,CAAC,CAC5B,CAAA,CAED,MAAMG,EAAsBV,EAAiB,IAAI,CAACW,EAAIP,IACrDF,EACE,IAAI,CAACU,EAAIH,IACFG,GAAMD,GACZR,EAAiBM,CAAC,GAAKR,EAAkBG,CAAC,IACzC,CAACP,GAAaH,EAAQ,OAAQU,CAAC,IAAMT,EAAO,OAAQc,CAAC,GACpDA,EACA,EACH,EACA,OAAQA,GAAMA,IAAM,EAAE,CACzB,EACMI,EAASC,GAAwB,CACtC,GAAIA,IAAU,EAAG,CACZ,KAAK,mBAAmBpB,EAASC,EAAQI,CAAO,GACnDiB,EAAQ,KAAK,CAAC,GAAGjB,CAAO,CAAC,EAE1B,MAAA,CAEU,UAAAgB,KAAaL,EAAQI,CAAK,EAC/BhB,EAAKiB,CAAS,IAClBhB,EAAQe,CAAK,EAAIC,EACjBjB,EAAKiB,CAAS,EAAI,GACd,KAAK,WAAWrB,EAASC,EAAQI,EAASe,CAAK,GAClDD,EAAMC,EAAQ,CAAC,EAEhBhB,EAAKiB,CAAS,EAAI,GAClBhB,EAAQe,CAAK,EAAI,GAGpB,EACA,OAAAD,EAAM,CAAC,EACAG,CAAA,CAOA,WACPtB,EACAC,EACAI,EACAe,EACU,CACJ,MAAAG,EAAgBvB,EAAQ,YAAcC,EAAO,WAEnD,QAAS,EAAI,EAAG,EAAImB,EAAO,IAc1B,GAbIpB,EAAQ,gBAAgBoB,CAAK,EAAE,CAAC,IAC/B,CAACnB,EAAO,gBAAgBI,EAAQe,CAAK,CAAC,EAAEf,EAAQ,CAAC,CAAC,GAKrDkB,GACAvB,EAAQ,WAAYoB,CAAK,EAAE,CAAC,IAC3BnB,EAAO,WAAYI,EAAQe,CAAK,CAAC,EAAEf,EAAQ,CAAC,CAAC,IAK5CL,EAAQ,gBAAgB,CAAC,EAAEoB,CAAK,IAC/B,CAACnB,EAAO,gBAAgBI,EAAQ,CAAC,CAAC,EAAEA,EAAQe,CAAK,CAAC,GAKrDG,GACAvB,EAAQ,WAAY,CAAC,EAAEoB,CAAK,IAC3BnB,EAAO,WAAYI,EAAQ,CAAC,CAAC,EAAEA,EAAQe,CAAK,CAAC,GAEvC,MAAA,GAIH,MAAA,EAAA,CAMA,mBACPpB,EACAC,EACAI,EACU,CACJ,MAAAkB,EAAgBvB,EAAQ,YAAcC,EAAO,WAC7CuB,EAAIxB,EAAQ,gBAAgB,OAClC,QAAS,EAAI,EAAG,EAAIwB,EAAG,IACtB,QAAST,EAAI,EAAGA,EAAIS,EAAGT,IACtB,GAAIf,EAAQ,gBAAgB,CAAC,EAAEe,CAAC,IAC3B,CAACd,EAAO,gBAAgBI,EAAQ,CAAC,CAAC,EAAEA,EAAQU,CAAC,CAAC,GAKjDQ,GACAvB,EAAQ,WAAY,CAAC,EAAEe,CAAC,IACvBd,EAAO,WAAYI,EAAQ,CAAC,CAAC,EAAEA,EAAQU,CAAC,CAAC,GAGnC,MAAA,GAKJ,MAAA,EAAA,CAET"}