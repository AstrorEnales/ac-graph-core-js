{"version":3,"file":"ac-graph-core-js.umd.cjs","sources":["../src/graph/matching/GraphMatcher.ts","../src/graph/matching/UllmannGraphMatcher.ts","../src/graph/Automorphism.ts","../src/graph/canon/GraphCanon.ts","../src/graph/ConnectedComponents.ts","../src/graph/index.ts"],"sourcesContent":["import {Mapping} from '.';\nimport {Graph} from '..';\n\nexport abstract class GraphMatcher {\n\t/**\n\t * Subgraph isomorphism check\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic abstract isSubgraphIsomorphic(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[],\n\t\tedgeLabelWildcards: string[],\n\t\tpartialMapping: number[] | null\n\t): boolean;\n\n\t/**\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\n\t * including symmetries\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic abstract findAllSubgraphMonomorphisms(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[],\n\t\tedgeLabelWildcards: string[],\n\t\tpartialMapping: number[] | null\n\t): Mapping[];\n}\n","import {Mapping} from '.';\nimport {Graph} from '..';\nimport {GraphMatcher} from './GraphMatcher';\n\nexport class UllmannGraphMatcher extends GraphMatcher {\n\t/**\n\t * Subgraph isomorphism check\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic override isSubgraphIsomorphic(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[] = [],\n\t\tedgeLabelWildcards: string[] = [],\n\t\tpartialMapping: number[] | null = null\n\t): boolean {\n\t\t// Number of nodes in the pattern graph\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\t// Number of nodes in the target graph\n\t\tconst m = target.adjacencyMatrix.length;\n\t\t// If pattern is larger than target, no mapping is possible\n\t\tif (n > m) {\n\t\t\treturn false;\n\t\t}\n\t\tif (partialMapping === null) {\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\n\t\t}\n\t\tconst isLabeled = pattern.labels && target.labels;\n\t\t// Track which target nodes are already used in the mapping\n\t\tconst used = Array(m).fill(false);\n\t\tconst mapping = Array(n).fill(-1);\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\n\t\t// Pre-compute degrees for pattern and target nodes\n\t\tconst [\n\t\t\tpatternInDegrees,\n\t\t\tpatternOutDegrees,\n\t\t\ttargetInDegrees,\n\t\t\ttargetOutDegrees,\n\t\t] = this.getInOutDegrees(pattern, target);\n\t\t// Pre-compute candidate domains for pattern nodes based on degree\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\n\t\t\ttargetInDegrees\n\t\t\t\t.map((td, j) => {\n\t\t\t\t\treturn td >= pd &&\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\n\t\t\t\t\t\t(!isLabeled ||\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\n\t\t\t\t\t\t? j\n\t\t\t\t\t\t: -1;\n\t\t\t\t})\n\t\t\t\t.filter((j) => j !== -1)\n\t\t);\n\t\t// Recursive backtracking function to try all injective mappings\n\t\tconst match = (depth: number): boolean => {\n\t\t\tif (depth === n) {\n\t\t\t\treturn this.checkCompatibility(\n\t\t\t\t\tpattern,\n\t\t\t\t\ttarget,\n\t\t\t\t\tmapping,\n\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t);\n\t\t\t}\n\t\t\tfor (const candidate of domains[depth]) {\n\t\t\t\tif (!used[candidate]) {\n\t\t\t\t\tmapping[depth] = candidate;\n\t\t\t\t\tused[candidate] = true;\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.isFeasible(\n\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tmapping,\n\t\t\t\t\t\t\tdepth,\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t\t\t) &&\n\t\t\t\t\t\tmatch(depth + 1)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// Backtrack\n\t\t\t\t\tused[candidate] = false;\n\t\t\t\t\tmapping[depth] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\treturn match(0);\n\t}\n\n\tprivate getInOutDegrees(\n\t\tpattern: Graph,\n\t\ttarget: Graph\n\t): [number[], number[], number[], number[]] {\n\t\tconst patternInDegrees = pattern.adjacencyMatrix.map((r) =>\n\t\t\tr.reduce((a, b) => a + b, 0)\n\t\t);\n\t\tconst patternOutDegrees: number[] = [];\n\t\tconst targetInDegrees = target.adjacencyMatrix.map((r) =>\n\t\t\tr.reduce((a, b) => a + b, 0)\n\t\t);\n\t\tconst targetOutDegrees: number[] = [];\n\t\tpattern.adjacencyMatrix.forEach((row, i) => {\n\t\t\tpatternOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => pattern.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t});\n\t\ttarget.adjacencyMatrix.forEach((row, i) => {\n\t\t\ttargetOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => target.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t});\n\t\treturn [\n\t\t\tpatternInDegrees,\n\t\t\tpatternOutDegrees,\n\t\t\ttargetInDegrees,\n\t\t\ttargetOutDegrees,\n\t\t];\n\t}\n\n\t/**\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\n\t * including symmetries\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic override findAllSubgraphMonomorphisms(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[] = [],\n\t\tedgeLabelWildcards: string[] = [],\n\t\tpartialMapping: number[] | null = null\n\t): Mapping[] {\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\tconst m = target.adjacencyMatrix.length;\n\t\tconst results: Mapping[] = [];\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\n\t\tif (n > m) {\n\t\t\treturn results;\n\t\t}\n\t\tif (partialMapping === null) {\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\n\t\t}\n\t\tconst isLabeled = pattern.labels && target.labels;\n\t\tconst used = Array(m).fill(false);\n\t\tconst mapping = Array(n).fill(-1);\n\t\tconst [\n\t\t\tpatternInDegrees,\n\t\t\tpatternOutDegrees,\n\t\t\ttargetInDegrees,\n\t\t\ttargetOutDegrees,\n\t\t] = this.getInOutDegrees(pattern, target);\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\n\t\t\ttargetInDegrees\n\t\t\t\t.map((td, j) => {\n\t\t\t\t\treturn td >= pd &&\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\n\t\t\t\t\t\t(!isLabeled ||\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\n\t\t\t\t\t\t? j\n\t\t\t\t\t\t: -1;\n\t\t\t\t})\n\t\t\t\t.filter((j) => j !== -1)\n\t\t);\n\t\tconst match = (depth: number): void => {\n\t\t\tif (depth === n) {\n\t\t\t\tif (\n\t\t\t\t\tthis.checkCompatibility(\n\t\t\t\t\t\tpattern,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tmapping,\n\t\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tresults.push([...mapping]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (const candidate of domains[depth]) {\n\t\t\t\tif (!used[candidate]) {\n\t\t\t\t\tmapping[depth] = candidate;\n\t\t\t\t\tused[candidate] = true;\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.isFeasible(\n\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tmapping,\n\t\t\t\t\t\t\tdepth,\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tmatch(depth + 1);\n\t\t\t\t\t}\n\t\t\t\t\tused[candidate] = false;\n\t\t\t\t\tmapping[depth] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmatch(0);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Feasibility check for current depth: preserve pattern edges\n\t * and edge labels if present\n\t */\n\tprivate isFeasible(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tmapping: Mapping,\n\t\tdepth: number,\n\t\tedgeLabelWildcardsSet: Set<string>\n\t): boolean {\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\n\t\t// Check that all edges in the current partial mapping are preserved\n\t\tfor (let i = 0; i < depth; i++) {\n\t\t\tif (pattern.adjacencyMatrix[depth][i]) {\n\t\t\t\tif (!target.adjacencyMatrix[mapping[depth]][mapping[i]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check edge labels if present\n\t\t\t\tif (\n\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t!edgeLabelWildcardsSet.has(depth + ',' + i) &&\n\t\t\t\t\tpattern.edgeLabels![depth][i] !==\n\t\t\t\t\t\ttarget.edgeLabels![mapping[depth]][mapping[i]]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pattern.adjacencyMatrix[i][depth]) {\n\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[depth]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check edge labels if present\n\t\t\t\tif (\n\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + depth) &&\n\t\t\t\t\tpattern.edgeLabels![i][depth] !==\n\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[depth]]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Verifies full structural consistency of the mapping\n\t */\n\tprivate checkCompatibility(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tmapping: Mapping,\n\t\tedgeLabelWildcardsSet: Set<string>\n\t): boolean {\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tfor (let j = 0; j < n; j++) {\n\t\t\t\tif (pattern.adjacencyMatrix[i][j]) {\n\t\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[j]]) {\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + j) &&\n\t\t\t\t\t\tpattern.edgeLabels![i][j] !==\n\t\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[j]]\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge label\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n","export class Automorphism {\n\tpublic readonly mappings: Map<number, number>;\n\tpublic readonly cycles: number[][] = [];\n\n\tconstructor(mappings: Map<number, number>) {\n\t\tthis.mappings = mappings;\n\t\tif (new Set(mappings.values()).size !== mappings.size) {\n\t\t\tthrow 'Automorphism is not bijective';\n\t\t}\n\t\tconst visited = new Set<number>();\n\t\tconst keys = [...mappings.keys()].sort();\n\t\tfor (const key of keys) {\n\t\t\tif (!visited.has(key)) {\n\t\t\t\tvisited.add(key);\n\t\t\t\tconst cycle = [key];\n\t\t\t\twhile (mappings.has(cycle[cycle.length - 1])) {\n\t\t\t\t\tconst value = mappings.get(cycle[cycle.length - 1])!;\n\t\t\t\t\tvisited.add(value);\n\t\t\t\t\tif (value !== cycle[0]) {\n\t\t\t\t\t\tcycle.push(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cycle.length > 1) {\n\t\t\t\t\tthis.cycles.push(cycle);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic apply(x: number): number {\n\t\treturn this.mappings.get(x)!;\n\t}\n\n\t/**\n\t * Compose this automorphism (f) with another one (g): (f ∘ g)(x) = f(g(x))\n\t */\n\tpublic compose(g: Automorphism): Automorphism {\n\t\tconst h = new Map<number, number>();\n\t\tfor (const x of this.mappings.keys()) {\n\t\t\tconst gx = g.apply(x);\n\t\t\tconst fgx = this.apply(gx);\n\t\t\th.set(x, fgx);\n\t\t}\n\t\treturn new Automorphism(h);\n\t}\n\n\tpublic reverse(): Automorphism {\n\t\treturn new Automorphism(\n\t\t\tnew Map([...this.mappings.entries()].map(([k, v]) => [v, k]))\n\t\t);\n\t}\n\n\tpublic equals(g: Automorphism): boolean {\n\t\tfor (const key of this.mappings.keys()) {\n\t\t\tif (this.mappings.get(key)! !== g.mappings.get(key)!) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic isIdentity(): boolean {\n\t\tfor (const key of this.mappings.keys()) {\n\t\t\tif (this.mappings.get(key)! !== key) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic toString(): string {\n\t\tif (this.cycles.length === 0) {\n\t\t\treturn '()';\n\t\t}\n\t\treturn this.cycles\n\t\t\t.map((m) => `(${m.join(' ')})`)\n\t\t\t.sort()\n\t\t\t.join('');\n\t}\n}\n\nexport class AutomorphismGroup {\n\tpublic readonly generators: Automorphism[];\n\n\tconstructor(generators: Automorphism[], n: number) {\n\t\tif (generators.some((g) => g.isIdentity())) {\n\t\t\tthis.generators = [...generators];\n\t\t} else {\n\t\t\tconst identity = new Automorphism(\n\t\t\t\tnew Map(Array.from({length: n}, (_, i) => [i, i]))\n\t\t\t);\n\t\t\tthis.generators = [identity, ...generators];\n\t\t}\n\t}\n\n\tpublic orbitOf(x: number): number[] {\n\t\tconst orbit = new Set<number>();\n\t\torbit.add(x);\n\t\tfor (const aut of this.generators) {\n\t\t\torbit.add(aut.apply(x));\n\t\t}\n\t\treturn Array.from(orbit).sort();\n\t}\n\n\tpublic stabilizerOf(x: number): Automorphism[] {\n\t\treturn this.generators.filter((aut) => aut.apply(x) === x);\n\t}\n\n\tpublic stabilizerSizeOf(x: number): number {\n\t\treturn this.generators.reduce(\n\t\t\t(c, aut) => (c += aut.apply(x) === x ? 1 : 0),\n\t\t\t0\n\t\t);\n\t}\n\n\t/**\n\t * Orbit size of x via Orbit–Stabilizer Theorem.\n\t */\n\tpublic orbitSizeOf(x: number): number {\n\t\treturn this.generators.length / this.stabilizerSizeOf(x);\n\t}\n\n\tpublic orbits(): number[][] {\n\t\tconst seen = new Set<number>();\n\t\tconst orbits: number[][] = [];\n\t\tfor (const g of this.generators[0].mappings.keys()) {\n\t\t\tif (!seen.has(g)) {\n\t\t\t\tconst orb = this.orbitOf(g);\n\t\t\t\torb.forEach((x) => seen.add(x));\n\t\t\t\torbits.push(orb);\n\t\t\t}\n\t\t}\n\t\treturn orbits;\n\t}\n\n\tpublic closure(): Automorphism[] {\n\t\tconst result: Automorphism[] = [];\n\t\tconst visited = new Set<string>();\n\t\tconst addIfUnvisited = (aut: Automorphism) => {\n\t\t\tconst key = aut.toString();\n\t\t\tif (!visited.has(key)) {\n\t\t\t\tresult.push(aut);\n\t\t\t\tvisited.add(key);\n\t\t\t}\n\t\t};\n\t\tconst queue = [\n\t\t\t...this.generators,\n\t\t\t...this.generators.map((g) => g.reverse()),\n\t\t];\n\t\tqueue.forEach((aut) => addIfUnvisited(aut));\n\t\twhile (queue.length > 0) {\n\t\t\tconst f = queue.pop()!;\n\t\t\tfor (const g of result) {\n\t\t\t\taddIfUnvisited(f.compose(g));\n\t\t\t\taddIfUnvisited(g.compose(f));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toString(): string {\n\t\treturn '[' + this.generators.map((g) => g.toString()).join(', ') + ']';\n\t}\n}\n","import {Graph} from '..';\nimport {Automorphism, AutomorphismGroup} from '../Automorphism';\nimport {Mapping} from '../matching';\n\nexport type NodeKeySuffixGenerator = (\n\tgraph: Graph,\n\tnodeIndex: number\n) => string;\nexport type NodePropertiesMapper = (\n\tgraph: Graph,\n\tnodeIndex: number,\n\tnodeMapping: number[]\n) => Map<string, any> | undefined;\nexport type NodeLabelCanonKeyMapper = (\n\tgraph: Graph,\n\tnodeIndex: number\n) => string;\nexport type EdgeLabelCanonKeyMapper = (\n\tgraph: Graph,\n\tsourceNodeIndex: number,\n\ttargetNodeIndex: number\n) => string;\nexport type NodePropertiesCanonKeyMapper = (\n\tgraph: Graph,\n\tnodeIndex: number\n) => string;\n\n/**\n * Nauty graph canonicalization using the following graph properties\n * for ordering and selection:\n * - First, node cell membership is sorted ascending by \"outDegree|inDegree|label?\"\n * - Second, direct neighborhood cell memberships and optional edge labels are sorted\n *   ascending, concatenated, and used to further split cells.\n *   \"neighborCell_1;outEdgeLabel_1?;inEdgeLabel_1?|neighborCell_2;outEdgeLabel_2?;inEdgeLabel_2?|...\"\n *   New cell IDs of the split are assigned by descending key order.\n * - Target cell selection in the search tree is performed by selecting the leftmost (smallest) cell ID\n *   with at least two members.\n */\nexport class GraphCanon {\n\tpublic static readonly KEY_VERSION = 'v2';\n\tpublic static readonly DefaultNodeKeySuffixGenerator: NodeKeySuffixGenerator =\n\t\t(graph: Graph, nodeIndex: number) => {\n\t\t\treturn graph.labels ? graph.labels[nodeIndex] : '';\n\t\t};\n\tpublic static readonly DefaultNodePropertiesMapper: NodePropertiesMapper = (\n\t\tgraph: Graph,\n\t\tnodeIndex: number,\n\t\t_nodeMapping: number[]\n\t) => {\n\t\treturn graph.nodeProperties && graph.nodeProperties[nodeIndex]\n\t\t\t? new Map(graph.nodeProperties[nodeIndex])\n\t\t\t: undefined;\n\t};\n\tpublic static readonly DefaultNodeLabelCanonKeyMapper: NodeLabelCanonKeyMapper =\n\t\t(graph: Graph, nodeIndex: number) => {\n\t\t\treturn graph.labels ? graph.labels[nodeIndex] : '';\n\t\t};\n\tpublic static readonly DefaultEdgeLabelCanonKeyMapper: EdgeLabelCanonKeyMapper =\n\t\t(graph: Graph, sourceNodeIndex: number, targetNodeIndex: number) => {\n\t\t\treturn graph.edgeLabels\n\t\t\t\t? graph.edgeLabels[sourceNodeIndex][targetNodeIndex]\n\t\t\t\t: '';\n\t\t};\n\tpublic static readonly DefaultNodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper =\n\t\t(_graph: Graph, _nodeIndex: number) => {\n\t\t\treturn '';\n\t\t};\n\n\tprivate readonly nodeCount: number;\n\tprivate readonly hasNodeLabels: boolean;\n\tprivate readonly hasNodeProperties: boolean;\n\tprivate readonly hasEdgeLabels: boolean;\n\tprivate readonly isSymmetric: boolean;\n\tprivate readonly graph: Graph;\n\tprivate readonly nodeNeighbors = new Map<number, number[]>();\n\tprivate readonly nodeKeys = new Map<number, string>();\n\tprivate readonly nodePropertiesMapper: NodePropertiesMapper;\n\tprivate readonly nodeLabelCanonKeyMapper: NodeLabelCanonKeyMapper;\n\tprivate readonly edgeLabelCanonKeyMapper: EdgeLabelCanonKeyMapper;\n\tprivate readonly nodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper;\n\tprivate readonly graphStringBuilder: (graph: Graph) => string;\n\n\tpublic constructor(\n\t\tgraph: Graph,\n\t\tnodeKeySuffixGenerator: NodeKeySuffixGenerator = GraphCanon.DefaultNodeKeySuffixGenerator,\n\t\tnodePropertiesMapper: NodePropertiesMapper = GraphCanon.DefaultNodePropertiesMapper,\n\t\tnodeLabelCanonKeyMapper: NodeLabelCanonKeyMapper = GraphCanon.DefaultNodeLabelCanonKeyMapper,\n\t\tedgeLabelCanonKeyMapper: EdgeLabelCanonKeyMapper = GraphCanon.DefaultEdgeLabelCanonKeyMapper,\n\t\tnodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper = GraphCanon.DefaultNodePropertiesCanonKeyMapper\n\t) {\n\t\tthis.graph = graph;\n\t\tthis.nodeCount = graph.adjacencyMatrix.length;\n\t\tthis.hasNodeLabels = graph.labels !== undefined;\n\t\tthis.hasNodeProperties = graph.nodeProperties !== undefined;\n\t\tthis.hasEdgeLabels = graph.edgeLabels !== undefined;\n\t\tthis.nodePropertiesMapper = nodePropertiesMapper;\n\t\tthis.nodeLabelCanonKeyMapper = nodeLabelCanonKeyMapper;\n\t\tthis.edgeLabelCanonKeyMapper = edgeLabelCanonKeyMapper;\n\t\tthis.nodePropertiesCanonKeyMapper = nodePropertiesCanonKeyMapper;\n\t\tlet isSymmetric = true;\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\tconst neighbors = new Set<number>();\n\t\t\tlet inDegree = 0;\n\t\t\tlet outDegree = 0;\n\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\tconst isOut = graph.adjacencyMatrix[i][j];\n\t\t\t\tconst isIn = graph.adjacencyMatrix[j][i];\n\t\t\t\tif (isOut === 1) {\n\t\t\t\t\toutDegree++;\n\t\t\t\t\tneighbors.add(j);\n\t\t\t\t}\n\t\t\t\tif (isIn === 1) {\n\t\t\t\t\tinDegree++;\n\t\t\t\t\tneighbors.add(j);\n\t\t\t\t}\n\t\t\t\tif (isOut !== isIn) {\n\t\t\t\t\tisSymmetric = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.nodeNeighbors.set(i, [...neighbors]);\n\t\t\tconst nodeKey =\n\t\t\t\toutDegree + '|' + inDegree + '|' + nodeKeySuffixGenerator(graph, i);\n\t\t\tthis.nodeKeys.set(i, nodeKey);\n\t\t}\n\t\tthis.isSymmetric = isSymmetric;\n\t\t// Finally build the curried graph key function\n\t\tthis.graphStringBuilder = this.buildGraphStringCurry();\n\t}\n\n\t/**\n\t * Canonicalize the graph\n\t * @returns\n\t * 1. canonical graph representation\n\t * 2. graph key\n\t * 3. node mapping from the original to the canonical graph\n\t * 4. automorphisms\n\t */\n\tpublic canonicalize(): [Graph, string, Mapping, AutomorphismGroup] {\n\t\tconst nodeCells = new Array(this.nodeCount).fill(1);\n\t\tthis.partitionByPropertyKeys(nodeCells);\n\t\tconst partitions: Map<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpartitions: Map<number, number>[];\n\t\t\t\tautomorphisms: Map<string, Automorphism>;\n\t\t\t}\n\t\t> = new Map();\n\t\tconst prunedSubtrees = new Set<string>();\n\t\tthis.individualizeDFS(\n\t\t\tnodeCells,\n\t\t\t[],\n\t\t\tprunedSubtrees,\n\t\t\tthis.handleRepresentationCurry(partitions, prunedSubtrees)\n\t\t);\n\t\tconst lexSmallestKey = [...partitions.keys()].sort((a, b) =>\n\t\t\ta.localeCompare(b)\n\t\t)[0];\n\t\tconst partition = partitions.get(lexSmallestKey)!;\n\t\tconst smallestRepresentation = new Array(this.nodeCount);\n\t\tconst lexSmallestMapping = new Array(smallestRepresentation.length);\n\t\t[...partition.partitions[0].entries()].forEach(([c, i]) => {\n\t\t\tsmallestRepresentation[i] = c;\n\t\t\tlexSmallestMapping[c - 1] = i;\n\t\t});\n\t\tconst lexSmallestGraph = this.buildRepresentationGraph(\n\t\t\tsmallestRepresentation\n\t\t);\n\t\tconst allAutomorphisms = new Map<string, Automorphism>();\n\t\t[...partitions.values()].forEach((p) =>\n\t\t\t[...p.automorphisms.entries()].forEach(([key, aut]) =>\n\t\t\t\tallAutomorphisms.set(key, aut)\n\t\t\t)\n\t\t);\n\t\treturn [\n\t\t\tlexSmallestGraph,\n\t\t\tthis.buildGraphString(lexSmallestGraph),\n\t\t\tlexSmallestMapping,\n\t\t\tnew AutomorphismGroup([...allAutomorphisms.values()], this.nodeCount),\n\t\t];\n\t}\n\n\tprivate handleRepresentationCurry(\n\t\tpartitions: Map<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpartitions: Map<number, number>[];\n\t\t\t\tautomorphisms: Map<string, Automorphism>;\n\t\t\t}\n\t\t>,\n\t\tprunedSubtrees: Set<string>\n\t): (nodeCells: number[], suffix: number[]) => void {\n\t\tconst cellIds = Array.from({length: this.nodeCount}, (_, i) => i + 1);\n\t\treturn (repNodeCells, suffix) => {\n\t\t\t// Build the partition key for comparison with other partitions\n\t\t\tconst partition = new Map<number, number>();\n\t\t\trepNodeCells.forEach((c, i) => partition.set(c, i));\n\t\t\tconst partitionKey = cellIds\n\t\t\t\t.map((c) =>\n\t\t\t\t\tthis.nodeNeighbors\n\t\t\t\t\t\t.get(partition.get(c)!)!\n\t\t\t\t\t\t.map((n) => repNodeCells[n])\n\t\t\t\t\t\t.sort()\n\t\t\t\t\t\t.join(';')\n\t\t\t\t)\n\t\t\t\t.join('|');\n\t\t\tlet sameRepresentations = partitions.get(partitionKey);\n\t\t\tif (sameRepresentations === undefined) {\n\t\t\t\tsameRepresentations = {\n\t\t\t\t\tpartitions: [],\n\t\t\t\t\tautomorphisms: new Map(),\n\t\t\t\t};\n\t\t\t\tpartitions.set(partitionKey, sameRepresentations);\n\t\t\t}\n\n\t\t\tfor (const partition of sameRepresentations.partitions) {\n\t\t\t\tconst automorphismMap = new Map<number, number>();\n\t\t\t\tfor (let i = 0; i < repNodeCells.length; i++) {\n\t\t\t\t\tconst partitionIndex = partition.get(repNodeCells[i])!;\n\t\t\t\t\tautomorphismMap.set(i, partitionIndex);\n\t\t\t\t}\n\t\t\t\tconst automorphism = new Automorphism(automorphismMap);\n\t\t\t\tconst key = automorphism.toString();\n\t\t\t\tif (!sameRepresentations.automorphisms.has(key)) {\n\t\t\t\t\tsameRepresentations.automorphisms.set(key, automorphism);\n\t\t\t\t\tfor (const x of automorphism.mappings) {\n\t\t\t\t\t\tif (x[0] === x[1]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < suffix.length; i++) {\n\t\t\t\t\t\t\tif (suffix[i] === x[0]) {\n\t\t\t\t\t\t\t\tprunedSubtrees.add([...suffix.slice(0, i), x[1]].join('|'));\n\t\t\t\t\t\t\t} else if (suffix[i] === x[1]) {\n\t\t\t\t\t\t\t\tprunedSubtrees.add([...suffix.slice(0, i), x[0]].join('|'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Save the representation\n\t\t\tsameRepresentations.partitions.push(partition);\n\t\t};\n\t}\n\n\t/**\n\t * Calculates only the automorphisms of the graph.\n\t *\n\t * Note: if any of the graph, graph key, or node mapping are needed as well,\n\t * use the canonicalize() function.\n\t */\n\tpublic aut(): AutomorphismGroup {\n\t\tconst nodeCells = new Array(this.nodeCount).fill(1);\n\t\tthis.partitionByPropertyKeys(nodeCells);\n\t\tconst partitions: Map<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpartitions: Map<number, number>[];\n\t\t\t\tautomorphisms: Map<string, Automorphism>;\n\t\t\t}\n\t\t> = new Map();\n\t\tconst prunedSubtrees = new Set<string>();\n\t\tthis.individualizeDFS(\n\t\t\tnodeCells,\n\t\t\t[],\n\t\t\tprunedSubtrees,\n\t\t\tthis.handleRepresentationCurry(partitions, prunedSubtrees)\n\t\t);\n\t\tconst allAutomorphisms = new Map<string, Automorphism>();\n\t\t[...partitions.values()].forEach((p) =>\n\t\t\t[...p.automorphisms.entries()].forEach(([key, aut]) =>\n\t\t\t\tallAutomorphisms.set(key, aut)\n\t\t\t)\n\t\t);\n\t\treturn new AutomorphismGroup(\n\t\t\t[...allAutomorphisms.values()],\n\t\t\tthis.nodeCount\n\t\t);\n\t}\n\n\tprivate partitionByPropertyKeys(nodeCells: number[]) {\n\t\tconst propertyKeyNodeIndices = new Map<string, number[]>();\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\tconst key = this.nodeKeys.get(i)!;\n\t\t\tif (propertyKeyNodeIndices.has(key)) {\n\t\t\t\tpropertyKeyNodeIndices.get(key)!.push(i);\n\t\t\t} else {\n\t\t\t\tpropertyKeyNodeIndices.set(key, [i]);\n\t\t\t}\n\t\t}\n\t\tlet nextFreeCell = 1;\n\t\tArray.from(propertyKeyNodeIndices.keys())\n\t\t\t.sort((a, b) => a.localeCompare(b))\n\t\t\t.forEach((k) => {\n\t\t\t\tconst nodesInNextCell = propertyKeyNodeIndices.get(k)!;\n\t\t\t\tnodesInNextCell.forEach((i) => (nodeCells[i] = nextFreeCell));\n\t\t\t\tnextFreeCell += nodesInNextCell.length;\n\t\t\t});\n\t}\n\n\tprivate isCanon(nodeCells: number[]): boolean {\n\t\treturn new Set<number>(nodeCells).size === this.nodeCount;\n\t}\n\n\tprivate individualizeDFS(\n\t\tnodeCells: number[],\n\t\tsuffix: number[],\n\t\tprunedSubtrees: Set<string>,\n\t\thandleRepresentation: (nodeCells: number[], suffix: number[]) => void\n\t) {\n\t\tif (this.isCanon(nodeCells)) {\n\t\t\thandleRepresentation(nodeCells, suffix);\n\t\t\treturn;\n\t\t}\n\t\tthis.individualizationRefinement(nodeCells);\n\t\tif (this.isCanon(nodeCells)) {\n\t\t\thandleRepresentation(nodeCells, suffix);\n\t\t\treturn;\n\t\t}\n\t\tconst cellToBreak = this.getCellToBreak(nodeCells);\n\t\tfor (const n of cellToBreak[1]) {\n\t\t\tnodeCells[n] = cellToBreak[0] + 1;\n\t\t}\n\t\tfor (const nodeId of cellToBreak[1]) {\n\t\t\t// Check if subtree is pruned\n\t\t\tconst newSuffix = [...suffix, nodeId];\n\t\t\tif (prunedSubtrees.has(newSuffix.join('|'))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnodeCells[nodeId] = cellToBreak[0];\n\t\t\tthis.individualizeDFS(\n\t\t\t\t[...nodeCells],\n\t\t\t\tnewSuffix,\n\t\t\t\tprunedSubtrees,\n\t\t\t\thandleRepresentation\n\t\t\t);\n\t\t\tnodeCells[nodeId] = cellToBreak[0] + 1;\n\t\t}\n\t}\n\n\tprivate individualizationRefinement(nodeCells: number[]) {\n\t\tlet isEquitable = false;\n\t\twhile (!isEquitable) {\n\t\t\tisEquitable = true;\n\t\t\t// Build signature for each node\n\t\t\tconst signatures: string[] = nodeCells.map((_, i) => {\n\t\t\t\tconst neighborCells = this.nodeNeighbors.get(i)!.map((n) => {\n\t\t\t\t\tif (this.hasEdgeLabels) {\n\t\t\t\t\t\tconst edgeLabels = this.graph.edgeLabels!;\n\t\t\t\t\t\tif (this.isSymmetric) {\n\t\t\t\t\t\t\treturn `${nodeCells[n]};${edgeLabels[i][n]}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `${nodeCells[n]};${edgeLabels[i][n]};${edgeLabels[n][i]}`;\n\t\t\t\t\t}\n\t\t\t\t\treturn nodeCells[n].toString();\n\t\t\t\t});\n\t\t\t\treturn neighborCells.sort().join('|');\n\t\t\t});\n\t\t\t// Group by current cell and signature\n\t\t\tconst partitionMap = new Map<number, Map<string, number[]>>();\n\t\t\tsignatures.forEach((signature, nodeIndex) => {\n\t\t\t\tconst cell = nodeCells[nodeIndex];\n\t\t\t\tlet cellMap = partitionMap.get(cell);\n\t\t\t\tif (cellMap === undefined) {\n\t\t\t\t\tcellMap = new Map();\n\t\t\t\t\tpartitionMap.set(cell, cellMap);\n\t\t\t\t}\n\t\t\t\tlet nodeIndices = cellMap.get(signature);\n\t\t\t\tif (nodeIndices === undefined) {\n\t\t\t\t\tnodeIndices = [];\n\t\t\t\t\tcellMap.set(signature, nodeIndices);\n\t\t\t\t}\n\t\t\t\tnodeIndices.push(nodeIndex);\n\t\t\t});\n\t\t\t// Partition cells based on signature blocks\n\t\t\tfor (let cellId = 1; cellId <= this.nodeCount; cellId++) {\n\t\t\t\tconst value = partitionMap.get(cellId);\n\t\t\t\tif (value === undefined || value.size < 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisEquitable = false;\n\t\t\t\t// Sort block signatures descending\n\t\t\t\tconst blockKeys = [...value.keys()].sort((a, b) => b.localeCompare(a));\n\t\t\t\tlet newCellId = cellId;\n\t\t\t\tfor (const key of blockKeys) {\n\t\t\t\t\tconst nodes = value.get(key)!;\n\t\t\t\t\tnodes.forEach((n) => (nodeCells[n] = newCellId));\n\t\t\t\t\tnewCellId += nodes.length;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getCellToBreak(nodeCells: number[]): [number, number[]] {\n\t\tconst cells: number[][] = Array.from({length: nodeCells.length}, () => []);\n\t\tnodeCells.forEach((c, i) => cells[c - 1].push(i));\n\t\tfor (let i = 0; i < cells.length; i++) {\n\t\t\tif (cells[i].length > 1) {\n\t\t\t\treturn [i + 1, cells[i]];\n\t\t\t}\n\t\t}\n\t\treturn [1, cells[0]];\n\t}\n\n\tprivate buildRepresentationGraph(nodeCells: number[]): Graph {\n\t\tconst nodeMapping = nodeCells.map((c) => c - 1);\n\t\tconst graph: Graph = {\n\t\t\tadjacencyMatrix: Array.from(\n\t\t\t\t{length: this.nodeCount},\n\t\t\t\t() => new Array(this.nodeCount)\n\t\t\t),\n\t\t};\n\t\tif (this.isSymmetric) {\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\tconst mi = nodeMapping[i];\n\t\t\t\tconst row = this.graph.adjacencyMatrix[i];\n\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\n\t\t\t\t\tgraph.adjacencyMatrix[mi][nodeMapping[j]] = row[j];\n\t\t\t\t\tgraph.adjacencyMatrix[nodeMapping[j]][mi] = row[j];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\tconst mi = nodeMapping[i];\n\t\t\t\tconst row = this.graph.adjacencyMatrix[i];\n\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\t\tgraph.adjacencyMatrix[mi][nodeMapping[j]] = row[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.hasNodeLabels) {\n\t\t\tgraph.labels = new Array(this.nodeCount);\n\t\t\tnodeMapping.forEach((c, i) => (graph.labels![c] = this.graph.labels![i]));\n\t\t}\n\t\tif (this.hasNodeProperties) {\n\t\t\tgraph.nodeProperties = new Array(this.nodeCount);\n\t\t\tnodeMapping.forEach(\n\t\t\t\t(c, i) =>\n\t\t\t\t\t(graph.nodeProperties![c] = this.nodePropertiesMapper(\n\t\t\t\t\t\tthis.graph,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\tnodeMapping\n\t\t\t\t\t))\n\t\t\t);\n\t\t}\n\t\tif (this.hasEdgeLabels) {\n\t\t\tgraph.edgeLabels = Array.from(\n\t\t\t\t{length: this.nodeCount},\n\t\t\t\t() => new Array(this.nodeCount)\n\t\t\t);\n\t\t\tif (this.isSymmetric) {\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\t\tconst mi = nodeMapping[i];\n\t\t\t\t\tconst row = this.graph.edgeLabels![i];\n\t\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\n\t\t\t\t\t\tgraph.edgeLabels[mi][nodeMapping[j]] = row[j];\n\t\t\t\t\t\tgraph.edgeLabels[nodeMapping[j]][mi] = row[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\t\tconst mi = nodeMapping[i];\n\t\t\t\t\tconst row = this.graph.edgeLabels![i];\n\t\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\t\t\tgraph.edgeLabels[mi][nodeMapping[j]] = row[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\n\tprivate buildGraphStringCurry() {\n\t\tconst edgeCallback = this.hasEdgeLabels\n\t\t\t? (graph: Graph, i: number, j: number) =>\n\t\t\t\t\t`${i}-${this.edgeLabelCanonKeyMapper(graph, i, j)}-${j}`\n\t\t\t: (_: Graph, i: number, j: number) => `${i}-${j}`;\n\t\tconst nodePropertyCallback = this.hasNodeProperties\n\t\t\t? (graph: Graph, i: number): string => {\n\t\t\t\t\tconst nodePropertyCanonKey = this.nodePropertiesCanonKeyMapper(\n\t\t\t\t\t\tgraph,\n\t\t\t\t\t\ti\n\t\t\t\t\t);\n\t\t\t\t\treturn nodePropertyCanonKey.length > 0\n\t\t\t\t\t\t? `{${nodePropertyCanonKey}}`\n\t\t\t\t\t\t: '';\n\t\t\t\t}\n\t\t\t: (_graph: Graph, _i: number): string => '';\n\t\tconst nodeCallback = this.hasNodeLabels\n\t\t\t? (graph: Graph): string =>\n\t\t\t\t\t';' +\n\t\t\t\t\tgraph\n\t\t\t\t\t\t.labels!.map(\n\t\t\t\t\t\t\t(_, i) =>\n\t\t\t\t\t\t\t\tthis.nodeLabelCanonKeyMapper(graph, i) +\n\t\t\t\t\t\t\t\tnodePropertyCallback(graph, i)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.join('|')\n\t\t\t: this.hasNodeProperties\n\t\t\t\t? (graph: Graph): string =>\n\t\t\t\t\t\t';' +\n\t\t\t\t\t\tgraph\n\t\t\t\t\t\t\t.nodeProperties!.map((_, i) =>\n\t\t\t\t\t\t\t\tthis.nodePropertiesCanonKeyMapper(graph, i)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.join('|')\n\t\t\t\t: (_: Graph): string => '';\n\n\t\tif (this.isSymmetric) {\n\t\t\treturn (graph: Graph): string => {\n\t\t\t\tconst edges = [];\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\t\tconst row = graph.adjacencyMatrix[i];\n\t\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\n\t\t\t\t\t\tif (row[j] === 1) {\n\t\t\t\t\t\t\tedges.push(edgeCallback(graph, i, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn (\n\t\t\t\t\tGraphCanon.KEY_VERSION +\n\t\t\t\t\t';' +\n\t\t\t\t\tgraph.adjacencyMatrix.length +\n\t\t\t\t\t';sym;' +\n\t\t\t\t\tedges.join('|') +\n\t\t\t\t\tnodeCallback(graph)\n\t\t\t\t);\n\t\t\t};\n\t\t}\n\t\treturn (graph: Graph): string => {\n\t\t\tconst edges = [];\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\tconst row = graph.adjacencyMatrix[i];\n\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\t\tif (row[j] === 1) {\n\t\t\t\t\t\tedges.push(edgeCallback(graph, i, j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (\n\t\t\t\tGraphCanon.KEY_VERSION +\n\t\t\t\t';' +\n\t\t\t\tgraph.adjacencyMatrix.length +\n\t\t\t\t';' +\n\t\t\t\tedges.join('|') +\n\t\t\t\tnodeCallback(graph)\n\t\t\t);\n\t\t};\n\t}\n\n\tpublic buildGraphString(graph: Graph): string {\n\t\treturn this.graphStringBuilder(graph);\n\t}\n}\n","import {Graph} from '.';\r\n\r\nexport class ConnectedComponents {\r\n\tpublic static find(graph: Graph): number[][] {\r\n\t\tconst result: number[][] = [];\r\n\t\tconst visited = new Set<number>();\r\n\r\n\t\tconst dfs = (node: number, component: number[]) => {\r\n\t\t\tvisited.add(node);\r\n\t\t\tcomponent.push(node);\r\n\t\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tgraph.adjacencyMatrix[node][i] === 1 ||\r\n\t\t\t\t\tgraph.adjacencyMatrix[i][node] === 1\r\n\t\t\t\t) {\r\n\t\t\t\t\tif (!visited.has(i)) {\r\n\t\t\t\t\t\tdfs(i, component);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\tif (!visited.has(i)) {\r\n\t\t\t\tconst component: number[] = [];\r\n\t\t\t\tdfs(i, component);\r\n\t\t\t\tresult.push(component);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n","export * as matching from './matching';\r\nexport * as canon from './canon';\r\nexport * from './ConnectedComponents';\r\n\r\nexport interface Graph {\r\n\t/**\r\n\t * N x N adjacency matrix of the graph. Must be symmetric if directed is true.\r\n\t */\r\n\tadjacencyMatrix: number[][];\r\n\t/**\r\n\t * Optional node labels\r\n\t */\r\n\tlabels?: string[];\r\n\t/**\r\n\t * Optional node properties\r\n\t */\r\n\tnodeProperties?: (Map<string, any> | undefined)[];\r\n\t/**\r\n\t * Optional edge labels\r\n\t */\r\n\tedgeLabels?: string[][];\r\n}\r\n\r\nexport function symmetricGraphToDIMACS(graph: Graph): string {\r\n\tconst n = graph.adjacencyMatrix.length;\r\n\tlet edges: string[] = [];\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tfor (let j = i + 1; j < n; j++) {\r\n\t\t\tif (graph.adjacencyMatrix[i][j] !== 0) {\r\n\t\t\t\tedges.push(`e ${i + 1} ${j + 1}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn [`p edge ${n} ${edges.length}`, ...edges].join('\\n');\r\n}\r\n"],"names":["GraphMatcher","UllmannGraphMatcher","pattern","target","nodeLabelWildcards","edgeLabelWildcards","partialMapping","n","m","isLabeled","used","mapping","nodeLabelWildcardsSet","edgeLabelWildcardsSet","patternInDegrees","patternOutDegrees","targetInDegrees","targetOutDegrees","domains","pd","i","td","j","match","depth","candidate","r","b","row","_","a","results","isEdgeLabeled","Automorphism","mappings","__publicField","visited","keys","key","cycle","value","x","g","h","gx","fgx","k","v","AutomorphismGroup","generators","identity","orbit","aut","c","seen","orbits","orb","result","addIfUnvisited","queue","f","_GraphCanon","graph","nodeKeySuffixGenerator","nodePropertiesMapper","nodeLabelCanonKeyMapper","edgeLabelCanonKeyMapper","nodePropertiesCanonKeyMapper","isSymmetric","neighbors","inDegree","outDegree","isOut","isIn","nodeKey","nodeCells","partitions","prunedSubtrees","lexSmallestKey","partition","smallestRepresentation","lexSmallestMapping","lexSmallestGraph","allAutomorphisms","p","cellIds","repNodeCells","suffix","partitionKey","sameRepresentations","automorphismMap","partitionIndex","automorphism","propertyKeyNodeIndices","nextFreeCell","nodesInNextCell","handleRepresentation","cellToBreak","nodeId","newSuffix","isEquitable","signatures","edgeLabels","partitionMap","signature","nodeIndex","cell","cellMap","nodeIndices","cellId","blockKeys","newCellId","nodes","cells","nodeMapping","mi","edgeCallback","nodePropertyCallback","nodePropertyCanonKey","_graph","_i","nodeCallback","edges","_nodeMapping","sourceNodeIndex","targetNodeIndex","_nodeIndex","GraphCanon","ConnectedComponents","dfs","node","component","symmetricGraphToDIMACS"],"mappings":"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"}