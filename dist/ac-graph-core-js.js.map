{"version":3,"file":"ac-graph-core-js.js","sources":["../src/graph/matching/GraphMatcher.ts","../src/graph/matching/UllmannGraphMatcher.ts","../src/graph/canon/GraphCanon.ts","../src/graph/ConnectedComponents.ts","../src/graph/index.ts"],"sourcesContent":["import {Mapping} from '.';\r\nimport {Graph} from '..';\r\n\r\nexport abstract class GraphMatcher {\r\n\t/**\r\n\t * Subgraph isomorphism check\r\n\t * @param pattern Pattern graph adjacency matrix\r\n\t * @param target Target graph adjacency matrix\r\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation.\r\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation. Encoded\r\n\t * as \"sourceIndex + ',' + targetIndex\".\r\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\r\n\t * find solutions containing this mapping. The array needs to follow the\r\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\r\n\t * are represented by -1.\r\n\t */\r\n\tpublic abstract isSubgraphIsomorphic(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tnodeLabelWildcards: number[],\r\n\t\tedgeLabelWildcards: string[],\r\n\t\tpartialMapping: number[] | null\r\n\t): boolean;\r\n\r\n\t/**\r\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\r\n\t * including symmetries\r\n\t * @param pattern Pattern graph adjacency matrix\r\n\t * @param target Target graph adjacency matrix\r\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation.\r\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation. Encoded\r\n\t * as \"sourceIndex + ',' + targetIndex\".\r\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\r\n\t * find solutions containing this mapping. The array needs to follow the\r\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\r\n\t * are represented by -1.\r\n\t */\r\n\tpublic abstract findAllSubgraphMonomorphisms(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tnodeLabelWildcards: number[],\r\n\t\tedgeLabelWildcards: string[],\r\n\t\tpartialMapping: number[] | null\r\n\t): Mapping[];\r\n}\r\n","import {Mapping} from '.';\r\nimport {Graph} from '..';\r\nimport {GraphMatcher} from './GraphMatcher';\r\n\r\nexport class UllmannGraphMatcher extends GraphMatcher {\r\n\t/**\r\n\t * Subgraph isomorphism check\r\n\t * @param pattern Pattern graph adjacency matrix\r\n\t * @param target Target graph adjacency matrix\r\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation.\r\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation. Encoded\r\n\t * as \"sourceIndex + ',' + targetIndex\".\r\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\r\n\t * find solutions containing this mapping. The array needs to follow the\r\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\r\n\t * are represented by -1.\r\n\t */\r\n\tpublic override isSubgraphIsomorphic(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tnodeLabelWildcards: number[] = [],\r\n\t\tedgeLabelWildcards: string[] = [],\r\n\t\tpartialMapping: number[] | null = null\r\n\t): boolean {\r\n\t\t// Number of nodes in the pattern graph\r\n\t\tconst n = pattern.adjacencyMatrix.length;\r\n\t\t// Number of nodes in the target graph\r\n\t\tconst m = target.adjacencyMatrix.length;\r\n\t\t// If pattern is larger than target, no mapping is possible\r\n\t\tif (n > m) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (partialMapping === null) {\r\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\r\n\t\t}\r\n\t\tconst isLabeled = pattern.labels && target.labels;\r\n\t\t// Track which target nodes are already used in the mapping\r\n\t\tconst used = Array(m).fill(false);\r\n\t\tconst mapping = Array(n).fill(-1);\r\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\r\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\r\n\t\t// Pre-compute degrees for pattern and target nodes\r\n\t\tconst [\r\n\t\t\tpatternInDegrees,\r\n\t\t\tpatternOutDegrees,\r\n\t\t\ttargetInDegrees,\r\n\t\t\ttargetOutDegrees,\r\n\t\t] = this.getInOutDegrees(pattern, target);\r\n\t\t// Pre-compute candidate domains for pattern nodes based on degree\r\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\r\n\t\t\ttargetInDegrees\r\n\t\t\t\t.map((td, j) => {\r\n\t\t\t\t\treturn td >= pd &&\r\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\r\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\r\n\t\t\t\t\t\t(!isLabeled ||\r\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\r\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\r\n\t\t\t\t\t\t? j\r\n\t\t\t\t\t\t: -1;\r\n\t\t\t\t})\r\n\t\t\t\t.filter((j) => j !== -1)\r\n\t\t);\r\n\t\t// Recursive backtracking function to try all injective mappings\r\n\t\tconst match = (depth: number): boolean => {\r\n\t\t\tif (depth === n) {\r\n\t\t\t\treturn this.checkCompatibility(\r\n\t\t\t\t\tpattern,\r\n\t\t\t\t\ttarget,\r\n\t\t\t\t\tmapping,\r\n\t\t\t\t\tedgeLabelWildcardsSet\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tfor (const candidate of domains[depth]) {\r\n\t\t\t\tif (!used[candidate]) {\r\n\t\t\t\t\tmapping[depth] = candidate;\r\n\t\t\t\t\tused[candidate] = true;\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tthis.isFeasible(\r\n\t\t\t\t\t\t\tpattern,\r\n\t\t\t\t\t\t\ttarget,\r\n\t\t\t\t\t\t\tmapping,\r\n\t\t\t\t\t\t\tdepth,\r\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\r\n\t\t\t\t\t\t) &&\r\n\t\t\t\t\t\tmatch(depth + 1)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Backtrack\r\n\t\t\t\t\tused[candidate] = false;\r\n\t\t\t\t\tmapping[depth] = -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\treturn match(0);\r\n\t}\r\n\r\n\tprivate getInOutDegrees(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph\r\n\t): [number[], number[], number[], number[]] {\r\n\t\tconst patternInDegrees = pattern.adjacencyMatrix.map((r) =>\r\n\t\t\tr.reduce((a, b) => a + b, 0)\r\n\t\t);\r\n\t\tconst patternOutDegrees: number[] = [];\r\n\t\tconst targetInDegrees = target.adjacencyMatrix.map((r) =>\r\n\t\t\tr.reduce((a, b) => a + b, 0)\r\n\t\t);\r\n\t\tconst targetOutDegrees: number[] = [];\r\n\t\tpattern.adjacencyMatrix.forEach((row, i) => {\r\n\t\t\tpatternOutDegrees.push(\r\n\t\t\t\trow\r\n\t\t\t\t\t.map((_, j) => pattern.adjacencyMatrix[j][i])\r\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\r\n\t\t\t);\r\n\t\t});\r\n\t\ttarget.adjacencyMatrix.forEach((row, i) => {\r\n\t\t\ttargetOutDegrees.push(\r\n\t\t\t\trow\r\n\t\t\t\t\t.map((_, j) => target.adjacencyMatrix[j][i])\r\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\r\n\t\t\t);\r\n\t\t});\r\n\t\treturn [\r\n\t\t\tpatternInDegrees,\r\n\t\t\tpatternOutDegrees,\r\n\t\t\ttargetInDegrees,\r\n\t\t\ttargetOutDegrees,\r\n\t\t];\r\n\t}\r\n\r\n\t/**\r\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\r\n\t * including symmetries\r\n\t * @param pattern Pattern graph adjacency matrix\r\n\t * @param target Target graph adjacency matrix\r\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation.\r\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation. Encoded\r\n\t * as \"sourceIndex + ',' + targetIndex\".\r\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\r\n\t * find solutions containing this mapping. The array needs to follow the\r\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\r\n\t * are represented by -1.\r\n\t */\r\n\tpublic override findAllSubgraphMonomorphisms(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tnodeLabelWildcards: number[] = [],\r\n\t\tedgeLabelWildcards: string[] = [],\r\n\t\tpartialMapping: number[] | null = null\r\n\t): Mapping[] {\r\n\t\tconst n = pattern.adjacencyMatrix.length;\r\n\t\tconst m = target.adjacencyMatrix.length;\r\n\t\tconst results: Mapping[] = [];\r\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\r\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\r\n\t\tif (n > m) {\r\n\t\t\treturn results;\r\n\t\t}\r\n\t\tif (partialMapping === null) {\r\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\r\n\t\t}\r\n\t\tconst isLabeled = pattern.labels && target.labels;\r\n\t\tconst used = Array(m).fill(false);\r\n\t\tconst mapping = Array(n).fill(-1);\r\n\t\tconst [\r\n\t\t\tpatternInDegrees,\r\n\t\t\tpatternOutDegrees,\r\n\t\t\ttargetInDegrees,\r\n\t\t\ttargetOutDegrees,\r\n\t\t] = this.getInOutDegrees(pattern, target);\r\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\r\n\t\t\ttargetInDegrees\r\n\t\t\t\t.map((td, j) => {\r\n\t\t\t\t\treturn td >= pd &&\r\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\r\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\r\n\t\t\t\t\t\t(!isLabeled ||\r\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\r\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\r\n\t\t\t\t\t\t? j\r\n\t\t\t\t\t\t: -1;\r\n\t\t\t\t})\r\n\t\t\t\t.filter((j) => j !== -1)\r\n\t\t);\r\n\t\tconst match = (depth: number): void => {\r\n\t\t\tif (depth === n) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tthis.checkCompatibility(\r\n\t\t\t\t\t\tpattern,\r\n\t\t\t\t\t\ttarget,\r\n\t\t\t\t\t\tmapping,\r\n\t\t\t\t\t\tedgeLabelWildcardsSet\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\t\t\t\t\tresults.push([...mapping]);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tfor (const candidate of domains[depth]) {\r\n\t\t\t\tif (!used[candidate]) {\r\n\t\t\t\t\tmapping[depth] = candidate;\r\n\t\t\t\t\tused[candidate] = true;\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tthis.isFeasible(\r\n\t\t\t\t\t\t\tpattern,\r\n\t\t\t\t\t\t\ttarget,\r\n\t\t\t\t\t\t\tmapping,\r\n\t\t\t\t\t\t\tdepth,\r\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tmatch(depth + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tused[candidate] = false;\r\n\t\t\t\t\tmapping[depth] = -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tmatch(0);\r\n\t\treturn results;\r\n\t}\r\n\r\n\t/**\r\n\t * Feasibility check for current depth: preserve pattern edges\r\n\t * and edge labels if present\r\n\t */\r\n\tprivate isFeasible(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tmapping: Mapping,\r\n\t\tdepth: number,\r\n\t\tedgeLabelWildcardsSet: Set<string>\r\n\t): boolean {\r\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\r\n\t\t// Check that all edges in the current partial mapping are preserved\r\n\t\tfor (let i = 0; i < depth; i++) {\r\n\t\t\tif (pattern.adjacencyMatrix[depth][i]) {\r\n\t\t\t\tif (!target.adjacencyMatrix[mapping[depth]][mapping[i]]) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t// Check edge labels if present\r\n\t\t\t\tif (\r\n\t\t\t\t\tisEdgeLabeled &&\r\n\t\t\t\t\t!edgeLabelWildcardsSet.has(depth + ',' + i) &&\r\n\t\t\t\t\tpattern.edgeLabels![depth][i] !==\r\n\t\t\t\t\t\ttarget.edgeLabels![mapping[depth]][mapping[i]]\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (pattern.adjacencyMatrix[i][depth]) {\r\n\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[depth]]) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t// Check edge labels if present\r\n\t\t\t\tif (\r\n\t\t\t\t\tisEdgeLabeled &&\r\n\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + depth) &&\r\n\t\t\t\t\tpattern.edgeLabels![i][depth] !==\r\n\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[depth]]\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Verifies full structural consistency of the mapping\r\n\t */\r\n\tprivate checkCompatibility(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tmapping: Mapping,\r\n\t\tedgeLabelWildcardsSet: Set<string>\r\n\t): boolean {\r\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\r\n\t\tconst n = pattern.adjacencyMatrix.length;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tfor (let j = 0; j < n; j++) {\r\n\t\t\t\tif (pattern.adjacencyMatrix[i][j]) {\r\n\t\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[j]]) {\r\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tisEdgeLabeled &&\r\n\t\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + j) &&\r\n\t\t\t\t\t\tpattern.edgeLabels![i][j] !==\r\n\t\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[j]]\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge label\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n}\r\n","import {Automorphism, AutomorphismGroup, Graph} from '..';\r\nimport {Mapping} from '../matching';\r\n\r\nexport type NodeKeySuffixGenerator = (\r\n\tgraph: Graph,\r\n\tnodeIndex: number\r\n) => string;\r\nexport type NodePropertiesMapper = (\r\n\tgraph: Graph,\r\n\tnodeIndex: number,\r\n\tnodeMapping: number[]\r\n) => Map<string, any> | undefined;\r\nexport type NodePropertiesCanonKeyMapper = (\r\n\tgraph: Graph,\r\n\tnodeIndex: number\r\n) => string;\r\n\r\n/**\r\n * Nauty graph canonicalization using the following graph properties\r\n * for ordering and selection:\r\n * - First, node cell membership is sorted ascending by \"outDegree|inDegree|label?\"\r\n * - Second, direct neighborhood cell memberships and optional edge labels are sorted\r\n *   ascending, concatenated, and used to further split cells.\r\n *   \"neighborCell_1;outEdgeLabel_1?;inEdgeLabel_1?|neighborCell_2;outEdgeLabel_2?;inEdgeLabel_2?|...\"\r\n *   New cell IDs of the split are assigned by descending key order.\r\n * - Target cell selection in the search tree is performed by selecting the leftmost (smallest) cell ID\r\n *   with at least two members.\r\n */\r\nexport class GraphCanon {\r\n\tpublic static readonly DefaultNodeKeySuffixGenerator: NodeKeySuffixGenerator =\r\n\t\t(graph: Graph, nodeIndex: number) => {\r\n\t\t\treturn graph.labels ? graph.labels[nodeIndex] : '';\r\n\t\t};\r\n\tpublic static readonly DefaultNodePropertiesMapper: NodePropertiesMapper = (\r\n\t\tgraph: Graph,\r\n\t\tnodeIndex: number,\r\n\t\t_nodeMapping: number[]\r\n\t) => {\r\n\t\treturn graph.nodeProperties && graph.nodeProperties[nodeIndex]\r\n\t\t\t? new Map(graph.nodeProperties[nodeIndex])\r\n\t\t\t: undefined;\r\n\t};\r\n\tpublic static readonly DefaultNodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper =\r\n\t\t(_graph: Graph, _nodeIndex: number) => {\r\n\t\t\treturn '';\r\n\t\t};\r\n\r\n\tprivate readonly nodeCount: number;\r\n\tprivate readonly hasNodeLabels: boolean;\r\n\tprivate readonly hasNodeProperties: boolean;\r\n\tprivate readonly hasEdgeLabels: boolean;\r\n\tprivate readonly isSymmetric: boolean;\r\n\tprivate readonly graph: Graph;\r\n\tprivate readonly nodeNeighbors = new Map<number, number[]>();\r\n\tprivate readonly nodeKeys = new Map<number, string>();\r\n\tprivate readonly nodePropertiesMapper: NodePropertiesMapper;\r\n\tprivate readonly nodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper;\r\n\tprivate readonly graphStringBuilder: (graph: Graph) => string;\r\n\r\n\tpublic constructor(\r\n\t\tgraph: Graph,\r\n\t\tnodeKeySuffixGenerator: NodeKeySuffixGenerator = GraphCanon.DefaultNodeKeySuffixGenerator,\r\n\t\tnodePropertiesMapper: NodePropertiesMapper = GraphCanon.DefaultNodePropertiesMapper,\r\n\t\tnodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper = GraphCanon.DefaultNodePropertiesCanonKeyMapper\r\n\t) {\r\n\t\tthis.graph = graph;\r\n\t\tthis.nodeCount = graph.adjacencyMatrix.length;\r\n\t\tthis.hasNodeLabels = graph.labels !== undefined;\r\n\t\tthis.hasNodeProperties = graph.nodeProperties !== undefined;\r\n\t\tthis.hasEdgeLabels = graph.edgeLabels !== undefined;\r\n\t\tthis.nodePropertiesMapper = nodePropertiesMapper;\r\n\t\tthis.nodePropertiesCanonKeyMapper = nodePropertiesCanonKeyMapper;\r\n\t\tlet isSymmetric = true;\r\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\tconst neighbors = new Set<number>();\r\n\t\t\tlet inDegree = 0;\r\n\t\t\tlet outDegree = 0;\r\n\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\tconst isOut = graph.adjacencyMatrix[i][j];\r\n\t\t\t\tconst isIn = graph.adjacencyMatrix[j][i];\r\n\t\t\t\tif (isOut === 1) {\r\n\t\t\t\t\toutDegree++;\r\n\t\t\t\t\tneighbors.add(j);\r\n\t\t\t\t}\r\n\t\t\t\tif (isIn === 1) {\r\n\t\t\t\t\tinDegree++;\r\n\t\t\t\t\tneighbors.add(j);\r\n\t\t\t\t}\r\n\t\t\t\tif (isOut !== isIn) {\r\n\t\t\t\t\tisSymmetric = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.nodeNeighbors.set(i, [...neighbors]);\r\n\t\t\tconst nodeKey =\r\n\t\t\t\toutDegree + '|' + inDegree + '|' + nodeKeySuffixGenerator(graph, i);\r\n\t\t\tthis.nodeKeys.set(i, nodeKey);\r\n\t\t}\r\n\t\tthis.isSymmetric = isSymmetric;\r\n\t\t// Finally build the curried graph key function\r\n\t\tthis.graphStringBuilder = this.buildGraphStringCurry();\r\n\t}\r\n\r\n\t/**\r\n\t * Canonicalize the graph\r\n\t * @returns\r\n\t * 1. canonical graph representation\r\n\t * 2. graph key\r\n\t * 3. node mapping from the original to the canonical graph\r\n\t * 4. automorphisms\r\n\t */\r\n\tpublic canonicalize(): [Graph, string, Mapping, AutomorphismGroup] {\r\n\t\tconst nodeCells = new Array(this.nodeCount).fill(1);\r\n\t\tthis.partitionByPropertyKeys(nodeCells);\r\n\t\tconst partitions: Map<\r\n\t\t\tstring,\r\n\t\t\t{\r\n\t\t\t\tpartitions: Map<number, number>[];\r\n\t\t\t\tautomorphisms: Map<string, Automorphism>;\r\n\t\t\t}\r\n\t\t> = new Map();\r\n\t\tconst prunedSubtrees = new Set<string>();\r\n\t\tthis.individualizeDFS(\r\n\t\t\tnodeCells,\r\n\t\t\t[],\r\n\t\t\tprunedSubtrees,\r\n\t\t\tthis.handleRepresentationCurry(partitions, prunedSubtrees)\r\n\t\t);\r\n\t\tconst lexSmallestKey = [...partitions.keys()].sort((a, b) =>\r\n\t\t\ta.localeCompare(b)\r\n\t\t)[0];\r\n\t\tconst partition = partitions.get(lexSmallestKey)!;\r\n\t\tconst smallestRepresentation = new Array(this.nodeCount);\r\n\t\tconst lexSmallestMapping = new Array(smallestRepresentation.length);\r\n\t\t[...partition.partitions[0].entries()].forEach(([c, i]) => {\r\n\t\t\tsmallestRepresentation[i] = c;\r\n\t\t\tlexSmallestMapping[c - 1] = i;\r\n\t\t});\r\n\t\tconst lexSmallestGraph = this.buildRepresentationGraph(\r\n\t\t\tsmallestRepresentation\r\n\t\t);\r\n\t\tconst allAutomorphisms = new Map<string, Automorphism>();\r\n\t\t[...partitions.values()].forEach((p) =>\r\n\t\t\t[...p.automorphisms.entries()].forEach(([key, aut]) =>\r\n\t\t\t\tallAutomorphisms.set(key, aut)\r\n\t\t\t)\r\n\t\t);\r\n\t\treturn [\r\n\t\t\tlexSmallestGraph,\r\n\t\t\tthis.buildGraphString(lexSmallestGraph),\r\n\t\t\tlexSmallestMapping,\r\n\t\t\tnew AutomorphismGroup([...allAutomorphisms.values()]),\r\n\t\t];\r\n\t}\r\n\r\n\tprivate handleRepresentationCurry(\r\n\t\tpartitions: Map<\r\n\t\t\tstring,\r\n\t\t\t{\r\n\t\t\t\tpartitions: Map<number, number>[];\r\n\t\t\t\tautomorphisms: Map<string, Automorphism>;\r\n\t\t\t}\r\n\t\t>,\r\n\t\tprunedSubtrees: Set<string>\r\n\t): (nodeCells: number[], suffix: number[]) => void {\r\n\t\tconst cellIds = Array.from({length: this.nodeCount}, (_, i) => i + 1);\r\n\t\treturn (repNodeCells, suffix) => {\r\n\t\t\t// Build the partition key for comparison with other partitions\r\n\t\t\tconst partition = new Map<number, number>();\r\n\t\t\trepNodeCells.forEach((c, i) => partition.set(c, i));\r\n\t\t\tconst partitionKey = cellIds\r\n\t\t\t\t.map((c) =>\r\n\t\t\t\t\tthis.nodeNeighbors\r\n\t\t\t\t\t\t.get(partition.get(c)!)!\r\n\t\t\t\t\t\t.map((n) => repNodeCells[n])\r\n\t\t\t\t\t\t.sort()\r\n\t\t\t\t\t\t.join(';')\r\n\t\t\t\t)\r\n\t\t\t\t.join('|');\r\n\t\t\tlet sameRepresentations = partitions.get(partitionKey);\r\n\t\t\tif (sameRepresentations === undefined) {\r\n\t\t\t\tsameRepresentations = {\r\n\t\t\t\t\tpartitions: [],\r\n\t\t\t\t\tautomorphisms: new Map(),\r\n\t\t\t\t};\r\n\t\t\t\tpartitions.set(partitionKey, sameRepresentations);\r\n\t\t\t}\r\n\r\n\t\t\tfor (const partition of sameRepresentations.partitions) {\r\n\t\t\t\tconst automorphismMap = new Map<string, [number, number]>();\r\n\t\t\t\tfor (let i = 0; i < repNodeCells.length; i++) {\r\n\t\t\t\t\tconst partitionIndex = partition.get(repNodeCells[i])!;\r\n\t\t\t\t\tif (partitionIndex !== i) {\r\n\t\t\t\t\t\tconst match: [number, number] = [\r\n\t\t\t\t\t\t\tpartitionIndex < i ? partitionIndex : i,\r\n\t\t\t\t\t\t\ti < partitionIndex ? partitionIndex : i,\r\n\t\t\t\t\t\t];\r\n\t\t\t\t\t\tautomorphismMap.set(match[0] + '|' + match[1], match);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tconst automorphism = new Automorphism([...automorphismMap.values()]);\r\n\t\t\t\tsameRepresentations.automorphisms.set(\r\n\t\t\t\t\tautomorphism.toString(),\r\n\t\t\t\t\tautomorphism\r\n\t\t\t\t);\r\n\t\t\t\tfor (const x of automorphism.mappings) {\r\n\t\t\t\t\tfor (let i = 0; i < suffix.length; i++) {\r\n\t\t\t\t\t\tif (x.includes(suffix[i])) {\r\n\t\t\t\t\t\t\tx.filter((y) => y != suffix[i]).forEach((y) =>\r\n\t\t\t\t\t\t\t\tprunedSubtrees.add([...suffix.slice(0, i), y].join('|'))\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Save the representation\r\n\t\t\tsameRepresentations.partitions.push(partition);\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates only the automorphisms of the graph.\r\n\t *\r\n\t * Note: if any of the graph, graph key, or node mapping are needed as well,\r\n\t * use the canonicalize() function.\r\n\t */\r\n\tpublic aut(): AutomorphismGroup {\r\n\t\tconst nodeCells = new Array(this.nodeCount).fill(1);\r\n\t\tthis.partitionByPropertyKeys(nodeCells);\r\n\t\tconst partitions: Map<\r\n\t\t\tstring,\r\n\t\t\t{\r\n\t\t\t\tpartitions: Map<number, number>[];\r\n\t\t\t\tautomorphisms: Map<string, Automorphism>;\r\n\t\t\t}\r\n\t\t> = new Map();\r\n\t\tconst prunedSubtrees = new Set<string>();\r\n\t\tthis.individualizeDFS(\r\n\t\t\tnodeCells,\r\n\t\t\t[],\r\n\t\t\tprunedSubtrees,\r\n\t\t\tthis.handleRepresentationCurry(partitions, prunedSubtrees)\r\n\t\t);\r\n\t\tconst allAutomorphisms = new Map<string, Automorphism>();\r\n\t\t[...partitions.values()].forEach((p) =>\r\n\t\t\t[...p.automorphisms.entries()].forEach(([key, aut]) =>\r\n\t\t\t\tallAutomorphisms.set(key, aut)\r\n\t\t\t)\r\n\t\t);\r\n\t\treturn new AutomorphismGroup([...allAutomorphisms.values()]);\r\n\t}\r\n\r\n\tprivate partitionByPropertyKeys(nodeCells: number[]) {\r\n\t\tconst propertyKeyNodeIndices = new Map<string, number[]>();\r\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\tconst key = this.nodeKeys.get(i)!;\r\n\t\t\tif (propertyKeyNodeIndices.has(key)) {\r\n\t\t\t\tpropertyKeyNodeIndices.get(key)!.push(i);\r\n\t\t\t} else {\r\n\t\t\t\tpropertyKeyNodeIndices.set(key, [i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet nextFreeCell = 1;\r\n\t\tArray.from(propertyKeyNodeIndices.keys())\r\n\t\t\t.sort((a, b) => a.localeCompare(b))\r\n\t\t\t.forEach((k) => {\r\n\t\t\t\tconst nodesInNextCell = propertyKeyNodeIndices.get(k)!;\r\n\t\t\t\tnodesInNextCell.forEach((i) => (nodeCells[i] = nextFreeCell));\r\n\t\t\t\tnextFreeCell += nodesInNextCell.length;\r\n\t\t\t});\r\n\t}\r\n\r\n\tprivate isCanon(nodeCells: number[]): boolean {\r\n\t\treturn new Set<number>(nodeCells).size === this.nodeCount;\r\n\t}\r\n\r\n\tprivate individualizeDFS(\r\n\t\tnodeCells: number[],\r\n\t\tsuffix: number[],\r\n\t\tprunedSubtrees: Set<string>,\r\n\t\thandleRepresentation: (nodeCells: number[], suffix: number[]) => void\r\n\t) {\r\n\t\tif (this.isCanon(nodeCells)) {\r\n\t\t\thandleRepresentation(nodeCells, suffix);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.individualizationRefinement(nodeCells);\r\n\t\tif (this.isCanon(nodeCells)) {\r\n\t\t\thandleRepresentation(nodeCells, suffix);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst cellToBreak = this.getCellToBreak(nodeCells);\r\n\t\tfor (const n of cellToBreak[1]) {\r\n\t\t\tnodeCells[n] = cellToBreak[0] + 1;\r\n\t\t}\r\n\t\tfor (const nodeId of cellToBreak[1]) {\r\n\t\t\t// Check if subtree is pruned\r\n\t\t\tconst newSuffix = [...suffix, nodeId];\r\n\t\t\tif (prunedSubtrees.has(newSuffix.join('|'))) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tnodeCells[nodeId] = cellToBreak[0];\r\n\t\t\tthis.individualizeDFS(\r\n\t\t\t\t[...nodeCells],\r\n\t\t\t\tnewSuffix,\r\n\t\t\t\tprunedSubtrees,\r\n\t\t\t\thandleRepresentation\r\n\t\t\t);\r\n\t\t\tnodeCells[nodeId] = cellToBreak[0] + 1;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate individualizationRefinement(nodeCells: number[]) {\r\n\t\tlet isEquitable = false;\r\n\t\twhile (!isEquitable) {\r\n\t\t\tisEquitable = true;\r\n\t\t\t// Build signature for each node\r\n\t\t\tconst signatures: string[] = nodeCells.map((_, i) => {\r\n\t\t\t\tconst neighborCells = this.nodeNeighbors.get(i)!.map((n) => {\r\n\t\t\t\t\tif (this.hasEdgeLabels) {\r\n\t\t\t\t\t\tconst edgeLabels = this.graph.edgeLabels!;\r\n\t\t\t\t\t\tif (this.isSymmetric) {\r\n\t\t\t\t\t\t\treturn `${nodeCells[n]};${edgeLabels[i][n]}`;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn `${nodeCells[n]};${edgeLabels[i][n]};${edgeLabels[n][i]}`;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn nodeCells[n].toString();\r\n\t\t\t\t});\r\n\t\t\t\treturn neighborCells.sort().join('|');\r\n\t\t\t});\r\n\t\t\t// Group by current cell and signature\r\n\t\t\tconst partitionMap = new Map<number, Map<string, number[]>>();\r\n\t\t\tsignatures.forEach((signature, nodeIndex) => {\r\n\t\t\t\tconst cell = nodeCells[nodeIndex];\r\n\t\t\t\tlet cellMap = partitionMap.get(cell);\r\n\t\t\t\tif (cellMap === undefined) {\r\n\t\t\t\t\tcellMap = new Map();\r\n\t\t\t\t\tpartitionMap.set(cell, cellMap);\r\n\t\t\t\t}\r\n\t\t\t\tlet nodeIndices = cellMap.get(signature);\r\n\t\t\t\tif (nodeIndices === undefined) {\r\n\t\t\t\t\tnodeIndices = [];\r\n\t\t\t\t\tcellMap.set(signature, nodeIndices);\r\n\t\t\t\t}\r\n\t\t\t\tnodeIndices.push(nodeIndex);\r\n\t\t\t});\r\n\t\t\t// Partition cells based on signature blocks\r\n\t\t\tfor (let cellId = 1; cellId <= this.nodeCount; cellId++) {\r\n\t\t\t\tconst value = partitionMap.get(cellId);\r\n\t\t\t\tif (value === undefined || value.size < 2) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tisEquitable = false;\r\n\t\t\t\t// Sort block signatures descending\r\n\t\t\t\tconst blockKeys = [...value.keys()].sort((a, b) => b.localeCompare(a));\r\n\t\t\t\tlet newCellId = cellId;\r\n\t\t\t\tfor (const key of blockKeys) {\r\n\t\t\t\t\tconst nodes = value.get(key)!;\r\n\t\t\t\t\tnodes.forEach((n) => (nodeCells[n] = newCellId));\r\n\t\t\t\t\tnewCellId += nodes.length;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate getCellToBreak(nodeCells: number[]): [number, number[]] {\r\n\t\tconst cells: number[][] = Array.from({length: nodeCells.length}, () => []);\r\n\t\tnodeCells.forEach((c, i) => cells[c - 1].push(i));\r\n\t\tfor (let i = 0; i < cells.length; i++) {\r\n\t\t\tif (cells[i].length > 1) {\r\n\t\t\t\treturn [i + 1, cells[i]];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn [1, cells[0]];\r\n\t}\r\n\r\n\tprivate buildRepresentationGraph(nodeCells: number[]): Graph {\r\n\t\tconst nodeMapping = nodeCells.map((c) => c - 1);\r\n\t\tconst graph: Graph = {\r\n\t\t\tadjacencyMatrix: Array.from(\r\n\t\t\t\t{length: this.nodeCount},\r\n\t\t\t\t() => new Array(this.nodeCount)\r\n\t\t\t),\r\n\t\t};\r\n\t\tif (this.isSymmetric) {\r\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\tconst mi = nodeMapping[i];\r\n\t\t\t\tconst row = this.graph.adjacencyMatrix[i];\r\n\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\r\n\t\t\t\t\tgraph.adjacencyMatrix[mi][nodeMapping[j]] = row[j];\r\n\t\t\t\t\tgraph.adjacencyMatrix[nodeMapping[j]][mi] = row[j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\tconst mi = nodeMapping[i];\r\n\t\t\t\tconst row = this.graph.adjacencyMatrix[i];\r\n\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\t\tgraph.adjacencyMatrix[mi][nodeMapping[j]] = row[j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this.hasNodeLabels) {\r\n\t\t\tgraph.labels = new Array(this.nodeCount);\r\n\t\t\tnodeMapping.forEach((c, i) => (graph.labels![c] = this.graph.labels![i]));\r\n\t\t}\r\n\t\tif (this.hasNodeProperties) {\r\n\t\t\tgraph.nodeProperties = new Array(this.nodeCount);\r\n\t\t\tnodeMapping.forEach(\r\n\t\t\t\t(c, i) =>\r\n\t\t\t\t\t(graph.nodeProperties![c] = this.nodePropertiesMapper(\r\n\t\t\t\t\t\tthis.graph,\r\n\t\t\t\t\t\ti,\r\n\t\t\t\t\t\tnodeMapping\r\n\t\t\t\t\t))\r\n\t\t\t);\r\n\t\t}\r\n\t\tif (this.hasEdgeLabels) {\r\n\t\t\tgraph.edgeLabels = Array.from(\r\n\t\t\t\t{length: this.nodeCount},\r\n\t\t\t\t() => new Array(this.nodeCount)\r\n\t\t\t);\r\n\t\t\tif (this.isSymmetric) {\r\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\t\tconst mi = nodeMapping[i];\r\n\t\t\t\t\tconst row = this.graph.edgeLabels![i];\r\n\t\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\r\n\t\t\t\t\t\tgraph.edgeLabels[mi][nodeMapping[j]] = row[j];\r\n\t\t\t\t\t\tgraph.edgeLabels[nodeMapping[j]][mi] = row[j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\t\tconst mi = nodeMapping[i];\r\n\t\t\t\t\tconst row = this.graph.edgeLabels![i];\r\n\t\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\t\t\tgraph.edgeLabels[mi][nodeMapping[j]] = row[j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn graph;\r\n\t}\r\n\r\n\tprivate buildGraphStringCurry() {\r\n\t\tconst edgeCallback = this.hasEdgeLabels\r\n\t\t\t? (graph: Graph, i: number, j: number) =>\r\n\t\t\t\t\t`${i}-${graph.edgeLabels![i][j]}-${j}`\r\n\t\t\t: (_: Graph, i: number, j: number) => `${i}-${j}`;\r\n\t\tconst nodePropertyCallback = this.hasNodeProperties\r\n\t\t\t? (graph: Graph, i: number): string => {\r\n\t\t\t\t\tconst nodePropertyCanonKey = this.nodePropertiesCanonKeyMapper(\r\n\t\t\t\t\t\tgraph,\r\n\t\t\t\t\t\ti\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn nodePropertyCanonKey.length > 0\r\n\t\t\t\t\t\t? `{${nodePropertyCanonKey}}`\r\n\t\t\t\t\t\t: '';\r\n\t\t\t\t}\r\n\t\t\t: (_graph: Graph, _i: number): string => '';\r\n\t\tconst nodeCallback = this.hasNodeLabels\r\n\t\t\t? (graph: Graph): string =>\r\n\t\t\t\t\t';' +\r\n\t\t\t\t\tgraph\r\n\t\t\t\t\t\t.labels!.map((l, i) => l + nodePropertyCallback(graph, i))\r\n\t\t\t\t\t\t.join('|')\r\n\t\t\t: this.hasNodeProperties\r\n\t\t\t\t? (graph: Graph): string =>\r\n\t\t\t\t\t\t';' +\r\n\t\t\t\t\t\tgraph\r\n\t\t\t\t\t\t\t.nodeProperties!.map((_, i) =>\r\n\t\t\t\t\t\t\t\tthis.nodePropertiesCanonKeyMapper(graph, i)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t.join('|')\r\n\t\t\t\t: (_: Graph): string => '';\r\n\r\n\t\tif (this.isSymmetric) {\r\n\t\t\treturn (graph: Graph): string => {\r\n\t\t\t\tconst edges = [];\r\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\t\tconst row = graph.adjacencyMatrix[i];\r\n\t\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\r\n\t\t\t\t\t\tif (row[j] === 1) {\r\n\t\t\t\t\t\t\tedges.push(edgeCallback(graph, i, j));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn edges.join('|') + nodeCallback(graph);\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn (graph: Graph): string => {\r\n\t\t\tconst edges = [];\r\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\tconst row = graph.adjacencyMatrix[i];\r\n\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\t\tif (row[j] === 1) {\r\n\t\t\t\t\t\tedges.push(edgeCallback(graph, i, j));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn edges.join('|') + nodeCallback(graph);\r\n\t\t};\r\n\t}\r\n\r\n\tpublic buildGraphString(graph: Graph): string {\r\n\t\treturn this.graphStringBuilder(graph);\r\n\t}\r\n}\r\n","import {Graph} from '.';\r\n\r\nexport class ConnectedComponents {\r\n\tpublic static find(graph: Graph): number[][] {\r\n\t\tconst result: number[][] = [];\r\n\t\tconst visited = new Set<number>();\r\n\r\n\t\tconst dfs = (node: number, component: number[]) => {\r\n\t\t\tvisited.add(node);\r\n\t\t\tcomponent.push(node);\r\n\t\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tgraph.adjacencyMatrix[node][i] === 1 ||\r\n\t\t\t\t\tgraph.adjacencyMatrix[i][node] === 1\r\n\t\t\t\t) {\r\n\t\t\t\t\tif (!visited.has(i)) {\r\n\t\t\t\t\t\tdfs(i, component);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\tif (!visited.has(i)) {\r\n\t\t\t\tconst component: number[] = [];\r\n\t\t\t\tdfs(i, component);\r\n\t\t\t\tresult.push(component);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n","export * as matching from './matching';\r\nexport * as canon from './canon';\r\nexport * from './ConnectedComponents';\r\n\r\nexport interface Graph {\r\n\t/**\r\n\t * N x N adjacency matrix of the graph. Must be symmetric if directed is true.\r\n\t */\r\n\tadjacencyMatrix: number[][];\r\n\t/**\r\n\t * Optional node labels\r\n\t */\r\n\tlabels?: string[];\r\n\t/**\r\n\t * Optional node properties\r\n\t */\r\n\tnodeProperties?: (Map<string, any> | undefined)[];\r\n\t/**\r\n\t * Optional edge labels\r\n\t */\r\n\tedgeLabels?: string[][];\r\n}\r\n\r\nexport class Automorphism {\r\n\tpublic static readonly Identity = new Automorphism([]);\r\n\r\n\tpublic readonly mappings: [number, number][];\r\n\r\n\tconstructor(mappings: [number, number][]) {\r\n\t\tthis.mappings = mappings;\r\n\t}\r\n\r\n\tpublic apply(g: number): number {\r\n\t\tfor (const mapping of this.mappings) {\r\n\t\t\tif (mapping[0] === g) {\r\n\t\t\t\treturn mapping[1];\r\n\t\t\t}\r\n\t\t\tif (mapping[1] === g) {\r\n\t\t\t\treturn mapping[0];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn g;\r\n\t}\r\n\r\n\tpublic toString(): string {\r\n\t\treturn this.mappings.map((m) => `(${m[0]} ${m[1]})`).join('');\r\n\t}\r\n}\r\n\r\nexport class AutomorphismGroup {\r\n\tpublic readonly generators: Automorphism[];\r\n\r\n\tconstructor(generators: Automorphism[]) {\r\n\t\tthis.generators = [Automorphism.Identity, ...generators];\r\n\t}\r\n\r\n\tpublic orbitOf(g: number): number[] {\r\n\t\tconst orbit = new Set<number>();\r\n\t\torbit.add(g);\r\n\t\tfor (const aut of this.generators) {\r\n\t\t\torbit.add(aut.apply(g));\r\n\t\t}\r\n\t\treturn Array.from(orbit).sort();\r\n\t}\r\n\r\n\tpublic stabilizerOf(g: number): Automorphism[] {\r\n\t\treturn this.generators.filter((aut) => aut.apply(g) === g);\r\n\t}\r\n\r\n\tpublic stabilizerSizeOf(g: number): number {\r\n\t\treturn this.generators.reduce(\r\n\t\t\t(c, aut) => (c += aut.apply(g) === g ? 1 : 0),\r\n\t\t\t0\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Orbit size of g via Orbitâ€“Stabilizer Theorem.\r\n\t */\r\n\tpublic orbitSizeOf(g: number): number {\r\n\t\treturn this.generators.length / this.stabilizerSizeOf(g);\r\n\t}\r\n\r\n\tpublic orbits(G: number[]): number[][] {\r\n\t\tconst seen = new Set<number>();\r\n\t\tconst orbits: number[][] = [];\r\n\t\tfor (const g of G) {\r\n\t\t\tif (!seen.has(g)) {\r\n\t\t\t\tconst orb = this.orbitOf(g);\r\n\t\t\t\torb.forEach((x) => seen.add(x));\r\n\t\t\t\torbits.push(orb);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn orbits;\r\n\t}\r\n\r\n\tpublic toString(): string {\r\n\t\treturn '[' + this.generators.map((g) => g.toString()).join(', ') + ']';\r\n\t}\r\n}\r\n\r\nexport function symmetricGraphToDIMACS(graph: Graph): string {\r\n\tconst n = graph.adjacencyMatrix.length;\r\n\tlet edges: string[] = [];\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tfor (let j = i + 1; j < n; j++) {\r\n\t\t\tif (graph.adjacencyMatrix[i][j] !== 0) {\r\n\t\t\t\tedges.push(`e ${i + 1} ${j + 1}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn [`p edge ${n} ${edges.length}`, ...edges].join('\\n');\r\n}\r\n"],"names":["GraphMatcher","UllmannGraphMatcher","pattern","target","nodeLabelWildcards","edgeLabelWildcards","partialMapping","n","m","isLabeled","used","mapping","nodeLabelWildcardsSet","edgeLabelWildcardsSet","patternInDegrees","patternOutDegrees","targetInDegrees","targetOutDegrees","domains","pd","i","td","j","match","depth","candidate","r","b","row","_","a","results","isEdgeLabeled","_GraphCanon","graph","nodeKeySuffixGenerator","nodePropertiesMapper","nodePropertiesCanonKeyMapper","__publicField","isSymmetric","neighbors","inDegree","outDegree","isOut","isIn","nodeKey","nodeCells","partitions","prunedSubtrees","lexSmallestKey","partition","smallestRepresentation","lexSmallestMapping","c","lexSmallestGraph","allAutomorphisms","p","key","aut","AutomorphismGroup","cellIds","repNodeCells","suffix","partitionKey","sameRepresentations","automorphismMap","partitionIndex","automorphism","Automorphism","x","y","propertyKeyNodeIndices","nextFreeCell","k","nodesInNextCell","handleRepresentation","cellToBreak","nodeId","newSuffix","isEquitable","signatures","edgeLabels","partitionMap","signature","nodeIndex","cell","cellMap","nodeIndices","cellId","value","blockKeys","newCellId","nodes","cells","nodeMapping","mi","edgeCallback","nodePropertyCallback","nodePropertyCanonKey","_graph","_i","nodeCallback","l","edges","_nodeMapping","_nodeIndex","GraphCanon","ConnectedComponents","result","visited","dfs","node","component","_Automorphism","mappings","g","generators","orbit","G","seen","orbits","orb","symmetricGraphToDIMACS"],"mappings":";;;AAGO,MAAeA,EAAa;AA6CnC;AC5CO,MAAMC,UAA4BD,EAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAerC,qBACfE,GACAC,GACAC,IAA+B,IAC/BC,IAA+B,CAAA,GAC/BC,IAAkC,MACxB;AAEJ,UAAAC,IAAIL,EAAQ,gBAAgB,QAE5BM,IAAIL,EAAO,gBAAgB;AAEjC,QAAII,IAAIC;AACA,aAAA;AAER,IAAIF,MAAmB,SACtBA,IAAiB,IAAI,MAAcC,CAAC,EAAE,KAAK,EAAE;AAExC,UAAAE,IAAYP,EAAQ,UAAUC,EAAO,QAErCO,IAAO,MAAMF,CAAC,EAAE,KAAK,EAAK,GAC1BG,IAAU,MAAMJ,CAAC,EAAE,KAAK,EAAE,GAC1BK,IAAwB,IAAI,IAAIR,CAAkB,GAClDS,IAAwB,IAAI,IAAIR,CAAkB,GAElD;AAAA,MACLS;AAAA,MACAC;AAAA,MACAC;AAAA,MACAC;AAAA,IACG,IAAA,KAAK,gBAAgBf,GAASC,CAAM,GAElCe,IAAsBJ,EAAiB;AAAA,MAAI,CAACK,GAAIC,MACrDJ,EACE,IAAI,CAACK,GAAIC,MACFD,KAAMF,KACZF,EAAiBK,CAAC,KAAKP,EAAkBK,CAAC,MACzCd,EAAec,CAAC,MAAM,MAAMd,EAAec,CAAC,MAAME,OAClD,CAACb,KACDG,EAAsB,IAAIQ,CAAC,KAC3BlB,EAAQ,OAAQkB,CAAC,MAAMjB,EAAO,OAAQmB,CAAC,KACtCA,IACA,EACH,EACA,OAAO,CAACA,MAAMA,MAAM,EAAE;AAAA,IACzB,GAEMC,IAAQ,CAACC,MAA2B;AACzC,UAAIA,MAAUjB;AACb,eAAO,KAAK;AAAA,UACXL;AAAA,UACAC;AAAA,UACAQ;AAAA,UACAE;AAAA,QACD;AAEU,iBAAAY,KAAaP,EAAQM,CAAK;AAChC,YAAA,CAACd,EAAKe,CAAS,GAAG;AAGrB,cAFAd,EAAQa,CAAK,IAAIC,GACjBf,EAAKe,CAAS,IAAI,IAEjB,KAAK;AAAA,YACJvB;AAAA,YACAC;AAAA,YACAQ;AAAA,YACAa;AAAA,YACAX;AAAA,UAAA,KAEDU,EAAMC,IAAQ,CAAC;AAER,mBAAA;AAGR,UAAAd,EAAKe,CAAS,IAAI,IAClBd,EAAQa,CAAK,IAAI;AAAA,QAAA;AAGZ,aAAA;AAAA,IACR;AACA,WAAOD,EAAM,CAAC;AAAA,EAAA;AAAA,EAGP,gBACPrB,GACAC,GAC2C;AACrC,UAAAW,IAAmBZ,EAAQ,gBAAgB;AAAA,MAAI,CAACwB,MACrDA,EAAE,OAAO,CAAC,GAAGC,MAAM,IAAIA,GAAG,CAAC;AAAA,IAC5B,GACMZ,IAA8B,CAAC,GAC/BC,IAAkBb,EAAO,gBAAgB;AAAA,MAAI,CAACuB,MACnDA,EAAE,OAAO,CAAC,GAAGC,MAAM,IAAIA,GAAG,CAAC;AAAA,IAC5B,GACMV,IAA6B,CAAC;AACpC,WAAAf,EAAQ,gBAAgB,QAAQ,CAAC0B,GAAKR,MAAM;AACzB,MAAAL,EAAA;AAAA,QACjBa,EACE,IAAI,CAACC,GAAGP,MAAMpB,EAAQ,gBAAgBoB,CAAC,EAAEF,CAAC,CAAC,EAC3C,OAAO,CAACU,GAAGH,MAAMG,IAAIH,GAAG,CAAC;AAAA,MAC5B;AAAA,IAAA,CACA,GACDxB,EAAO,gBAAgB,QAAQ,CAACyB,GAAKR,MAAM;AACzB,MAAAH,EAAA;AAAA,QAChBW,EACE,IAAI,CAACC,GAAGP,MAAMnB,EAAO,gBAAgBmB,CAAC,EAAEF,CAAC,CAAC,EAC1C,OAAO,CAACU,GAAGH,MAAMG,IAAIH,GAAG,CAAC;AAAA,MAC5B;AAAA,IAAA,CACA,GACM;AAAA,MACNb;AAAA,MACAC;AAAA,MACAC;AAAA,MACAC;AAAA,IACD;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBe,6BACff,GACAC,GACAC,IAA+B,IAC/BC,IAA+B,CAAA,GAC/BC,IAAkC,MACtB;AACN,UAAAC,IAAIL,EAAQ,gBAAgB,QAC5BM,IAAIL,EAAO,gBAAgB,QAC3B4B,IAAqB,CAAC,GACtBnB,IAAwB,IAAI,IAAIR,CAAkB,GAClDS,IAAwB,IAAI,IAAIR,CAAkB;AACxD,QAAIE,IAAIC;AACA,aAAAuB;AAER,IAAIzB,MAAmB,SACtBA,IAAiB,IAAI,MAAcC,CAAC,EAAE,KAAK,EAAE;AAExC,UAAAE,IAAYP,EAAQ,UAAUC,EAAO,QACrCO,IAAO,MAAMF,CAAC,EAAE,KAAK,EAAK,GAC1BG,IAAU,MAAMJ,CAAC,EAAE,KAAK,EAAE,GAC1B;AAAA,MACLO;AAAA,MACAC;AAAA,MACAC;AAAA,MACAC;AAAA,IACG,IAAA,KAAK,gBAAgBf,GAASC,CAAM,GAClCe,IAAsBJ,EAAiB;AAAA,MAAI,CAACK,GAAIC,MACrDJ,EACE,IAAI,CAACK,GAAIC,MACFD,KAAMF,KACZF,EAAiBK,CAAC,KAAKP,EAAkBK,CAAC,MACzCd,EAAec,CAAC,MAAM,MAAMd,EAAec,CAAC,MAAME,OAClD,CAACb,KACDG,EAAsB,IAAIQ,CAAC,KAC3BlB,EAAQ,OAAQkB,CAAC,MAAMjB,EAAO,OAAQmB,CAAC,KACtCA,IACA,EACH,EACA,OAAO,CAACA,MAAMA,MAAM,EAAE;AAAA,IACzB,GACMC,IAAQ,CAACC,MAAwB;AACtC,UAAIA,MAAUjB,GAAG;AAChB,QACC,KAAK;AAAA,UACJL;AAAA,UACAC;AAAA,UACAQ;AAAA,UACAE;AAAA,QAAA,KAGDkB,EAAQ,KAAK,CAAC,GAAGpB,CAAO,CAAC;AAE1B;AAAA,MAAA;AAEU,iBAAAc,KAAaP,EAAQM,CAAK;AAChC,QAACd,EAAKe,CAAS,MAClBd,EAAQa,CAAK,IAAIC,GACjBf,EAAKe,CAAS,IAAI,IAEjB,KAAK;AAAA,UACJvB;AAAA,UACAC;AAAA,UACAQ;AAAA,UACAa;AAAA,UACAX;AAAA,QAAA,KAGDU,EAAMC,IAAQ,CAAC,GAEhBd,EAAKe,CAAS,IAAI,IAClBd,EAAQa,CAAK,IAAI;AAAA,IAGpB;AACA,WAAAD,EAAM,CAAC,GACAQ;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WACP7B,GACAC,GACAQ,GACAa,GACAX,GACU;AACJ,UAAAmB,IAAgB9B,EAAQ,cAAcC,EAAO;AAEnD,aAASiB,IAAI,GAAGA,IAAII,GAAOJ;AAe1B,UAdIlB,EAAQ,gBAAgBsB,CAAK,EAAEJ,CAAC,MAC/B,CAACjB,EAAO,gBAAgBQ,EAAQa,CAAK,CAAC,EAAEb,EAAQS,CAAC,CAAC,KAKrDY,KACA,CAACnB,EAAsB,IAAIW,IAAQ,MAAMJ,CAAC,KAC1ClB,EAAQ,WAAYsB,CAAK,EAAEJ,CAAC,MAC3BjB,EAAO,WAAYQ,EAAQa,CAAK,CAAC,EAAEb,EAAQS,CAAC,CAAC,MAK5ClB,EAAQ,gBAAgBkB,CAAC,EAAEI,CAAK,MAC/B,CAACrB,EAAO,gBAAgBQ,EAAQS,CAAC,CAAC,EAAET,EAAQa,CAAK,CAAC,KAKrDQ,KACA,CAACnB,EAAsB,IAAIO,IAAI,MAAMI,CAAK,KAC1CtB,EAAQ,WAAYkB,CAAC,EAAEI,CAAK,MAC3BrB,EAAO,WAAYQ,EAAQS,CAAC,CAAC,EAAET,EAAQa,CAAK,CAAC;AAEvC,eAAA;AAIH,WAAA;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA,EAMA,mBACPtB,GACAC,GACAQ,GACAE,GACU;AACJ,UAAAmB,IAAgB9B,EAAQ,cAAcC,EAAO,YAC7CI,IAAIL,EAAQ,gBAAgB;AAClC,aAASkB,IAAI,GAAGA,IAAIb,GAAGa;AACtB,eAASE,IAAI,GAAGA,IAAIf,GAAGe;AACtB,YAAIpB,EAAQ,gBAAgBkB,CAAC,EAAEE,CAAC,MAC3B,CAACnB,EAAO,gBAAgBQ,EAAQS,CAAC,CAAC,EAAET,EAAQW,CAAC,CAAC,KAKjDU,KACA,CAACnB,EAAsB,IAAIO,IAAI,MAAME,CAAC,KACtCpB,EAAQ,WAAYkB,CAAC,EAAEE,CAAC,MACvBnB,EAAO,WAAYQ,EAAQS,CAAC,CAAC,EAAET,EAAQW,CAAC,CAAC;AAGnC,iBAAA;AAKJ,WAAA;AAAA,EAAA;AAET;;;;;8CCvRaW,IAAN,MAAMA,EAAW;AAAA,EA+BhB,YACNC,GACAC,IAAiDF,EAAW,+BAC5DG,IAA6CH,EAAW,6BACxDI,IAA6DJ,EAAW,qCACvE;AAjBe,IAAAK,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA,2CAAoB,IAAsB;AAC1C,IAAAA,EAAA,sCAAe,IAAoB;AACnC,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AAQhB,SAAK,QAAQJ,GACR,KAAA,YAAYA,EAAM,gBAAgB,QAClC,KAAA,gBAAgBA,EAAM,WAAW,QACjC,KAAA,oBAAoBA,EAAM,mBAAmB,QAC7C,KAAA,gBAAgBA,EAAM,eAAe,QAC1C,KAAK,uBAAuBE,GAC5B,KAAK,+BAA+BC;AACpC,QAAIE,IAAc;AAClB,aAASnB,IAAI,GAAGA,IAAI,KAAK,WAAWA,KAAK;AAClC,YAAAoB,wBAAgB,IAAY;AAClC,UAAIC,IAAW,GACXC,IAAY;AAChB,eAASpB,IAAI,GAAGA,IAAI,KAAK,WAAWA,KAAK;AACxC,cAAMqB,IAAQT,EAAM,gBAAgBd,CAAC,EAAEE,CAAC,GAClCsB,IAAOV,EAAM,gBAAgBZ,CAAC,EAAEF,CAAC;AACvC,QAAIuB,MAAU,MACbD,KACAF,EAAU,IAAIlB,CAAC,IAEZsB,MAAS,MACZH,KACAD,EAAU,IAAIlB,CAAC,IAEZqB,MAAUC,MACCL,IAAA;AAAA,MACf;AAED,WAAK,cAAc,IAAInB,GAAG,CAAC,GAAGoB,CAAS,CAAC;AACxC,YAAMK,IACLH,IAAY,MAAMD,IAAW,MAAMN,EAAuBD,GAAOd,CAAC;AAC9D,WAAA,SAAS,IAAIA,GAAGyB,CAAO;AAAA,IAAA;AAE7B,SAAK,cAAcN,GAEd,KAAA,qBAAqB,KAAK,sBAAsB;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAW/C,eAA4D;AAClE,UAAMO,IAAY,IAAI,MAAM,KAAK,SAAS,EAAE,KAAK,CAAC;AAClD,SAAK,wBAAwBA,CAAS;AAChC,UAAAC,wBAME,IAAI,GACNC,wBAAqB,IAAY;AAClC,SAAA;AAAA,MACJF;AAAA,MACA,CAAC;AAAA,MACDE;AAAA,MACA,KAAK,0BAA0BD,GAAYC,CAAc;AAAA,IAC1D;AACA,UAAMC,IAAiB,CAAC,GAAGF,EAAW,KAAA,CAAM,EAAE;AAAA,MAAK,CAACjB,GAAGH,MACtDG,EAAE,cAAcH,CAAC;AAAA,MAChB,CAAC,GACGuB,IAAYH,EAAW,IAAIE,CAAc,GACzCE,IAAyB,IAAI,MAAM,KAAK,SAAS,GACjDC,IAAqB,IAAI,MAAMD,EAAuB,MAAM;AAClE,KAAC,GAAGD,EAAU,WAAW,CAAC,EAAE,SAAS,EAAE,QAAQ,CAAC,CAACG,GAAGjC,CAAC,MAAM;AAC1D,MAAA+B,EAAuB/B,CAAC,IAAIiC,GACTD,EAAAC,IAAI,CAAC,IAAIjC;AAAA,IAAA,CAC5B;AACD,UAAMkC,IAAmB,KAAK;AAAA,MAC7BH;AAAA,IACD,GACMI,wBAAuB,IAA0B;AACvD,YAAC,GAAGR,EAAW,OAAQ,CAAA,EAAE;AAAA,MAAQ,CAACS,MACjC,CAAC,GAAGA,EAAE,cAAc,QAAS,CAAA,EAAE;AAAA,QAAQ,CAAC,CAACC,GAAKC,CAAG,MAChDH,EAAiB,IAAIE,GAAKC,CAAG;AAAA,MAAA;AAAA,IAE/B,GACO;AAAA,MACNJ;AAAA,MACA,KAAK,iBAAiBA,CAAgB;AAAA,MACtCF;AAAA,MACA,IAAIO,EAAkB,CAAC,GAAGJ,EAAiB,OAAA,CAAQ,CAAC;AAAA,IACrD;AAAA,EAAA;AAAA,EAGO,0BACPR,GAOAC,GACkD;AAClD,UAAMY,IAAU,MAAM,KAAK,EAAC,QAAQ,KAAK,UAAS,GAAG,CAAC/B,GAAGT,MAAMA,IAAI,CAAC;AAC7D,WAAA,CAACyC,GAAcC,MAAW;AAE1B,YAAAZ,wBAAgB,IAAoB;AAC7B,MAAAW,EAAA,QAAQ,CAAC,GAAGzC,MAAM8B,EAAU,IAAI,GAAG9B,CAAC,CAAC;AAClD,YAAM2C,IAAeH,EACnB;AAAA,QAAI,CAAC,MACL,KAAK,cACH,IAAIV,EAAU,IAAI,CAAC,CAAE,EACrB,IAAI,CAAC3C,MAAMsD,EAAatD,CAAC,CAAC,EAC1B,KAAK,EACL,KAAK,GAAG;AAAA,MAAA,EAEV,KAAK,GAAG;AACN,UAAAyD,IAAsBjB,EAAW,IAAIgB,CAAY;AACrD,MAAIC,MAAwB,WACLA,IAAA;AAAA,QACrB,YAAY,CAAC;AAAA,QACb,mCAAmB,IAAI;AAAA,MACxB,GACWjB,EAAA,IAAIgB,GAAcC,CAAmB;AAGtCd,iBAAAA,KAAac,EAAoB,YAAY;AACjD,cAAAC,wBAAsB,IAA8B;AAC1D,iBAAS7C,IAAI,GAAGA,IAAIyC,EAAa,QAAQzC,KAAK;AAC7C,gBAAM8C,IAAiBhB,EAAU,IAAIW,EAAazC,CAAC,CAAC;AACpD,cAAI8C,MAAmB9C,GAAG;AACzB,kBAAMG,IAA0B;AAAA,cAC/B2C,IAAiB9C,IAAI8C,IAAiB9C;AAAA,cACtCA,IAAI8C,IAAiBA,IAAiB9C;AAAA,YACvC;AACgB,YAAA6C,EAAA,IAAI1C,EAAM,CAAC,IAAI,MAAMA,EAAM,CAAC,GAAGA,CAAK;AAAA,UAAA;AAAA,QACrD;AAEK,cAAA4C,IAAe,IAAIC,EAAa,CAAC,GAAGH,EAAgB,OAAA,CAAQ,CAAC;AACnE,QAAAD,EAAoB,cAAc;AAAA,UACjCG,EAAa,SAAS;AAAA,UACtBA;AAAA,QACD;AACW,mBAAAE,KAAKF,EAAa;AAC5B,mBAAS/C,IAAI,GAAGA,IAAI0C,EAAO,QAAQ1C;AAClC,YAAIiD,EAAE,SAASP,EAAO1C,CAAC,CAAC,KACvBiD,EAAE,OAAO,CAACC,MAAMA,KAAKR,EAAO1C,CAAC,CAAC,EAAE;AAAA,cAAQ,CAACkD,MACxCtB,EAAe,IAAI,CAAC,GAAGc,EAAO,MAAM,GAAG1C,CAAC,GAAGkD,CAAC,EAAE,KAAK,GAAG,CAAC;AAAA,YACxD;AAAA,MAGH;AAGmB,MAAAN,EAAA,WAAW,KAAKd,CAAS;AAAA,IAC9C;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASM,MAAyB;AAC/B,UAAMJ,IAAY,IAAI,MAAM,KAAK,SAAS,EAAE,KAAK,CAAC;AAClD,SAAK,wBAAwBA,CAAS;AAChC,UAAAC,wBAME,IAAI,GACNC,wBAAqB,IAAY;AAClC,SAAA;AAAA,MACJF;AAAA,MACA,CAAC;AAAA,MACDE;AAAA,MACA,KAAK,0BAA0BD,GAAYC,CAAc;AAAA,IAC1D;AACM,UAAAO,wBAAuB,IAA0B;AACvD,YAAC,GAAGR,EAAW,OAAQ,CAAA,EAAE;AAAA,MAAQ,CAACS,MACjC,CAAC,GAAGA,EAAE,cAAc,QAAS,CAAA,EAAE;AAAA,QAAQ,CAAC,CAACC,GAAKC,CAAG,MAChDH,EAAiB,IAAIE,GAAKC,CAAG;AAAA,MAAA;AAAA,IAE/B,GACO,IAAIC,EAAkB,CAAC,GAAGJ,EAAiB,OAAQ,CAAA,CAAC;AAAA,EAAA;AAAA,EAGpD,wBAAwBT,GAAqB;AAC9C,UAAAyB,wBAA6B,IAAsB;AACzD,aAASnD,IAAI,GAAGA,IAAI,KAAK,WAAWA,KAAK;AACxC,YAAMqC,IAAM,KAAK,SAAS,IAAIrC,CAAC;AAC3B,MAAAmD,EAAuB,IAAId,CAAG,IACjCc,EAAuB,IAAId,CAAG,EAAG,KAAKrC,CAAC,IAEvCmD,EAAuB,IAAId,GAAK,CAACrC,CAAC,CAAC;AAAA,IACpC;AAED,QAAIoD,IAAe;AACnB,UAAM,KAAKD,EAAuB,KAAA,CAAM,EACtC,KAAK,CAACzC,GAAGH,MAAMG,EAAE,cAAcH,CAAC,CAAC,EACjC,QAAQ,CAAC8C,MAAM;AACT,YAAAC,IAAkBH,EAAuB,IAAIE,CAAC;AACpD,MAAAC,EAAgB,QAAQ,CAACtD,MAAO0B,EAAU1B,CAAC,IAAIoD,CAAa,GAC5DA,KAAgBE,EAAgB;AAAA,IAAA,CAChC;AAAA,EAAA;AAAA,EAGK,QAAQ5B,GAA8B;AAC7C,WAAO,IAAI,IAAYA,CAAS,EAAE,SAAS,KAAK;AAAA,EAAA;AAAA,EAGzC,iBACPA,GACAgB,GACAd,GACA2B,GACC;AACG,QAAA,KAAK,QAAQ7B,CAAS,GAAG;AAC5B,MAAA6B,EAAqB7B,GAAWgB,CAAM;AACtC;AAAA,IAAA;AAGG,QADJ,KAAK,4BAA4BhB,CAAS,GACtC,KAAK,QAAQA,CAAS,GAAG;AAC5B,MAAA6B,EAAqB7B,GAAWgB,CAAM;AACtC;AAAA,IAAA;AAEK,UAAAc,IAAc,KAAK,eAAe9B,CAAS;AACtC,eAAAvC,KAAKqE,EAAY,CAAC;AAC5B,MAAA9B,EAAUvC,CAAC,IAAIqE,EAAY,CAAC,IAAI;AAEtB,eAAAC,KAAUD,EAAY,CAAC,GAAG;AAEpC,YAAME,IAAY,CAAC,GAAGhB,GAAQe,CAAM;AACpC,MAAI7B,EAAe,IAAI8B,EAAU,KAAK,GAAG,CAAC,MAGhChC,EAAA+B,CAAM,IAAID,EAAY,CAAC,GAC5B,KAAA;AAAA,QACJ,CAAC,GAAG9B,CAAS;AAAA,QACbgC;AAAA,QACA9B;AAAA,QACA2B;AAAA,MACD,GACA7B,EAAU+B,CAAM,IAAID,EAAY,CAAC,IAAI;AAAA,IAAA;AAAA,EACtC;AAAA,EAGO,4BAA4B9B,GAAqB;AACxD,QAAIiC,IAAc;AAClB,WAAO,CAACA,KAAa;AACN,MAAAA,IAAA;AAEd,YAAMC,IAAuBlC,EAAU,IAAI,CAACjB,GAAGT,MACxB,KAAK,cAAc,IAAIA,CAAC,EAAG,IAAI,CAACb,MAAM;AAC3D,YAAI,KAAK,eAAe;AACjB,gBAAA0E,IAAa,KAAK,MAAM;AAC9B,iBAAI,KAAK,cACD,GAAGnC,EAAUvC,CAAC,CAAC,IAAI0E,EAAW7D,CAAC,EAAEb,CAAC,CAAC,KAEpC,GAAGuC,EAAUvC,CAAC,CAAC,IAAI0E,EAAW7D,CAAC,EAAEb,CAAC,CAAC,IAAI0E,EAAW1E,CAAC,EAAEa,CAAC,CAAC;AAAA,QAAA;AAExD,eAAA0B,EAAUvC,CAAC,EAAE,SAAS;AAAA,MAAA,CAC7B,EACoB,OAAO,KAAK,GAAG,CACpC,GAEK2E,wBAAmB,IAAmC;AACjD,MAAAF,EAAA,QAAQ,CAACG,GAAWC,MAAc;AACtC,cAAAC,IAAOvC,EAAUsC,CAAS;AAC5B,YAAAE,IAAUJ,EAAa,IAAIG,CAAI;AACnC,QAAIC,MAAY,WACfA,wBAAc,IAAI,GACLJ,EAAA,IAAIG,GAAMC,CAAO;AAE3B,YAAAC,IAAcD,EAAQ,IAAIH,CAAS;AACvC,QAAII,MAAgB,WACnBA,IAAc,CAAC,GACPD,EAAA,IAAIH,GAAWI,CAAW,IAEnCA,EAAY,KAAKH,CAAS;AAAA,MAAA,CAC1B;AAED,eAASI,IAAS,GAAGA,KAAU,KAAK,WAAWA,KAAU;AAClD,cAAAC,IAAQP,EAAa,IAAIM,CAAM;AACrC,YAAIC,MAAU,UAAaA,EAAM,OAAO;AACvC;AAEa,QAAAV,IAAA;AAEd,cAAMW,IAAY,CAAC,GAAGD,EAAM,KAAM,CAAA,EAAE,KAAK,CAAC3D,GAAGH,MAAMA,EAAE,cAAcG,CAAC,CAAC;AACrE,YAAI6D,IAAYH;AAChB,mBAAW/B,KAAOiC,GAAW;AACtB,gBAAAE,IAAQH,EAAM,IAAIhC,CAAG;AAC3B,UAAAmC,EAAM,QAAQ,CAACrF,MAAOuC,EAAUvC,CAAC,IAAIoF,CAAU,GAC/CA,KAAaC,EAAM;AAAA,QAAA;AAEpB;AAAA,MAAA;AAAA,IACD;AAAA,EACD;AAAA,EAGO,eAAe9C,GAAyC;AACzD,UAAA+C,IAAoB,MAAM,KAAK,EAAC,QAAQ/C,EAAU,UAAS,MAAM,EAAE;AAC/D,IAAAA,EAAA,QAAQ,CAACO,GAAGjC,MAAMyE,EAAMxC,IAAI,CAAC,EAAE,KAAKjC,CAAC,CAAC;AAChD,aAAS,IAAI,GAAG,IAAIyE,EAAM,QAAQ;AACjC,UAAIA,EAAM,CAAC,EAAE,SAAS;AACrB,eAAO,CAAC,IAAI,GAAGA,EAAM,CAAC,CAAC;AAGzB,WAAO,CAAC,GAAGA,EAAM,CAAC,CAAC;AAAA,EAAA;AAAA,EAGZ,yBAAyB/C,GAA4B;AAC5D,UAAMgD,IAAchD,EAAU,IAAI,CAACO,MAAMA,IAAI,CAAC,GACxCnB,IAAe;AAAA,MACpB,iBAAiB,MAAM;AAAA,QACtB,EAAC,QAAQ,KAAK,UAAS;AAAA,QACvB,MAAM,IAAI,MAAM,KAAK,SAAS;AAAA,MAAA;AAAA,IAEhC;AACA,QAAI,KAAK;AACR,eAASd,IAAI,GAAGA,IAAI,KAAK,WAAWA,KAAK;AAClC,cAAA2E,IAAKD,EAAY1E,CAAC,GAClBQ,IAAM,KAAK,MAAM,gBAAgBR,CAAC;AACxC,iBAASE,IAAIF,GAAGE,IAAI,KAAK,WAAWA;AAC7B,UAAAY,EAAA,gBAAgB6D,CAAE,EAAED,EAAYxE,CAAC,CAAC,IAAIM,EAAIN,CAAC,GAC3CY,EAAA,gBAAgB4D,EAAYxE,CAAC,CAAC,EAAEyE,CAAE,IAAInE,EAAIN,CAAC;AAAA,MAClD;AAAA;AAGD,eAASF,IAAI,GAAGA,IAAI,KAAK,WAAWA,KAAK;AAClC,cAAA2E,IAAKD,EAAY1E,CAAC,GAClBQ,IAAM,KAAK,MAAM,gBAAgBR,CAAC;AACxC,iBAASE,IAAI,GAAGA,IAAI,KAAK,WAAWA;AAC7B,UAAAY,EAAA,gBAAgB6D,CAAE,EAAED,EAAYxE,CAAC,CAAC,IAAIM,EAAIN,CAAC;AAAA,MAClD;AAkBF,QAfI,KAAK,kBACRY,EAAM,SAAS,IAAI,MAAM,KAAK,SAAS,GACvC4D,EAAY,QAAQ,CAACzC,GAAGjC,MAAOc,EAAM,OAAQmB,CAAC,IAAI,KAAK,MAAM,OAAQjC,CAAC,CAAE,IAErE,KAAK,sBACRc,EAAM,iBAAiB,IAAI,MAAM,KAAK,SAAS,GACnC4D,EAAA;AAAA,MACX,CAACzC,GAAGjC,MACFc,EAAM,eAAgBmB,CAAC,IAAI,KAAK;AAAA,QAChC,KAAK;AAAA,QACLjC;AAAA,QACA0E;AAAA,MAAA;AAAA,IAEH,IAEG,KAAK;AAKR,UAJA5D,EAAM,aAAa,MAAM;AAAA,QACxB,EAAC,QAAQ,KAAK,UAAS;AAAA,QACvB,MAAM,IAAI,MAAM,KAAK,SAAS;AAAA,MAC/B,GACI,KAAK;AACR,iBAASd,IAAI,GAAGA,IAAI,KAAK,WAAWA,KAAK;AAClC,gBAAA2E,IAAKD,EAAY1E,CAAC,GAClBQ,IAAM,KAAK,MAAM,WAAYR,CAAC;AACpC,mBAASE,IAAIF,GAAGE,IAAI,KAAK,WAAWA;AAC7B,YAAAY,EAAA,WAAW6D,CAAE,EAAED,EAAYxE,CAAC,CAAC,IAAIM,EAAIN,CAAC,GACtCY,EAAA,WAAW4D,EAAYxE,CAAC,CAAC,EAAEyE,CAAE,IAAInE,EAAIN,CAAC;AAAA,QAC7C;AAAA;AAGD,iBAASF,IAAI,GAAGA,IAAI,KAAK,WAAWA,KAAK;AAClC,gBAAA2E,IAAKD,EAAY1E,CAAC,GAClBQ,IAAM,KAAK,MAAM,WAAYR,CAAC;AACpC,mBAASE,IAAI,GAAGA,IAAI,KAAK,WAAWA;AAC7B,YAAAY,EAAA,WAAW6D,CAAE,EAAED,EAAYxE,CAAC,CAAC,IAAIM,EAAIN,CAAC;AAAA,QAC7C;AAII,WAAAY;AAAA,EAAA;AAAA,EAGA,wBAAwB;AACzB,UAAA8D,IAAe,KAAK,gBACvB,CAAC9D,GAAcd,GAAWE,MAC1B,GAAGF,CAAC,IAAIc,EAAM,WAAYd,CAAC,EAAEE,CAAC,CAAC,IAAIA,CAAC,KACpC,CAACO,GAAUT,GAAWE,MAAc,GAAGF,CAAC,IAAIE,CAAC,IAC1C2E,IAAuB,KAAK,oBAC/B,CAAC/D,GAAcd,MAAsB;AACrC,YAAM8E,IAAuB,KAAK;AAAA,QACjChE;AAAA,QACAd;AAAA,MACD;AACA,aAAO8E,EAAqB,SAAS,IAClC,IAAIA,CAAoB,MACxB;AAAA,IAAA,IAEH,CAACC,GAAeC,MAAuB,IACpCC,IAAe,KAAK,gBACvB,CAACnE,MACD,MACAA,EACE,OAAQ,IAAI,CAACoE,GAAGlF,MAAMkF,IAAIL,EAAqB/D,GAAOd,CAAC,CAAC,EACxD,KAAK,GAAG,IACV,KAAK,oBACJ,CAACc,MACD,MACAA,EACE,eAAgB;AAAA,MAAI,CAACL,GAAGT,MACxB,KAAK,6BAA6Bc,GAAOd,CAAC;AAAA,IAE1C,EAAA,KAAK,GAAG,IACV,CAACS,MAAqB;AAE1B,WAAI,KAAK,cACD,CAACK,MAAyB;AAChC,YAAMqE,IAAQ,CAAC;AACf,eAASnF,IAAI,GAAGA,IAAI,KAAK,WAAWA,KAAK;AAClC,cAAAQ,IAAMM,EAAM,gBAAgBd,CAAC;AACnC,iBAASE,IAAIF,GAAGE,IAAI,KAAK,WAAWA;AAC/B,UAAAM,EAAIN,CAAC,MAAM,KACdiF,EAAM,KAAKP,EAAa9D,GAAOd,GAAGE,CAAC,CAAC;AAAA,MAEtC;AAED,aAAOiF,EAAM,KAAK,GAAG,IAAIF,EAAanE,CAAK;AAAA,IAC5C,IAEM,CAACA,MAAyB;AAChC,YAAMqE,IAAQ,CAAC;AACf,eAASnF,IAAI,GAAGA,IAAI,KAAK,WAAWA,KAAK;AAClC,cAAAQ,IAAMM,EAAM,gBAAgBd,CAAC;AACnC,iBAASE,IAAI,GAAGA,IAAI,KAAK,WAAWA;AAC/B,UAAAM,EAAIN,CAAC,MAAM,KACdiF,EAAM,KAAKP,EAAa9D,GAAOd,GAAGE,CAAC,CAAC;AAAA,MAEtC;AAED,aAAOiF,EAAM,KAAK,GAAG,IAAIF,EAAanE,CAAK;AAAA,IAC5C;AAAA,EAAA;AAAA,EAGM,iBAAiBA,GAAsB;AACtC,WAAA,KAAK,mBAAmBA,CAAK;AAAA,EAAA;AAEtC;AA9dCI,EADYL,GACW,iCACtB,CAACC,GAAckD,MACPlD,EAAM,SAASA,EAAM,OAAOkD,CAAS,IAAI,KAElD9C,EALYL,GAKW,+BAAoD,CAC1EC,GACAkD,GACAoB,MAEOtE,EAAM,kBAAkBA,EAAM,eAAekD,CAAS,IAC1D,IAAI,IAAIlD,EAAM,eAAekD,CAAS,CAAC,IACvC,SAEJ9C,EAdYL,GAcW,uCACtB,CAACkE,GAAeM,MACR;AAhBH,IAAMC,IAANzE;;;;;AC1BA,MAAM0E,EAAoB;AAAA,EAChC,OAAc,KAAKzE,GAA0B;AAC5C,UAAM0E,IAAqB,CAAC,GACtBC,wBAAc,IAAY,GAE1BC,IAAM,CAACC,GAAcC,MAAwB;AAClD,MAAAH,EAAQ,IAAIE,CAAI,GAChBC,EAAU,KAAKD,CAAI;AACnB,eAAS3F,IAAI,GAAGA,IAAIc,EAAM,gBAAgB,QAAQd;AACjD,SACCc,EAAM,gBAAgB6E,CAAI,EAAE3F,CAAC,MAAM,KACnCc,EAAM,gBAAgBd,CAAC,EAAE2F,CAAI,MAAM,OAE9BF,EAAQ,IAAIzF,CAAC,KACjB0F,EAAI1F,GAAG4F,CAAS;AAAA,IAIpB;AAEA,aAAS5F,IAAI,GAAGA,IAAIc,EAAM,gBAAgB,QAAQd;AACjD,UAAI,CAACyF,EAAQ,IAAIzF,CAAC,GAAG;AACpB,cAAM4F,IAAsB,CAAC;AAC7B,QAAAF,EAAI1F,GAAG4F,CAAS,GAChBJ,EAAO,KAAKI,CAAS;AAAA,MAAA;AAGhB,WAAAJ;AAAA,EAAA;AAET;ACRO,MAAMK,IAAN,MAAMA,EAAa;AAAA,EAKzB,YAAYC,GAA8B;AAF1B,IAAA5E,EAAA;AAGf,SAAK,WAAW4E;AAAA,EAAA;AAAA,EAGV,MAAMC,GAAmB;AACpB,eAAAxG,KAAW,KAAK,UAAU;AAChC,UAAAA,EAAQ,CAAC,MAAMwG;AAClB,eAAOxG,EAAQ,CAAC;AAEb,UAAAA,EAAQ,CAAC,MAAMwG;AAClB,eAAOxG,EAAQ,CAAC;AAAA,IACjB;AAEM,WAAAwG;AAAA,EAAA;AAAA,EAGD,WAAmB;AACzB,WAAO,KAAK,SAAS,IAAI,CAAC3G,MAAM,IAAIA,EAAE,CAAC,CAAC,IAAIA,EAAE,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE;AAAA,EAAA;AAE9D;AAvBC8B,EADY2E,GACW,YAAW,IAAIA,EAAa,EAAE;AAD/C,IAAM7C,IAAN6C;AA0BA,MAAMtD,EAAkB;AAAA,EAG9B,YAAYyD,GAA4B;AAFxB,IAAA9E,EAAA;AAGf,SAAK,aAAa,CAAC8B,EAAa,UAAU,GAAGgD,CAAU;AAAA,EAAA;AAAA,EAGjD,QAAQD,GAAqB;AAC7B,UAAAE,wBAAY,IAAY;AAC9B,IAAAA,EAAM,IAAIF,CAAC;AACA,eAAAzD,KAAO,KAAK;AACtB,MAAA2D,EAAM,IAAI3D,EAAI,MAAMyD,CAAC,CAAC;AAEvB,WAAO,MAAM,KAAKE,CAAK,EAAE,KAAK;AAAA,EAAA;AAAA,EAGxB,aAAaF,GAA2B;AACvC,WAAA,KAAK,WAAW,OAAO,CAACzD,MAAQA,EAAI,MAAMyD,CAAC,MAAMA,CAAC;AAAA,EAAA;AAAA,EAGnD,iBAAiBA,GAAmB;AAC1C,WAAO,KAAK,WAAW;AAAA,MACtB,CAAC9D,GAAGK,MAASL,KAAKK,EAAI,MAAMyD,CAAC,MAAMA,IAAI,IAAI;AAAA,MAC3C;AAAA,IACD;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA,EAMM,YAAYA,GAAmB;AACrC,WAAO,KAAK,WAAW,SAAS,KAAK,iBAAiBA,CAAC;AAAA,EAAA;AAAA,EAGjD,OAAOG,GAAyB;AAChC,UAAAC,wBAAW,IAAY,GACvBC,IAAqB,CAAC;AAC5B,eAAWL,KAAKG;AACf,UAAI,CAACC,EAAK,IAAIJ,CAAC,GAAG;AACX,cAAAM,IAAM,KAAK,QAAQN,CAAC;AAC1B,QAAAM,EAAI,QAAQ,CAACpD,MAAMkD,EAAK,IAAIlD,CAAC,CAAC,GAC9BmD,EAAO,KAAKC,CAAG;AAAA,MAAA;AAGV,WAAAD;AAAA,EAAA;AAAA,EAGD,WAAmB;AACzB,WAAO,MAAM,KAAK,WAAW,IAAI,CAACL,MAAMA,EAAE,SAAA,CAAU,EAAE,KAAK,IAAI,IAAI;AAAA,EAAA;AAErE;AAEO,SAASO,EAAuBxF,GAAsB;AACtD,QAAA3B,IAAI2B,EAAM,gBAAgB;AAChC,MAAIqE,IAAkB,CAAC;AACvB,WAAS,IAAI,GAAG,IAAIhG,GAAG;AACtB,aAASe,IAAI,IAAI,GAAGA,IAAIf,GAAGe;AAC1B,MAAIY,EAAM,gBAAgB,CAAC,EAAEZ,CAAC,MAAM,KACnCiF,EAAM,KAAK,KAAK,IAAI,CAAC,IAAIjF,IAAI,CAAC,EAAE;AAI5B,SAAA,CAAC,UAAUf,CAAC,IAAIgG,EAAM,MAAM,IAAI,GAAGA,CAAK,EAAE,KAAK;AAAA,CAAI;AAC3D;;;;;;;;;;"}