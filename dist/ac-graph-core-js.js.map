{"version":3,"file":"ac-graph-core-js.js","sources":["../src/graph/matching/GraphMatcher.ts","../src/graph/matching/UllmannGraphMatcher.ts","../src/graph/Automorphism.ts","../src/graph/canon/GraphCanon.ts","../src/graph/ConnectedComponents.ts","../src/graph/index.ts"],"sourcesContent":["import {Mapping} from '.';\nimport {Graph} from '..';\n\nexport abstract class GraphMatcher {\n\t/**\n\t * Subgraph isomorphism check\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic abstract isSubgraphIsomorphic(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[],\n\t\tedgeLabelWildcards: string[],\n\t\tpartialMapping: number[] | null\n\t): boolean;\n\n\t/**\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\n\t * including symmetries\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic abstract findAllSubgraphMonomorphisms(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[],\n\t\tedgeLabelWildcards: string[],\n\t\tpartialMapping: number[] | null\n\t): Mapping[];\n}\n","import {Mapping} from '.';\nimport {Graph} from '..';\nimport {GraphMatcher} from './GraphMatcher';\n\nexport class UllmannGraphMatcher extends GraphMatcher {\n\t/**\n\t * Subgraph isomorphism check\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic override isSubgraphIsomorphic(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[] = [],\n\t\tedgeLabelWildcards: string[] = [],\n\t\tpartialMapping: number[] | null = null\n\t): boolean {\n\t\t// Number of nodes in the pattern graph\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\t// Number of nodes in the target graph\n\t\tconst m = target.adjacencyMatrix.length;\n\t\t// If pattern is larger than target, no mapping is possible\n\t\tif (n > m) {\n\t\t\treturn false;\n\t\t}\n\t\tif (partialMapping === null) {\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\n\t\t}\n\t\tconst isLabeled = pattern.labels && target.labels;\n\t\t// Track which target nodes are already used in the mapping\n\t\tconst used = Array(m).fill(false);\n\t\tconst mapping = Array(n).fill(-1);\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\n\t\t// Pre-compute degrees for pattern and target nodes\n\t\tconst [\n\t\t\tpatternInDegrees,\n\t\t\tpatternOutDegrees,\n\t\t\ttargetInDegrees,\n\t\t\ttargetOutDegrees,\n\t\t] = this.getInOutDegrees(pattern, target);\n\t\t// Pre-compute candidate domains for pattern nodes based on degree\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\n\t\t\ttargetInDegrees\n\t\t\t\t.map((td, j) => {\n\t\t\t\t\treturn td >= pd &&\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\n\t\t\t\t\t\t(!isLabeled ||\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\n\t\t\t\t\t\t? j\n\t\t\t\t\t\t: -1;\n\t\t\t\t})\n\t\t\t\t.filter((j) => j !== -1)\n\t\t);\n\t\t// Recursive backtracking function to try all injective mappings\n\t\tconst match = (depth: number): boolean => {\n\t\t\tif (depth === n) {\n\t\t\t\treturn this.checkCompatibility(\n\t\t\t\t\tpattern,\n\t\t\t\t\ttarget,\n\t\t\t\t\tmapping,\n\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t);\n\t\t\t}\n\t\t\tfor (const candidate of domains[depth]) {\n\t\t\t\tif (!used[candidate]) {\n\t\t\t\t\tmapping[depth] = candidate;\n\t\t\t\t\tused[candidate] = true;\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.isFeasible(\n\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tmapping,\n\t\t\t\t\t\t\tdepth,\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t\t\t) &&\n\t\t\t\t\t\tmatch(depth + 1)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// Backtrack\n\t\t\t\t\tused[candidate] = false;\n\t\t\t\t\tmapping[depth] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\treturn match(0);\n\t}\n\n\tprivate getInOutDegrees(\n\t\tpattern: Graph,\n\t\ttarget: Graph\n\t): [number[], number[], number[], number[]] {\n\t\tconst patternInDegrees = pattern.adjacencyMatrix.map((r) =>\n\t\t\tr.reduce((a, b) => a + b, 0)\n\t\t);\n\t\tconst patternOutDegrees: number[] = [];\n\t\tconst targetInDegrees = target.adjacencyMatrix.map((r) =>\n\t\t\tr.reduce((a, b) => a + b, 0)\n\t\t);\n\t\tconst targetOutDegrees: number[] = [];\n\t\tpattern.adjacencyMatrix.forEach((row, i) => {\n\t\t\tpatternOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => pattern.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t});\n\t\ttarget.adjacencyMatrix.forEach((row, i) => {\n\t\t\ttargetOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => target.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t});\n\t\treturn [\n\t\t\tpatternInDegrees,\n\t\t\tpatternOutDegrees,\n\t\t\ttargetInDegrees,\n\t\t\ttargetOutDegrees,\n\t\t];\n\t}\n\n\t/**\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\n\t * including symmetries\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic override findAllSubgraphMonomorphisms(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[] = [],\n\t\tedgeLabelWildcards: string[] = [],\n\t\tpartialMapping: number[] | null = null\n\t): Mapping[] {\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\tconst m = target.adjacencyMatrix.length;\n\t\tconst results: Mapping[] = [];\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\n\t\tif (n > m) {\n\t\t\treturn results;\n\t\t}\n\t\tif (partialMapping === null) {\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\n\t\t}\n\t\tconst isLabeled = pattern.labels && target.labels;\n\t\tconst used = Array(m).fill(false);\n\t\tconst mapping = Array(n).fill(-1);\n\t\tconst [\n\t\t\tpatternInDegrees,\n\t\t\tpatternOutDegrees,\n\t\t\ttargetInDegrees,\n\t\t\ttargetOutDegrees,\n\t\t] = this.getInOutDegrees(pattern, target);\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\n\t\t\ttargetInDegrees\n\t\t\t\t.map((td, j) => {\n\t\t\t\t\treturn td >= pd &&\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\n\t\t\t\t\t\t(!isLabeled ||\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\n\t\t\t\t\t\t? j\n\t\t\t\t\t\t: -1;\n\t\t\t\t})\n\t\t\t\t.filter((j) => j !== -1)\n\t\t);\n\t\tconst match = (depth: number): void => {\n\t\t\tif (depth === n) {\n\t\t\t\tif (\n\t\t\t\t\tthis.checkCompatibility(\n\t\t\t\t\t\tpattern,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tmapping,\n\t\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tresults.push([...mapping]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (const candidate of domains[depth]) {\n\t\t\t\tif (!used[candidate]) {\n\t\t\t\t\tmapping[depth] = candidate;\n\t\t\t\t\tused[candidate] = true;\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.isFeasible(\n\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tmapping,\n\t\t\t\t\t\t\tdepth,\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tmatch(depth + 1);\n\t\t\t\t\t}\n\t\t\t\t\tused[candidate] = false;\n\t\t\t\t\tmapping[depth] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmatch(0);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Feasibility check for current depth: preserve pattern edges\n\t * and edge labels if present\n\t */\n\tprivate isFeasible(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tmapping: Mapping,\n\t\tdepth: number,\n\t\tedgeLabelWildcardsSet: Set<string>\n\t): boolean {\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\n\t\t// Check that all edges in the current partial mapping are preserved\n\t\tfor (let i = 0; i < depth; i++) {\n\t\t\tif (pattern.adjacencyMatrix[depth][i]) {\n\t\t\t\tif (!target.adjacencyMatrix[mapping[depth]][mapping[i]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check edge labels if present\n\t\t\t\tif (\n\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t!edgeLabelWildcardsSet.has(depth + ',' + i) &&\n\t\t\t\t\tpattern.edgeLabels![depth][i] !==\n\t\t\t\t\t\ttarget.edgeLabels![mapping[depth]][mapping[i]]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pattern.adjacencyMatrix[i][depth]) {\n\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[depth]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check edge labels if present\n\t\t\t\tif (\n\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + depth) &&\n\t\t\t\t\tpattern.edgeLabels![i][depth] !==\n\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[depth]]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Verifies full structural consistency of the mapping\n\t */\n\tprivate checkCompatibility(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tmapping: Mapping,\n\t\tedgeLabelWildcardsSet: Set<string>\n\t): boolean {\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tfor (let j = 0; j < n; j++) {\n\t\t\t\tif (pattern.adjacencyMatrix[i][j]) {\n\t\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[j]]) {\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + j) &&\n\t\t\t\t\t\tpattern.edgeLabels![i][j] !==\n\t\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[j]]\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge label\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n","export class Automorphism {\r\n\tpublic readonly mappings: Map<number, number>;\r\n\tpublic readonly cycles: number[][] = [];\r\n\r\n\tconstructor(mappings: Map<number, number>) {\r\n\t\tthis.mappings = mappings;\r\n\t\tif (new Set(mappings.values()).size !== mappings.size) {\r\n\t\t\tthrow 'Automorphism is not bijective';\r\n\t\t}\r\n\t\tconst visited = new Set<number>();\r\n\t\tconst keys = [...mappings.keys()].sort();\r\n\t\tfor (const key of keys) {\r\n\t\t\tif (!visited.has(key)) {\r\n\t\t\t\tvisited.add(key);\r\n\t\t\t\tconst cycle = [key];\r\n\t\t\t\twhile (mappings.has(cycle[cycle.length - 1])) {\r\n\t\t\t\t\tconst value = mappings.get(cycle[cycle.length - 1])!;\r\n\t\t\t\t\tvisited.add(value);\r\n\t\t\t\t\tif (value !== cycle[0]) {\r\n\t\t\t\t\t\tcycle.push(value);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (cycle.length > 1) {\r\n\t\t\t\t\tthis.cycles.push(cycle);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic apply(x: number): number {\r\n\t\treturn this.mappings.get(x)!;\r\n\t}\r\n\r\n\t/**\r\n\t * Compose this automorphism (f) with another one (g): (f ∘ g)(x) = f(g(x))\r\n\t */\r\n\tpublic compose(g: Automorphism): Automorphism {\r\n\t\tconst h = new Map<number, number>();\r\n\t\tfor (const x of this.mappings.keys()) {\r\n\t\t\tconst gx = g.apply(x);\r\n\t\t\tconst fgx = this.apply(gx);\r\n\t\t\th.set(x, fgx);\r\n\t\t}\r\n\t\treturn new Automorphism(h);\r\n\t}\r\n\r\n\tpublic reverse(): Automorphism {\r\n\t\treturn new Automorphism(\r\n\t\t\tnew Map([...this.mappings.entries()].map(([k, v]) => [v, k]))\r\n\t\t);\r\n\t}\r\n\r\n\tpublic equals(g: Automorphism): boolean {\r\n\t\tfor (const key of this.mappings.keys()) {\r\n\t\t\tif (this.mappings.get(key)! !== g.mappings.get(key)!) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic isIdentity(): boolean {\r\n\t\tfor (const key of this.mappings.keys()) {\r\n\t\t\tif (this.mappings.get(key)! !== key) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic toString(): string {\r\n\t\tif (this.cycles.length === 0) {\r\n\t\t\treturn '()';\r\n\t\t}\r\n\t\treturn this.cycles\r\n\t\t\t.map((m) => `(${m.join(' ')})`)\r\n\t\t\t.sort()\r\n\t\t\t.join('');\r\n\t}\r\n}\r\n\r\nexport class AutomorphismGroup {\r\n\tpublic readonly generators: Automorphism[];\r\n\r\n\tconstructor(generators: Automorphism[], n: number) {\r\n\t\tif (generators.some((g) => g.isIdentity())) {\r\n\t\t\tthis.generators = [...generators];\r\n\t\t} else {\r\n\t\t\tconst identity = new Automorphism(\r\n\t\t\t\tnew Map(Array.from({length: n}, (_, i) => [i, i]))\r\n\t\t\t);\r\n\t\t\tthis.generators = [identity, ...generators];\r\n\t\t}\r\n\t}\r\n\r\n\tpublic orbitOf(x: number): number[] {\r\n\t\tconst orbit = new Set<number>();\r\n\t\torbit.add(x);\r\n\t\tfor (const aut of this.generators) {\r\n\t\t\torbit.add(aut.apply(x));\r\n\t\t}\r\n\t\treturn Array.from(orbit).sort();\r\n\t}\r\n\r\n\tpublic stabilizerOf(x: number): Automorphism[] {\r\n\t\treturn this.generators.filter((aut) => aut.apply(x) === x);\r\n\t}\r\n\r\n\tpublic stabilizerSizeOf(x: number): number {\r\n\t\treturn this.generators.reduce(\r\n\t\t\t(c, aut) => (c += aut.apply(x) === x ? 1 : 0),\r\n\t\t\t0\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Orbit size of x via Orbit–Stabilizer Theorem.\r\n\t */\r\n\tpublic orbitSizeOf(x: number): number {\r\n\t\treturn this.generators.length / this.stabilizerSizeOf(x);\r\n\t}\r\n\r\n\tpublic orbits(): number[][] {\r\n\t\tconst seen = new Set<number>();\r\n\t\tconst orbits: number[][] = [];\r\n\t\tfor (const g of this.generators[0].mappings.keys()) {\r\n\t\t\tif (!seen.has(g)) {\r\n\t\t\t\tconst orb = this.orbitOf(g);\r\n\t\t\t\torb.forEach((x) => seen.add(x));\r\n\t\t\t\torbits.push(orb);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn orbits;\r\n\t}\r\n\r\n\tpublic closure(): Automorphism[] {\r\n\t\tconst result: Automorphism[] = [];\r\n\t\tconst visited = new Set<string>();\r\n\t\tconst addIfUnvisited = (aut: Automorphism) => {\r\n\t\t\tconst key = aut.toString();\r\n\t\t\tif (!visited.has(key)) {\r\n\t\t\t\tresult.push(aut);\r\n\t\t\t\tvisited.add(key);\r\n\t\t\t}\r\n\t\t};\r\n\t\tconst queue = [\r\n\t\t\t...this.generators,\r\n\t\t\t...this.generators.map((g) => g.reverse()),\r\n\t\t];\r\n\t\tqueue.forEach((aut) => addIfUnvisited(aut));\r\n\t\twhile (queue.length > 0) {\r\n\t\t\tconst f = queue.pop()!;\r\n\t\t\tfor (const g of result) {\r\n\t\t\t\taddIfUnvisited(f.compose(g));\r\n\t\t\t\taddIfUnvisited(g.compose(f));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\tpublic toString(): string {\r\n\t\treturn '[' + this.generators.map((g) => g.toString()).join(', ') + ']';\r\n\t}\r\n}\r\n","import {Graph} from '..';\nimport {Automorphism, AutomorphismGroup} from '../Automorphism';\nimport {Mapping} from '../matching';\n\nexport type NodeKeySuffixGenerator = (\n\tgraph: Graph,\n\tnodeIndex: number\n) => string;\nexport type NodePropertiesMapper = (\n\tgraph: Graph,\n\tnodeIndex: number,\n\tnodeMapping: number[]\n) => Map<string, any> | undefined;\nexport type NodeLabelCanonKeyMapper = (\n\tgraph: Graph,\n\tnodeIndex: number\n) => string;\nexport type NodePropertiesCanonKeyMapper = (\n\tgraph: Graph,\n\tnodeIndex: number\n) => string;\n\n/**\n * Nauty graph canonicalization using the following graph properties\n * for ordering and selection:\n * - First, node cell membership is sorted ascending by \"outDegree|inDegree|label?\"\n * - Second, direct neighborhood cell memberships and optional edge labels are sorted\n *   ascending, concatenated, and used to further split cells.\n *   \"neighborCell_1;outEdgeLabel_1?;inEdgeLabel_1?|neighborCell_2;outEdgeLabel_2?;inEdgeLabel_2?|...\"\n *   New cell IDs of the split are assigned by descending key order.\n * - Target cell selection in the search tree is performed by selecting the leftmost (smallest) cell ID\n *   with at least two members.\n */\nexport class GraphCanon {\n\tpublic static readonly KEY_VERSION = 'v2';\n\tpublic static readonly DefaultNodeKeySuffixGenerator: NodeKeySuffixGenerator =\n\t\t(graph: Graph, nodeIndex: number) => {\n\t\t\treturn graph.labels ? graph.labels[nodeIndex] : '';\n\t\t};\n\tpublic static readonly DefaultNodePropertiesMapper: NodePropertiesMapper = (\n\t\tgraph: Graph,\n\t\tnodeIndex: number,\n\t\t_nodeMapping: number[]\n\t) => {\n\t\treturn graph.nodeProperties && graph.nodeProperties[nodeIndex]\n\t\t\t? new Map(graph.nodeProperties[nodeIndex])\n\t\t\t: undefined;\n\t};\n\tpublic static readonly DefaultNodeLabelCanonKeyMapper: NodeLabelCanonKeyMapper =\n\t\t(graph: Graph, nodeIndex: number) => {\n\t\t\treturn graph.labels ? graph.labels[nodeIndex] : '';\n\t\t};\n\tpublic static readonly DefaultNodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper =\n\t\t(_graph: Graph, _nodeIndex: number) => {\n\t\t\treturn '';\n\t\t};\n\n\tprivate readonly nodeCount: number;\n\tprivate readonly hasNodeLabels: boolean;\n\tprivate readonly hasNodeProperties: boolean;\n\tprivate readonly hasEdgeLabels: boolean;\n\tprivate readonly isSymmetric: boolean;\n\tprivate readonly graph: Graph;\n\tprivate readonly nodeNeighbors = new Map<number, number[]>();\n\tprivate readonly nodeKeys = new Map<number, string>();\n\tprivate readonly nodePropertiesMapper: NodePropertiesMapper;\n\tprivate readonly nodeLabelCanonKeyMapper: NodeLabelCanonKeyMapper;\n\tprivate readonly nodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper;\n\tprivate readonly graphStringBuilder: (graph: Graph) => string;\n\n\tpublic constructor(\n\t\tgraph: Graph,\n\t\tnodeKeySuffixGenerator: NodeKeySuffixGenerator = GraphCanon.DefaultNodeKeySuffixGenerator,\n\t\tnodePropertiesMapper: NodePropertiesMapper = GraphCanon.DefaultNodePropertiesMapper,\n\t\tnodeLabelCanonKeyMapper: NodeLabelCanonKeyMapper = GraphCanon.DefaultNodeLabelCanonKeyMapper,\n\t\tnodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper = GraphCanon.DefaultNodePropertiesCanonKeyMapper\n\t) {\n\t\tthis.graph = graph;\n\t\tthis.nodeCount = graph.adjacencyMatrix.length;\n\t\tthis.hasNodeLabels = graph.labels !== undefined;\n\t\tthis.hasNodeProperties = graph.nodeProperties !== undefined;\n\t\tthis.hasEdgeLabels = graph.edgeLabels !== undefined;\n\t\tthis.nodePropertiesMapper = nodePropertiesMapper;\n\t\tthis.nodeLabelCanonKeyMapper = nodeLabelCanonKeyMapper;\n\t\tthis.nodePropertiesCanonKeyMapper = nodePropertiesCanonKeyMapper;\n\t\tlet isSymmetric = true;\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\tconst neighbors = new Set<number>();\n\t\t\tlet inDegree = 0;\n\t\t\tlet outDegree = 0;\n\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\tconst isOut = graph.adjacencyMatrix[i][j];\n\t\t\t\tconst isIn = graph.adjacencyMatrix[j][i];\n\t\t\t\tif (isOut === 1) {\n\t\t\t\t\toutDegree++;\n\t\t\t\t\tneighbors.add(j);\n\t\t\t\t}\n\t\t\t\tif (isIn === 1) {\n\t\t\t\t\tinDegree++;\n\t\t\t\t\tneighbors.add(j);\n\t\t\t\t}\n\t\t\t\tif (isOut !== isIn) {\n\t\t\t\t\tisSymmetric = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.nodeNeighbors.set(i, [...neighbors]);\n\t\t\tconst nodeKey =\n\t\t\t\toutDegree + '|' + inDegree + '|' + nodeKeySuffixGenerator(graph, i);\n\t\t\tthis.nodeKeys.set(i, nodeKey);\n\t\t}\n\t\tthis.isSymmetric = isSymmetric;\n\t\t// Finally build the curried graph key function\n\t\tthis.graphStringBuilder = this.buildGraphStringCurry();\n\t}\n\n\t/**\n\t * Canonicalize the graph\n\t * @returns\n\t * 1. canonical graph representation\n\t * 2. graph key\n\t * 3. node mapping from the original to the canonical graph\n\t * 4. automorphisms\n\t */\n\tpublic canonicalize(): [Graph, string, Mapping, AutomorphismGroup] {\n\t\tconst nodeCells = new Array(this.nodeCount).fill(1);\n\t\tthis.partitionByPropertyKeys(nodeCells);\n\t\tconst partitions: Map<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpartitions: Map<number, number>[];\n\t\t\t\tautomorphisms: Map<string, Automorphism>;\n\t\t\t}\n\t\t> = new Map();\n\t\tconst prunedSubtrees = new Set<string>();\n\t\tthis.individualizeDFS(\n\t\t\tnodeCells,\n\t\t\t[],\n\t\t\tprunedSubtrees,\n\t\t\tthis.handleRepresentationCurry(partitions, prunedSubtrees)\n\t\t);\n\t\tconst lexSmallestKey = [...partitions.keys()].sort((a, b) =>\n\t\t\ta.localeCompare(b)\n\t\t)[0];\n\t\tconst partition = partitions.get(lexSmallestKey)!;\n\t\tconst smallestRepresentation = new Array(this.nodeCount);\n\t\tconst lexSmallestMapping = new Array(smallestRepresentation.length);\n\t\t[...partition.partitions[0].entries()].forEach(([c, i]) => {\n\t\t\tsmallestRepresentation[i] = c;\n\t\t\tlexSmallestMapping[c - 1] = i;\n\t\t});\n\t\tconst lexSmallestGraph = this.buildRepresentationGraph(\n\t\t\tsmallestRepresentation\n\t\t);\n\t\tconst allAutomorphisms = new Map<string, Automorphism>();\n\t\t[...partitions.values()].forEach((p) =>\n\t\t\t[...p.automorphisms.entries()].forEach(([key, aut]) =>\n\t\t\t\tallAutomorphisms.set(key, aut)\n\t\t\t)\n\t\t);\n\t\treturn [\n\t\t\tlexSmallestGraph,\n\t\t\tthis.buildGraphString(lexSmallestGraph),\n\t\t\tlexSmallestMapping,\n\t\t\tnew AutomorphismGroup([...allAutomorphisms.values()], this.nodeCount),\n\t\t];\n\t}\n\n\tprivate handleRepresentationCurry(\n\t\tpartitions: Map<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpartitions: Map<number, number>[];\n\t\t\t\tautomorphisms: Map<string, Automorphism>;\n\t\t\t}\n\t\t>,\n\t\tprunedSubtrees: Set<string>\n\t): (nodeCells: number[], suffix: number[]) => void {\n\t\tconst cellIds = Array.from({length: this.nodeCount}, (_, i) => i + 1);\n\t\treturn (repNodeCells, suffix) => {\n\t\t\t// Build the partition key for comparison with other partitions\n\t\t\tconst partition = new Map<number, number>();\n\t\t\trepNodeCells.forEach((c, i) => partition.set(c, i));\n\t\t\tconst partitionKey = cellIds\n\t\t\t\t.map((c) =>\n\t\t\t\t\tthis.nodeNeighbors\n\t\t\t\t\t\t.get(partition.get(c)!)!\n\t\t\t\t\t\t.map((n) => repNodeCells[n])\n\t\t\t\t\t\t.sort()\n\t\t\t\t\t\t.join(';')\n\t\t\t\t)\n\t\t\t\t.join('|');\n\t\t\tlet sameRepresentations = partitions.get(partitionKey);\n\t\t\tif (sameRepresentations === undefined) {\n\t\t\t\tsameRepresentations = {\n\t\t\t\t\tpartitions: [],\n\t\t\t\t\tautomorphisms: new Map(),\n\t\t\t\t};\n\t\t\t\tpartitions.set(partitionKey, sameRepresentations);\n\t\t\t}\n\n\t\t\tfor (const partition of sameRepresentations.partitions) {\n\t\t\t\tconst automorphismMap = new Map<number, number>();\n\t\t\t\tfor (let i = 0; i < repNodeCells.length; i++) {\n\t\t\t\t\tconst partitionIndex = partition.get(repNodeCells[i])!;\n\t\t\t\t\tautomorphismMap.set(i, partitionIndex);\n\t\t\t\t}\n\t\t\t\tconst automorphism = new Automorphism(automorphismMap);\n\t\t\t\tconst key = automorphism.toString();\n\t\t\t\tif (!sameRepresentations.automorphisms.has(key)) {\n\t\t\t\t\tsameRepresentations.automorphisms.set(key, automorphism);\n\t\t\t\t\tfor (const x of automorphism.mappings) {\n\t\t\t\t\t\tif (x[0] === x[1]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < suffix.length; i++) {\n\t\t\t\t\t\t\tif (suffix[i] === x[0]) {\n\t\t\t\t\t\t\t\tprunedSubtrees.add([...suffix.slice(0, i), x[1]].join('|'));\n\t\t\t\t\t\t\t} else if (suffix[i] === x[1]) {\n\t\t\t\t\t\t\t\tprunedSubtrees.add([...suffix.slice(0, i), x[0]].join('|'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Save the representation\n\t\t\tsameRepresentations.partitions.push(partition);\n\t\t};\n\t}\n\n\t/**\n\t * Calculates only the automorphisms of the graph.\n\t *\n\t * Note: if any of the graph, graph key, or node mapping are needed as well,\n\t * use the canonicalize() function.\n\t */\n\tpublic aut(): AutomorphismGroup {\n\t\tconst nodeCells = new Array(this.nodeCount).fill(1);\n\t\tthis.partitionByPropertyKeys(nodeCells);\n\t\tconst partitions: Map<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpartitions: Map<number, number>[];\n\t\t\t\tautomorphisms: Map<string, Automorphism>;\n\t\t\t}\n\t\t> = new Map();\n\t\tconst prunedSubtrees = new Set<string>();\n\t\tthis.individualizeDFS(\n\t\t\tnodeCells,\n\t\t\t[],\n\t\t\tprunedSubtrees,\n\t\t\tthis.handleRepresentationCurry(partitions, prunedSubtrees)\n\t\t);\n\t\tconst allAutomorphisms = new Map<string, Automorphism>();\n\t\t[...partitions.values()].forEach((p) =>\n\t\t\t[...p.automorphisms.entries()].forEach(([key, aut]) =>\n\t\t\t\tallAutomorphisms.set(key, aut)\n\t\t\t)\n\t\t);\n\t\treturn new AutomorphismGroup(\n\t\t\t[...allAutomorphisms.values()],\n\t\t\tthis.nodeCount\n\t\t);\n\t}\n\n\tprivate partitionByPropertyKeys(nodeCells: number[]) {\n\t\tconst propertyKeyNodeIndices = new Map<string, number[]>();\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\tconst key = this.nodeKeys.get(i)!;\n\t\t\tif (propertyKeyNodeIndices.has(key)) {\n\t\t\t\tpropertyKeyNodeIndices.get(key)!.push(i);\n\t\t\t} else {\n\t\t\t\tpropertyKeyNodeIndices.set(key, [i]);\n\t\t\t}\n\t\t}\n\t\tlet nextFreeCell = 1;\n\t\tArray.from(propertyKeyNodeIndices.keys())\n\t\t\t.sort((a, b) => a.localeCompare(b))\n\t\t\t.forEach((k) => {\n\t\t\t\tconst nodesInNextCell = propertyKeyNodeIndices.get(k)!;\n\t\t\t\tnodesInNextCell.forEach((i) => (nodeCells[i] = nextFreeCell));\n\t\t\t\tnextFreeCell += nodesInNextCell.length;\n\t\t\t});\n\t}\n\n\tprivate isCanon(nodeCells: number[]): boolean {\n\t\treturn new Set<number>(nodeCells).size === this.nodeCount;\n\t}\n\n\tprivate individualizeDFS(\n\t\tnodeCells: number[],\n\t\tsuffix: number[],\n\t\tprunedSubtrees: Set<string>,\n\t\thandleRepresentation: (nodeCells: number[], suffix: number[]) => void\n\t) {\n\t\tif (this.isCanon(nodeCells)) {\n\t\t\thandleRepresentation(nodeCells, suffix);\n\t\t\treturn;\n\t\t}\n\t\tthis.individualizationRefinement(nodeCells);\n\t\tif (this.isCanon(nodeCells)) {\n\t\t\thandleRepresentation(nodeCells, suffix);\n\t\t\treturn;\n\t\t}\n\t\tconst cellToBreak = this.getCellToBreak(nodeCells);\n\t\tfor (const n of cellToBreak[1]) {\n\t\t\tnodeCells[n] = cellToBreak[0] + 1;\n\t\t}\n\t\tfor (const nodeId of cellToBreak[1]) {\n\t\t\t// Check if subtree is pruned\n\t\t\tconst newSuffix = [...suffix, nodeId];\n\t\t\tif (prunedSubtrees.has(newSuffix.join('|'))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnodeCells[nodeId] = cellToBreak[0];\n\t\t\tthis.individualizeDFS(\n\t\t\t\t[...nodeCells],\n\t\t\t\tnewSuffix,\n\t\t\t\tprunedSubtrees,\n\t\t\t\thandleRepresentation\n\t\t\t);\n\t\t\tnodeCells[nodeId] = cellToBreak[0] + 1;\n\t\t}\n\t}\n\n\tprivate individualizationRefinement(nodeCells: number[]) {\n\t\tlet isEquitable = false;\n\t\twhile (!isEquitable) {\n\t\t\tisEquitable = true;\n\t\t\t// Build signature for each node\n\t\t\tconst signatures: string[] = nodeCells.map((_, i) => {\n\t\t\t\tconst neighborCells = this.nodeNeighbors.get(i)!.map((n) => {\n\t\t\t\t\tif (this.hasEdgeLabels) {\n\t\t\t\t\t\tconst edgeLabels = this.graph.edgeLabels!;\n\t\t\t\t\t\tif (this.isSymmetric) {\n\t\t\t\t\t\t\treturn `${nodeCells[n]};${edgeLabels[i][n]}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `${nodeCells[n]};${edgeLabels[i][n]};${edgeLabels[n][i]}`;\n\t\t\t\t\t}\n\t\t\t\t\treturn nodeCells[n].toString();\n\t\t\t\t});\n\t\t\t\treturn neighborCells.sort().join('|');\n\t\t\t});\n\t\t\t// Group by current cell and signature\n\t\t\tconst partitionMap = new Map<number, Map<string, number[]>>();\n\t\t\tsignatures.forEach((signature, nodeIndex) => {\n\t\t\t\tconst cell = nodeCells[nodeIndex];\n\t\t\t\tlet cellMap = partitionMap.get(cell);\n\t\t\t\tif (cellMap === undefined) {\n\t\t\t\t\tcellMap = new Map();\n\t\t\t\t\tpartitionMap.set(cell, cellMap);\n\t\t\t\t}\n\t\t\t\tlet nodeIndices = cellMap.get(signature);\n\t\t\t\tif (nodeIndices === undefined) {\n\t\t\t\t\tnodeIndices = [];\n\t\t\t\t\tcellMap.set(signature, nodeIndices);\n\t\t\t\t}\n\t\t\t\tnodeIndices.push(nodeIndex);\n\t\t\t});\n\t\t\t// Partition cells based on signature blocks\n\t\t\tfor (let cellId = 1; cellId <= this.nodeCount; cellId++) {\n\t\t\t\tconst value = partitionMap.get(cellId);\n\t\t\t\tif (value === undefined || value.size < 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisEquitable = false;\n\t\t\t\t// Sort block signatures descending\n\t\t\t\tconst blockKeys = [...value.keys()].sort((a, b) => b.localeCompare(a));\n\t\t\t\tlet newCellId = cellId;\n\t\t\t\tfor (const key of blockKeys) {\n\t\t\t\t\tconst nodes = value.get(key)!;\n\t\t\t\t\tnodes.forEach((n) => (nodeCells[n] = newCellId));\n\t\t\t\t\tnewCellId += nodes.length;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getCellToBreak(nodeCells: number[]): [number, number[]] {\n\t\tconst cells: number[][] = Array.from({length: nodeCells.length}, () => []);\n\t\tnodeCells.forEach((c, i) => cells[c - 1].push(i));\n\t\tfor (let i = 0; i < cells.length; i++) {\n\t\t\tif (cells[i].length > 1) {\n\t\t\t\treturn [i + 1, cells[i]];\n\t\t\t}\n\t\t}\n\t\treturn [1, cells[0]];\n\t}\n\n\tprivate buildRepresentationGraph(nodeCells: number[]): Graph {\n\t\tconst nodeMapping = nodeCells.map((c) => c - 1);\n\t\tconst graph: Graph = {\n\t\t\tadjacencyMatrix: Array.from(\n\t\t\t\t{length: this.nodeCount},\n\t\t\t\t() => new Array(this.nodeCount)\n\t\t\t),\n\t\t};\n\t\tif (this.isSymmetric) {\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\tconst mi = nodeMapping[i];\n\t\t\t\tconst row = this.graph.adjacencyMatrix[i];\n\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\n\t\t\t\t\tgraph.adjacencyMatrix[mi][nodeMapping[j]] = row[j];\n\t\t\t\t\tgraph.adjacencyMatrix[nodeMapping[j]][mi] = row[j];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\tconst mi = nodeMapping[i];\n\t\t\t\tconst row = this.graph.adjacencyMatrix[i];\n\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\t\tgraph.adjacencyMatrix[mi][nodeMapping[j]] = row[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.hasNodeLabels) {\n\t\t\tgraph.labels = new Array(this.nodeCount);\n\t\t\tnodeMapping.forEach((c, i) => (graph.labels![c] = this.graph.labels![i]));\n\t\t}\n\t\tif (this.hasNodeProperties) {\n\t\t\tgraph.nodeProperties = new Array(this.nodeCount);\n\t\t\tnodeMapping.forEach(\n\t\t\t\t(c, i) =>\n\t\t\t\t\t(graph.nodeProperties![c] = this.nodePropertiesMapper(\n\t\t\t\t\t\tthis.graph,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\tnodeMapping\n\t\t\t\t\t))\n\t\t\t);\n\t\t}\n\t\tif (this.hasEdgeLabels) {\n\t\t\tgraph.edgeLabels = Array.from(\n\t\t\t\t{length: this.nodeCount},\n\t\t\t\t() => new Array(this.nodeCount)\n\t\t\t);\n\t\t\tif (this.isSymmetric) {\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\t\tconst mi = nodeMapping[i];\n\t\t\t\t\tconst row = this.graph.edgeLabels![i];\n\t\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\n\t\t\t\t\t\tgraph.edgeLabels[mi][nodeMapping[j]] = row[j];\n\t\t\t\t\t\tgraph.edgeLabels[nodeMapping[j]][mi] = row[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\t\tconst mi = nodeMapping[i];\n\t\t\t\t\tconst row = this.graph.edgeLabels![i];\n\t\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\t\t\tgraph.edgeLabels[mi][nodeMapping[j]] = row[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\n\tprivate buildGraphStringCurry() {\n\t\tconst edgeCallback = this.hasEdgeLabels\n\t\t\t? (graph: Graph, i: number, j: number) =>\n\t\t\t\t\t`${i}-${graph.edgeLabels![i][j]}-${j}`\n\t\t\t: (_: Graph, i: number, j: number) => `${i}-${j}`;\n\t\tconst nodePropertyCallback = this.hasNodeProperties\n\t\t\t? (graph: Graph, i: number): string => {\n\t\t\t\t\tconst nodePropertyCanonKey = this.nodePropertiesCanonKeyMapper(\n\t\t\t\t\t\tgraph,\n\t\t\t\t\t\ti\n\t\t\t\t\t);\n\t\t\t\t\treturn nodePropertyCanonKey.length > 0\n\t\t\t\t\t\t? `{${nodePropertyCanonKey}}`\n\t\t\t\t\t\t: '';\n\t\t\t\t}\n\t\t\t: (_graph: Graph, _i: number): string => '';\n\t\tconst nodeCallback = this.hasNodeLabels\n\t\t\t? (graph: Graph): string =>\n\t\t\t\t\t';' +\n\t\t\t\t\tgraph\n\t\t\t\t\t\t.labels!.map(\n\t\t\t\t\t\t\t(_, i) =>\n\t\t\t\t\t\t\t\tthis.nodeLabelCanonKeyMapper(graph, i) +\n\t\t\t\t\t\t\t\tnodePropertyCallback(graph, i)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.join('|')\n\t\t\t: this.hasNodeProperties\n\t\t\t\t? (graph: Graph): string =>\n\t\t\t\t\t\t';' +\n\t\t\t\t\t\tgraph\n\t\t\t\t\t\t\t.nodeProperties!.map((_, i) =>\n\t\t\t\t\t\t\t\tthis.nodePropertiesCanonKeyMapper(graph, i)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.join('|')\n\t\t\t\t: (_: Graph): string => '';\n\n\t\tif (this.isSymmetric) {\n\t\t\treturn (graph: Graph): string => {\n\t\t\t\tconst edges = [];\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\t\tconst row = graph.adjacencyMatrix[i];\n\t\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\n\t\t\t\t\t\tif (row[j] === 1) {\n\t\t\t\t\t\t\tedges.push(edgeCallback(graph, i, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn (\n\t\t\t\t\tGraphCanon.KEY_VERSION +\n\t\t\t\t\t';' +\n\t\t\t\t\tgraph.adjacencyMatrix.length +\n\t\t\t\t\t';sym;' +\n\t\t\t\t\tedges.join('|') +\n\t\t\t\t\tnodeCallback(graph)\n\t\t\t\t);\n\t\t\t};\n\t\t}\n\t\treturn (graph: Graph): string => {\n\t\t\tconst edges = [];\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\tconst row = graph.adjacencyMatrix[i];\n\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\t\tif (row[j] === 1) {\n\t\t\t\t\t\tedges.push(edgeCallback(graph, i, j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (\n\t\t\t\tGraphCanon.KEY_VERSION +\n\t\t\t\t';' +\n\t\t\t\tgraph.adjacencyMatrix.length +\n\t\t\t\t';' +\n\t\t\t\tedges.join('|') +\n\t\t\t\tnodeCallback(graph)\n\t\t\t);\n\t\t};\n\t}\n\n\tpublic buildGraphString(graph: Graph): string {\n\t\treturn this.graphStringBuilder(graph);\n\t}\n}\n","import {Graph} from '.';\r\n\r\nexport class ConnectedComponents {\r\n\tpublic static find(graph: Graph): number[][] {\r\n\t\tconst result: number[][] = [];\r\n\t\tconst visited = new Set<number>();\r\n\r\n\t\tconst dfs = (node: number, component: number[]) => {\r\n\t\t\tvisited.add(node);\r\n\t\t\tcomponent.push(node);\r\n\t\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tgraph.adjacencyMatrix[node][i] === 1 ||\r\n\t\t\t\t\tgraph.adjacencyMatrix[i][node] === 1\r\n\t\t\t\t) {\r\n\t\t\t\t\tif (!visited.has(i)) {\r\n\t\t\t\t\t\tdfs(i, component);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\tif (!visited.has(i)) {\r\n\t\t\t\tconst component: number[] = [];\r\n\t\t\t\tdfs(i, component);\r\n\t\t\t\tresult.push(component);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n","export * as matching from './matching';\r\nexport * as canon from './canon';\r\nexport * from './ConnectedComponents';\r\n\r\nexport interface Graph {\r\n\t/**\r\n\t * N x N adjacency matrix of the graph. Must be symmetric if directed is true.\r\n\t */\r\n\tadjacencyMatrix: number[][];\r\n\t/**\r\n\t * Optional node labels\r\n\t */\r\n\tlabels?: string[];\r\n\t/**\r\n\t * Optional node properties\r\n\t */\r\n\tnodeProperties?: (Map<string, any> | undefined)[];\r\n\t/**\r\n\t * Optional edge labels\r\n\t */\r\n\tedgeLabels?: string[][];\r\n}\r\n\r\nexport function symmetricGraphToDIMACS(graph: Graph): string {\r\n\tconst n = graph.adjacencyMatrix.length;\r\n\tlet edges: string[] = [];\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tfor (let j = i + 1; j < n; j++) {\r\n\t\t\tif (graph.adjacencyMatrix[i][j] !== 0) {\r\n\t\t\t\tedges.push(`e ${i + 1} ${j + 1}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn [`p edge ${n} ${edges.length}`, ...edges].join('\\n');\r\n}\r\n"],"names":["GraphMatcher","UllmannGraphMatcher","pattern","target","nodeLabelWildcards","edgeLabelWildcards","partialMapping","n","m","isLabeled","used","mapping","nodeLabelWildcardsSet","edgeLabelWildcardsSet","patternInDegrees","patternOutDegrees","targetInDegrees","targetOutDegrees","domains","pd","i","td","j","match","depth","candidate","b","row","_","a","results","isEdgeLabeled","Automorphism","mappings","__publicField","visited","keys","key","cycle","value","x","g","h","gx","fgx","k","v","AutomorphismGroup","generators","identity","orbit","aut","c","seen","orbits","orb","result","addIfUnvisited","queue","f","_GraphCanon","graph","nodeKeySuffixGenerator","nodePropertiesMapper","nodeLabelCanonKeyMapper","nodePropertiesCanonKeyMapper","isSymmetric","neighbors","inDegree","outDegree","isOut","isIn","nodeKey","nodeCells","partitions","prunedSubtrees","lexSmallestKey","partition","smallestRepresentation","lexSmallestMapping","lexSmallestGraph","allAutomorphisms","p","cellIds","repNodeCells","suffix","partitionKey","sameRepresentations","automorphismMap","partitionIndex","automorphism","propertyKeyNodeIndices","nextFreeCell","nodesInNextCell","handleRepresentation","cellToBreak","nodeId","newSuffix","isEquitable","signatures","edgeLabels","partitionMap","signature","nodeIndex","cell","cellMap","nodeIndices","cellId","blockKeys","newCellId","nodes","cells","nodeMapping","mi","edgeCallback","nodePropertyCallback","nodePropertyCanonKey","_graph","_i","nodeCallback","edges","_nodeMapping","_nodeIndex","GraphCanon","ConnectedComponents","dfs","node","component","symmetricGraphToDIMACS"],"mappings":"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"}