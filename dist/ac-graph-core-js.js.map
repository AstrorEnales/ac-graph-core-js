{"version":3,"file":"ac-graph-core-js.js","sources":["../src/graph/matching/GraphMatcher.ts","../src/graph/matching/UllmannGraphMatcher.ts","../src/graph/Automorphism.ts","../src/graph/canon/GraphCanon.ts","../src/graph/ConnectedComponents.ts","../src/graph/index.ts"],"sourcesContent":["import {Mapping} from '.';\r\nimport {Graph} from '..';\r\n\r\nexport abstract class GraphMatcher {\r\n\t/**\r\n\t * Subgraph isomorphism check\r\n\t * @param pattern Pattern graph adjacency matrix\r\n\t * @param target Target graph adjacency matrix\r\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation.\r\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation. Encoded\r\n\t * as \"sourceIndex + ',' + targetIndex\".\r\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\r\n\t * find solutions containing this mapping. The array needs to follow the\r\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\r\n\t * are represented by -1.\r\n\t */\r\n\tpublic abstract isSubgraphIsomorphic(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tnodeLabelWildcards: number[],\r\n\t\tedgeLabelWildcards: string[],\r\n\t\tpartialMapping: number[] | null\r\n\t): boolean;\r\n\r\n\t/**\r\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\r\n\t * including symmetries\r\n\t * @param pattern Pattern graph adjacency matrix\r\n\t * @param target Target graph adjacency matrix\r\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation.\r\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation. Encoded\r\n\t * as \"sourceIndex + ',' + targetIndex\".\r\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\r\n\t * find solutions containing this mapping. The array needs to follow the\r\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\r\n\t * are represented by -1.\r\n\t */\r\n\tpublic abstract findAllSubgraphMonomorphisms(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tnodeLabelWildcards: number[],\r\n\t\tedgeLabelWildcards: string[],\r\n\t\tpartialMapping: number[] | null\r\n\t): Mapping[];\r\n}\r\n","import {Mapping} from '.';\r\nimport {Graph} from '..';\r\nimport {GraphMatcher} from './GraphMatcher';\r\n\r\nexport class UllmannGraphMatcher extends GraphMatcher {\r\n\t/**\r\n\t * Subgraph isomorphism check\r\n\t * @param pattern Pattern graph adjacency matrix\r\n\t * @param target Target graph adjacency matrix\r\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation.\r\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation. Encoded\r\n\t * as \"sourceIndex + ',' + targetIndex\".\r\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\r\n\t * find solutions containing this mapping. The array needs to follow the\r\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\r\n\t * are represented by -1.\r\n\t */\r\n\tpublic override isSubgraphIsomorphic(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tnodeLabelWildcards: number[] = [],\r\n\t\tedgeLabelWildcards: string[] = [],\r\n\t\tpartialMapping: number[] | null = null\r\n\t): boolean {\r\n\t\t// Number of nodes in the pattern graph\r\n\t\tconst n = pattern.adjacencyMatrix.length;\r\n\t\t// Number of nodes in the target graph\r\n\t\tconst m = target.adjacencyMatrix.length;\r\n\t\t// If pattern is larger than target, no mapping is possible\r\n\t\tif (n > m) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (partialMapping === null) {\r\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\r\n\t\t}\r\n\t\tconst isLabeled = pattern.labels && target.labels;\r\n\t\t// Track which target nodes are already used in the mapping\r\n\t\tconst used = Array(m).fill(false);\r\n\t\tconst mapping = Array(n).fill(-1);\r\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\r\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\r\n\t\t// Pre-compute degrees for pattern and target nodes\r\n\t\tconst [\r\n\t\t\tpatternInDegrees,\r\n\t\t\tpatternOutDegrees,\r\n\t\t\ttargetInDegrees,\r\n\t\t\ttargetOutDegrees,\r\n\t\t] = this.getInOutDegrees(pattern, target);\r\n\t\t// Pre-compute candidate domains for pattern nodes based on degree\r\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\r\n\t\t\ttargetInDegrees\r\n\t\t\t\t.map((td, j) => {\r\n\t\t\t\t\treturn td >= pd &&\r\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\r\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\r\n\t\t\t\t\t\t(!isLabeled ||\r\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\r\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\r\n\t\t\t\t\t\t? j\r\n\t\t\t\t\t\t: -1;\r\n\t\t\t\t})\r\n\t\t\t\t.filter((j) => j !== -1)\r\n\t\t);\r\n\t\t// Recursive backtracking function to try all injective mappings\r\n\t\tconst match = (depth: number): boolean => {\r\n\t\t\tif (depth === n) {\r\n\t\t\t\treturn this.checkCompatibility(\r\n\t\t\t\t\tpattern,\r\n\t\t\t\t\ttarget,\r\n\t\t\t\t\tmapping,\r\n\t\t\t\t\tedgeLabelWildcardsSet\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tfor (const candidate of domains[depth]) {\r\n\t\t\t\tif (!used[candidate]) {\r\n\t\t\t\t\tmapping[depth] = candidate;\r\n\t\t\t\t\tused[candidate] = true;\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tthis.isFeasible(\r\n\t\t\t\t\t\t\tpattern,\r\n\t\t\t\t\t\t\ttarget,\r\n\t\t\t\t\t\t\tmapping,\r\n\t\t\t\t\t\t\tdepth,\r\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\r\n\t\t\t\t\t\t) &&\r\n\t\t\t\t\t\tmatch(depth + 1)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Backtrack\r\n\t\t\t\t\tused[candidate] = false;\r\n\t\t\t\t\tmapping[depth] = -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\treturn match(0);\r\n\t}\r\n\r\n\tprivate getInOutDegrees(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph\r\n\t): [number[], number[], number[], number[]] {\r\n\t\tconst patternInDegrees = pattern.adjacencyMatrix.map((r) =>\r\n\t\t\tr.reduce((a, b) => a + b, 0)\r\n\t\t);\r\n\t\tconst patternOutDegrees: number[] = [];\r\n\t\tconst targetInDegrees = target.adjacencyMatrix.map((r) =>\r\n\t\t\tr.reduce((a, b) => a + b, 0)\r\n\t\t);\r\n\t\tconst targetOutDegrees: number[] = [];\r\n\t\tpattern.adjacencyMatrix.forEach((row, i) => {\r\n\t\t\tpatternOutDegrees.push(\r\n\t\t\t\trow\r\n\t\t\t\t\t.map((_, j) => pattern.adjacencyMatrix[j][i])\r\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\r\n\t\t\t);\r\n\t\t});\r\n\t\ttarget.adjacencyMatrix.forEach((row, i) => {\r\n\t\t\ttargetOutDegrees.push(\r\n\t\t\t\trow\r\n\t\t\t\t\t.map((_, j) => target.adjacencyMatrix[j][i])\r\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\r\n\t\t\t);\r\n\t\t});\r\n\t\treturn [\r\n\t\t\tpatternInDegrees,\r\n\t\t\tpatternOutDegrees,\r\n\t\t\ttargetInDegrees,\r\n\t\t\ttargetOutDegrees,\r\n\t\t];\r\n\t}\r\n\r\n\t/**\r\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\r\n\t * including symmetries\r\n\t * @param pattern Pattern graph adjacency matrix\r\n\t * @param target Target graph adjacency matrix\r\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation.\r\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\r\n\t * for labelled graphs. Their label is ignored during validation. Encoded\r\n\t * as \"sourceIndex + ',' + targetIndex\".\r\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\r\n\t * find solutions containing this mapping. The array needs to follow the\r\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\r\n\t * are represented by -1.\r\n\t */\r\n\tpublic override findAllSubgraphMonomorphisms(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tnodeLabelWildcards: number[] = [],\r\n\t\tedgeLabelWildcards: string[] = [],\r\n\t\tpartialMapping: number[] | null = null\r\n\t): Mapping[] {\r\n\t\tconst n = pattern.adjacencyMatrix.length;\r\n\t\tconst m = target.adjacencyMatrix.length;\r\n\t\tconst results: Mapping[] = [];\r\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\r\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\r\n\t\tif (n > m) {\r\n\t\t\treturn results;\r\n\t\t}\r\n\t\tif (partialMapping === null) {\r\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\r\n\t\t}\r\n\t\tconst isLabeled = pattern.labels && target.labels;\r\n\t\tconst used = Array(m).fill(false);\r\n\t\tconst mapping = Array(n).fill(-1);\r\n\t\tconst [\r\n\t\t\tpatternInDegrees,\r\n\t\t\tpatternOutDegrees,\r\n\t\t\ttargetInDegrees,\r\n\t\t\ttargetOutDegrees,\r\n\t\t] = this.getInOutDegrees(pattern, target);\r\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\r\n\t\t\ttargetInDegrees\r\n\t\t\t\t.map((td, j) => {\r\n\t\t\t\t\treturn td >= pd &&\r\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\r\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\r\n\t\t\t\t\t\t(!isLabeled ||\r\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\r\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\r\n\t\t\t\t\t\t? j\r\n\t\t\t\t\t\t: -1;\r\n\t\t\t\t})\r\n\t\t\t\t.filter((j) => j !== -1)\r\n\t\t);\r\n\t\tconst match = (depth: number): void => {\r\n\t\t\tif (depth === n) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tthis.checkCompatibility(\r\n\t\t\t\t\t\tpattern,\r\n\t\t\t\t\t\ttarget,\r\n\t\t\t\t\t\tmapping,\r\n\t\t\t\t\t\tedgeLabelWildcardsSet\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\t\t\t\t\tresults.push([...mapping]);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tfor (const candidate of domains[depth]) {\r\n\t\t\t\tif (!used[candidate]) {\r\n\t\t\t\t\tmapping[depth] = candidate;\r\n\t\t\t\t\tused[candidate] = true;\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tthis.isFeasible(\r\n\t\t\t\t\t\t\tpattern,\r\n\t\t\t\t\t\t\ttarget,\r\n\t\t\t\t\t\t\tmapping,\r\n\t\t\t\t\t\t\tdepth,\r\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tmatch(depth + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tused[candidate] = false;\r\n\t\t\t\t\tmapping[depth] = -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tmatch(0);\r\n\t\treturn results;\r\n\t}\r\n\r\n\t/**\r\n\t * Feasibility check for current depth: preserve pattern edges\r\n\t * and edge labels if present\r\n\t */\r\n\tprivate isFeasible(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tmapping: Mapping,\r\n\t\tdepth: number,\r\n\t\tedgeLabelWildcardsSet: Set<string>\r\n\t): boolean {\r\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\r\n\t\t// Check that all edges in the current partial mapping are preserved\r\n\t\tfor (let i = 0; i < depth; i++) {\r\n\t\t\tif (pattern.adjacencyMatrix[depth][i]) {\r\n\t\t\t\tif (!target.adjacencyMatrix[mapping[depth]][mapping[i]]) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t// Check edge labels if present\r\n\t\t\t\tif (\r\n\t\t\t\t\tisEdgeLabeled &&\r\n\t\t\t\t\t!edgeLabelWildcardsSet.has(depth + ',' + i) &&\r\n\t\t\t\t\tpattern.edgeLabels![depth][i] !==\r\n\t\t\t\t\t\ttarget.edgeLabels![mapping[depth]][mapping[i]]\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (pattern.adjacencyMatrix[i][depth]) {\r\n\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[depth]]) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t// Check edge labels if present\r\n\t\t\t\tif (\r\n\t\t\t\t\tisEdgeLabeled &&\r\n\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + depth) &&\r\n\t\t\t\t\tpattern.edgeLabels![i][depth] !==\r\n\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[depth]]\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Verifies full structural consistency of the mapping\r\n\t */\r\n\tprivate checkCompatibility(\r\n\t\tpattern: Graph,\r\n\t\ttarget: Graph,\r\n\t\tmapping: Mapping,\r\n\t\tedgeLabelWildcardsSet: Set<string>\r\n\t): boolean {\r\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\r\n\t\tconst n = pattern.adjacencyMatrix.length;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tfor (let j = 0; j < n; j++) {\r\n\t\t\t\tif (pattern.adjacencyMatrix[i][j]) {\r\n\t\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[j]]) {\r\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tisEdgeLabeled &&\r\n\t\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + j) &&\r\n\t\t\t\t\t\tpattern.edgeLabels![i][j] !==\r\n\t\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[j]]\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge label\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n}\r\n","export class Automorphism {\n\tpublic readonly mappings: Map<number, number>;\n\tpublic readonly cycles: number[][] = [];\n\n\tconstructor(mappings: Map<number, number>) {\n\t\tthis.mappings = mappings;\n\t\tif (new Set(mappings.values()).size !== mappings.size) {\n\t\t\tthrow 'Automorphism is not bijective';\n\t\t}\n\t\tconst visited = new Set<number>();\n\t\tconst keys = [...mappings.keys()].sort();\n\t\tfor (const key of keys) {\n\t\t\tif (!visited.has(key)) {\n\t\t\t\tvisited.add(key);\n\t\t\t\tconst cycle = [key];\n\t\t\t\twhile (mappings.has(cycle[cycle.length - 1])) {\n\t\t\t\t\tconst value = mappings.get(cycle[cycle.length - 1])!;\n\t\t\t\t\tvisited.add(value);\n\t\t\t\t\tif (value !== cycle[0]) {\n\t\t\t\t\t\tcycle.push(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cycle.length > 1) {\n\t\t\t\t\tthis.cycles.push(cycle);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic apply(x: number): number {\n\t\treturn this.mappings.get(x)!;\n\t}\n\n\t/**\n\t * Compose this automorphism (f) with another one (g): (f ∘ g)(x) = f(g(x))\n\t */\n\tpublic compose(g: Automorphism): Automorphism {\n\t\tconst h = new Map<number, number>();\n\t\tfor (const x of this.mappings.keys()) {\n\t\t\tconst gx = g.apply(x);\n\t\t\tconst fgx = this.apply(gx);\n\t\t\th.set(x, fgx);\n\t\t}\n\t\treturn new Automorphism(h);\n\t}\n\n\tpublic reverse(): Automorphism {\n\t\treturn new Automorphism(\n\t\t\tnew Map([...this.mappings.entries()].map(([k, v]) => [v, k]))\n\t\t);\n\t}\n\n\tpublic equals(g: Automorphism): boolean {\n\t\tfor (const key of this.mappings.keys()) {\n\t\t\tif (this.mappings.get(key)! !== g.mappings.get(key)!) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic isIdentity(): boolean {\n\t\tfor (const key of this.mappings.keys()) {\n\t\t\tif (this.mappings.get(key)! !== key) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic toString(): string {\n\t\tif (this.cycles.length === 0) {\n\t\t\treturn '()';\n\t\t}\n\t\treturn this.cycles\n\t\t\t.map((m) => `(${m.join(' ')})`)\n\t\t\t.sort()\n\t\t\t.join('');\n\t}\n}\n\nexport class AutomorphismGroup {\n\tpublic readonly generators: Automorphism[];\n\n\tconstructor(generators: Automorphism[], n: number) {\n\t\tif (generators.some((g) => g.isIdentity())) {\n\t\t\tthis.generators = [...generators];\n\t\t} else {\n\t\t\tconst identity = new Automorphism(\n\t\t\t\tnew Map(Array.from({length: n}, (_, i) => [i, i]))\n\t\t\t);\n\t\t\tthis.generators = [identity, ...generators];\n\t\t}\n\t}\n\n\tpublic orbitOf(x: number): number[] {\n\t\tconst orbit = new Set<number>();\n\t\torbit.add(x);\n\t\tfor (const aut of this.generators) {\n\t\t\torbit.add(aut.apply(x));\n\t\t}\n\t\treturn Array.from(orbit).sort();\n\t}\n\n\tpublic stabilizerOf(x: number): Automorphism[] {\n\t\treturn this.generators.filter((aut) => aut.apply(x) === x);\n\t}\n\n\tpublic stabilizerSizeOf(x: number): number {\n\t\treturn this.generators.reduce(\n\t\t\t(c, aut) => (c += aut.apply(x) === x ? 1 : 0),\n\t\t\t0\n\t\t);\n\t}\n\n\t/**\n\t * Orbit size of x via Orbit–Stabilizer Theorem.\n\t */\n\tpublic orbitSizeOf(x: number): number {\n\t\treturn this.generators.length / this.stabilizerSizeOf(x);\n\t}\n\n\tpublic orbits(): number[][] {\n\t\tconst seen = new Set<number>();\n\t\tconst orbits: number[][] = [];\n\t\tfor (const g of this.generators[0].mappings.keys()) {\n\t\t\tif (!seen.has(g)) {\n\t\t\t\tconst orb = this.orbitOf(g);\n\t\t\t\torb.forEach((x) => seen.add(x));\n\t\t\t\torbits.push(orb);\n\t\t\t}\n\t\t}\n\t\treturn orbits;\n\t}\n\n\tpublic closure(): Automorphism[] {\n\t\tconst result: Automorphism[] = [];\n\t\tconst visited = new Set<string>();\n\t\tconst addIfUnvisited = (aut: Automorphism) => {\n\t\t\tconst key = aut.toString();\n\t\t\tif (!visited.has(key)) {\n\t\t\t\tresult.push(aut);\n\t\t\t\tvisited.add(key);\n\t\t\t}\n\t\t};\n\t\tconst queue = [\n\t\t\t...this.generators,\n\t\t\t...this.generators.map((g) => g.reverse()),\n\t\t];\n\t\tqueue.forEach((aut) => addIfUnvisited(aut));\n\t\twhile (queue.length > 0) {\n\t\t\tconst f = queue.pop()!;\n\t\t\tfor (const g of result) {\n\t\t\t\taddIfUnvisited(f.compose(g));\n\t\t\t\taddIfUnvisited(g.compose(f));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toString(): string {\n\t\treturn '[' + this.generators.map((g) => g.toString()).join(', ') + ']';\n\t}\n}\n","import {Graph} from '..';\r\nimport {Automorphism, AutomorphismGroup} from '../Automorphism';\r\nimport {Mapping} from '../matching';\r\n\r\nexport type NodeKeySuffixGenerator = (\r\n\tgraph: Graph,\r\n\tnodeIndex: number\r\n) => string;\r\nexport type NodePropertiesMapper = (\r\n\tgraph: Graph,\r\n\tnodeIndex: number,\r\n\tnodeMapping: number[]\r\n) => Map<string, any> | undefined;\r\nexport type NodePropertiesCanonKeyMapper = (\r\n\tgraph: Graph,\r\n\tnodeIndex: number\r\n) => string;\r\n\r\n/**\r\n * Nauty graph canonicalization using the following graph properties\r\n * for ordering and selection:\r\n * - First, node cell membership is sorted ascending by \"outDegree|inDegree|label?\"\r\n * - Second, direct neighborhood cell memberships and optional edge labels are sorted\r\n *   ascending, concatenated, and used to further split cells.\r\n *   \"neighborCell_1;outEdgeLabel_1?;inEdgeLabel_1?|neighborCell_2;outEdgeLabel_2?;inEdgeLabel_2?|...\"\r\n *   New cell IDs of the split are assigned by descending key order.\r\n * - Target cell selection in the search tree is performed by selecting the leftmost (smallest) cell ID\r\n *   with at least two members.\r\n */\r\nexport class GraphCanon {\r\n\tpublic static readonly KEY_VERSION = 'v2';\r\n\tpublic static readonly DefaultNodeKeySuffixGenerator: NodeKeySuffixGenerator =\r\n\t\t(graph: Graph, nodeIndex: number) => {\r\n\t\t\treturn graph.labels ? graph.labels[nodeIndex] : '';\r\n\t\t};\r\n\tpublic static readonly DefaultNodePropertiesMapper: NodePropertiesMapper = (\r\n\t\tgraph: Graph,\r\n\t\tnodeIndex: number,\r\n\t\t_nodeMapping: number[]\r\n\t) => {\r\n\t\treturn graph.nodeProperties && graph.nodeProperties[nodeIndex]\r\n\t\t\t? new Map(graph.nodeProperties[nodeIndex])\r\n\t\t\t: undefined;\r\n\t};\r\n\tpublic static readonly DefaultNodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper =\r\n\t\t(_graph: Graph, _nodeIndex: number) => {\r\n\t\t\treturn '';\r\n\t\t};\r\n\r\n\tprivate readonly nodeCount: number;\r\n\tprivate readonly hasNodeLabels: boolean;\r\n\tprivate readonly hasNodeProperties: boolean;\r\n\tprivate readonly hasEdgeLabels: boolean;\r\n\tprivate readonly isSymmetric: boolean;\r\n\tprivate readonly graph: Graph;\r\n\tprivate readonly nodeNeighbors = new Map<number, number[]>();\r\n\tprivate readonly nodeKeys = new Map<number, string>();\r\n\tprivate readonly nodePropertiesMapper: NodePropertiesMapper;\r\n\tprivate readonly nodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper;\r\n\tprivate readonly graphStringBuilder: (graph: Graph) => string;\r\n\r\n\tpublic constructor(\r\n\t\tgraph: Graph,\r\n\t\tnodeKeySuffixGenerator: NodeKeySuffixGenerator = GraphCanon.DefaultNodeKeySuffixGenerator,\r\n\t\tnodePropertiesMapper: NodePropertiesMapper = GraphCanon.DefaultNodePropertiesMapper,\r\n\t\tnodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper = GraphCanon.DefaultNodePropertiesCanonKeyMapper\r\n\t) {\r\n\t\tthis.graph = graph;\r\n\t\tthis.nodeCount = graph.adjacencyMatrix.length;\r\n\t\tthis.hasNodeLabels = graph.labels !== undefined;\r\n\t\tthis.hasNodeProperties = graph.nodeProperties !== undefined;\r\n\t\tthis.hasEdgeLabels = graph.edgeLabels !== undefined;\r\n\t\tthis.nodePropertiesMapper = nodePropertiesMapper;\r\n\t\tthis.nodePropertiesCanonKeyMapper = nodePropertiesCanonKeyMapper;\r\n\t\tlet isSymmetric = true;\r\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\tconst neighbors = new Set<number>();\r\n\t\t\tlet inDegree = 0;\r\n\t\t\tlet outDegree = 0;\r\n\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\tconst isOut = graph.adjacencyMatrix[i][j];\r\n\t\t\t\tconst isIn = graph.adjacencyMatrix[j][i];\r\n\t\t\t\tif (isOut === 1) {\r\n\t\t\t\t\toutDegree++;\r\n\t\t\t\t\tneighbors.add(j);\r\n\t\t\t\t}\r\n\t\t\t\tif (isIn === 1) {\r\n\t\t\t\t\tinDegree++;\r\n\t\t\t\t\tneighbors.add(j);\r\n\t\t\t\t}\r\n\t\t\t\tif (isOut !== isIn) {\r\n\t\t\t\t\tisSymmetric = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.nodeNeighbors.set(i, [...neighbors]);\r\n\t\t\tconst nodeKey =\r\n\t\t\t\toutDegree + '|' + inDegree + '|' + nodeKeySuffixGenerator(graph, i);\r\n\t\t\tthis.nodeKeys.set(i, nodeKey);\r\n\t\t}\r\n\t\tthis.isSymmetric = isSymmetric;\r\n\t\t// Finally build the curried graph key function\r\n\t\tthis.graphStringBuilder = this.buildGraphStringCurry();\r\n\t}\r\n\r\n\t/**\r\n\t * Canonicalize the graph\r\n\t * @returns\r\n\t * 1. canonical graph representation\r\n\t * 2. graph key\r\n\t * 3. node mapping from the original to the canonical graph\r\n\t * 4. automorphisms\r\n\t */\r\n\tpublic canonicalize(): [Graph, string, Mapping, AutomorphismGroup] {\r\n\t\tconst nodeCells = new Array(this.nodeCount).fill(1);\r\n\t\tthis.partitionByPropertyKeys(nodeCells);\r\n\t\tconst partitions: Map<\r\n\t\t\tstring,\r\n\t\t\t{\r\n\t\t\t\tpartitions: Map<number, number>[];\r\n\t\t\t\tautomorphisms: Map<string, Automorphism>;\r\n\t\t\t}\r\n\t\t> = new Map();\r\n\t\tconst prunedSubtrees = new Set<string>();\r\n\t\tthis.individualizeDFS(\r\n\t\t\tnodeCells,\r\n\t\t\t[],\r\n\t\t\tprunedSubtrees,\r\n\t\t\tthis.handleRepresentationCurry(partitions, prunedSubtrees)\r\n\t\t);\r\n\t\tconst lexSmallestKey = [...partitions.keys()].sort((a, b) =>\r\n\t\t\ta.localeCompare(b)\r\n\t\t)[0];\r\n\t\tconst partition = partitions.get(lexSmallestKey)!;\r\n\t\tconst smallestRepresentation = new Array(this.nodeCount);\r\n\t\tconst lexSmallestMapping = new Array(smallestRepresentation.length);\r\n\t\t[...partition.partitions[0].entries()].forEach(([c, i]) => {\r\n\t\t\tsmallestRepresentation[i] = c;\r\n\t\t\tlexSmallestMapping[c - 1] = i;\r\n\t\t});\r\n\t\tconst lexSmallestGraph = this.buildRepresentationGraph(\r\n\t\t\tsmallestRepresentation\r\n\t\t);\r\n\t\tconst allAutomorphisms = new Map<string, Automorphism>();\r\n\t\t[...partitions.values()].forEach((p) =>\r\n\t\t\t[...p.automorphisms.entries()].forEach(([key, aut]) =>\r\n\t\t\t\tallAutomorphisms.set(key, aut)\r\n\t\t\t)\r\n\t\t);\r\n\t\treturn [\r\n\t\t\tlexSmallestGraph,\r\n\t\t\tthis.buildGraphString(lexSmallestGraph),\r\n\t\t\tlexSmallestMapping,\r\n\t\t\tnew AutomorphismGroup([...allAutomorphisms.values()], this.nodeCount),\r\n\t\t];\r\n\t}\r\n\r\n\tprivate handleRepresentationCurry(\r\n\t\tpartitions: Map<\r\n\t\t\tstring,\r\n\t\t\t{\r\n\t\t\t\tpartitions: Map<number, number>[];\r\n\t\t\t\tautomorphisms: Map<string, Automorphism>;\r\n\t\t\t}\r\n\t\t>,\r\n\t\tprunedSubtrees: Set<string>\r\n\t): (nodeCells: number[], suffix: number[]) => void {\r\n\t\tconst cellIds = Array.from({length: this.nodeCount}, (_, i) => i + 1);\r\n\t\treturn (repNodeCells, suffix) => {\r\n\t\t\t// Build the partition key for comparison with other partitions\r\n\t\t\tconst partition = new Map<number, number>();\r\n\t\t\trepNodeCells.forEach((c, i) => partition.set(c, i));\r\n\t\t\tconst partitionKey = cellIds\r\n\t\t\t\t.map((c) =>\r\n\t\t\t\t\tthis.nodeNeighbors\r\n\t\t\t\t\t\t.get(partition.get(c)!)!\r\n\t\t\t\t\t\t.map((n) => repNodeCells[n])\r\n\t\t\t\t\t\t.sort()\r\n\t\t\t\t\t\t.join(';')\r\n\t\t\t\t)\r\n\t\t\t\t.join('|');\r\n\t\t\tlet sameRepresentations = partitions.get(partitionKey);\r\n\t\t\tif (sameRepresentations === undefined) {\r\n\t\t\t\tsameRepresentations = {\r\n\t\t\t\t\tpartitions: [],\r\n\t\t\t\t\tautomorphisms: new Map(),\r\n\t\t\t\t};\r\n\t\t\t\tpartitions.set(partitionKey, sameRepresentations);\r\n\t\t\t}\r\n\r\n\t\t\tfor (const partition of sameRepresentations.partitions) {\r\n\t\t\t\tconst automorphismMap = new Map<number, number>();\r\n\t\t\t\tfor (let i = 0; i < repNodeCells.length; i++) {\r\n\t\t\t\t\tconst partitionIndex = partition.get(repNodeCells[i])!;\r\n\t\t\t\t\tautomorphismMap.set(i, partitionIndex);\r\n\t\t\t\t}\r\n\t\t\t\tconst automorphism = new Automorphism(automorphismMap);\r\n\t\t\t\tconst key = automorphism.toString();\r\n\t\t\t\tif (!sameRepresentations.automorphisms.has(key)) {\r\n\t\t\t\t\tsameRepresentations.automorphisms.set(key, automorphism);\r\n\t\t\t\t\tfor (const x of automorphism.mappings) {\r\n\t\t\t\t\t\tif (x[0] === x[1]) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (let i = 0; i < suffix.length; i++) {\r\n\t\t\t\t\t\t\tif (suffix[i] === x[0]) {\r\n\t\t\t\t\t\t\t\tprunedSubtrees.add([...suffix.slice(0, i), x[1]].join('|'));\r\n\t\t\t\t\t\t\t} else if (suffix[i] === x[1]) {\r\n\t\t\t\t\t\t\t\tprunedSubtrees.add([...suffix.slice(0, i), x[0]].join('|'));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Save the representation\r\n\t\t\tsameRepresentations.partitions.push(partition);\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates only the automorphisms of the graph.\r\n\t *\r\n\t * Note: if any of the graph, graph key, or node mapping are needed as well,\r\n\t * use the canonicalize() function.\r\n\t */\r\n\tpublic aut(): AutomorphismGroup {\r\n\t\tconst nodeCells = new Array(this.nodeCount).fill(1);\r\n\t\tthis.partitionByPropertyKeys(nodeCells);\r\n\t\tconst partitions: Map<\r\n\t\t\tstring,\r\n\t\t\t{\r\n\t\t\t\tpartitions: Map<number, number>[];\r\n\t\t\t\tautomorphisms: Map<string, Automorphism>;\r\n\t\t\t}\r\n\t\t> = new Map();\r\n\t\tconst prunedSubtrees = new Set<string>();\r\n\t\tthis.individualizeDFS(\r\n\t\t\tnodeCells,\r\n\t\t\t[],\r\n\t\t\tprunedSubtrees,\r\n\t\t\tthis.handleRepresentationCurry(partitions, prunedSubtrees)\r\n\t\t);\r\n\t\tconst allAutomorphisms = new Map<string, Automorphism>();\r\n\t\t[...partitions.values()].forEach((p) =>\r\n\t\t\t[...p.automorphisms.entries()].forEach(([key, aut]) =>\r\n\t\t\t\tallAutomorphisms.set(key, aut)\r\n\t\t\t)\r\n\t\t);\r\n\t\treturn new AutomorphismGroup(\r\n\t\t\t[...allAutomorphisms.values()],\r\n\t\t\tthis.nodeCount\r\n\t\t);\r\n\t}\r\n\r\n\tprivate partitionByPropertyKeys(nodeCells: number[]) {\r\n\t\tconst propertyKeyNodeIndices = new Map<string, number[]>();\r\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\tconst key = this.nodeKeys.get(i)!;\r\n\t\t\tif (propertyKeyNodeIndices.has(key)) {\r\n\t\t\t\tpropertyKeyNodeIndices.get(key)!.push(i);\r\n\t\t\t} else {\r\n\t\t\t\tpropertyKeyNodeIndices.set(key, [i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet nextFreeCell = 1;\r\n\t\tArray.from(propertyKeyNodeIndices.keys())\r\n\t\t\t.sort((a, b) => a.localeCompare(b))\r\n\t\t\t.forEach((k) => {\r\n\t\t\t\tconst nodesInNextCell = propertyKeyNodeIndices.get(k)!;\r\n\t\t\t\tnodesInNextCell.forEach((i) => (nodeCells[i] = nextFreeCell));\r\n\t\t\t\tnextFreeCell += nodesInNextCell.length;\r\n\t\t\t});\r\n\t}\r\n\r\n\tprivate isCanon(nodeCells: number[]): boolean {\r\n\t\treturn new Set<number>(nodeCells).size === this.nodeCount;\r\n\t}\r\n\r\n\tprivate individualizeDFS(\r\n\t\tnodeCells: number[],\r\n\t\tsuffix: number[],\r\n\t\tprunedSubtrees: Set<string>,\r\n\t\thandleRepresentation: (nodeCells: number[], suffix: number[]) => void\r\n\t) {\r\n\t\tif (this.isCanon(nodeCells)) {\r\n\t\t\thandleRepresentation(nodeCells, suffix);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.individualizationRefinement(nodeCells);\r\n\t\tif (this.isCanon(nodeCells)) {\r\n\t\t\thandleRepresentation(nodeCells, suffix);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst cellToBreak = this.getCellToBreak(nodeCells);\r\n\t\tfor (const n of cellToBreak[1]) {\r\n\t\t\tnodeCells[n] = cellToBreak[0] + 1;\r\n\t\t}\r\n\t\tfor (const nodeId of cellToBreak[1]) {\r\n\t\t\t// Check if subtree is pruned\r\n\t\t\tconst newSuffix = [...suffix, nodeId];\r\n\t\t\tif (prunedSubtrees.has(newSuffix.join('|'))) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tnodeCells[nodeId] = cellToBreak[0];\r\n\t\t\tthis.individualizeDFS(\r\n\t\t\t\t[...nodeCells],\r\n\t\t\t\tnewSuffix,\r\n\t\t\t\tprunedSubtrees,\r\n\t\t\t\thandleRepresentation\r\n\t\t\t);\r\n\t\t\tnodeCells[nodeId] = cellToBreak[0] + 1;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate individualizationRefinement(nodeCells: number[]) {\r\n\t\tlet isEquitable = false;\r\n\t\twhile (!isEquitable) {\r\n\t\t\tisEquitable = true;\r\n\t\t\t// Build signature for each node\r\n\t\t\tconst signatures: string[] = nodeCells.map((_, i) => {\r\n\t\t\t\tconst neighborCells = this.nodeNeighbors.get(i)!.map((n) => {\r\n\t\t\t\t\tif (this.hasEdgeLabels) {\r\n\t\t\t\t\t\tconst edgeLabels = this.graph.edgeLabels!;\r\n\t\t\t\t\t\tif (this.isSymmetric) {\r\n\t\t\t\t\t\t\treturn `${nodeCells[n]};${edgeLabels[i][n]}`;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn `${nodeCells[n]};${edgeLabels[i][n]};${edgeLabels[n][i]}`;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn nodeCells[n].toString();\r\n\t\t\t\t});\r\n\t\t\t\treturn neighborCells.sort().join('|');\r\n\t\t\t});\r\n\t\t\t// Group by current cell and signature\r\n\t\t\tconst partitionMap = new Map<number, Map<string, number[]>>();\r\n\t\t\tsignatures.forEach((signature, nodeIndex) => {\r\n\t\t\t\tconst cell = nodeCells[nodeIndex];\r\n\t\t\t\tlet cellMap = partitionMap.get(cell);\r\n\t\t\t\tif (cellMap === undefined) {\r\n\t\t\t\t\tcellMap = new Map();\r\n\t\t\t\t\tpartitionMap.set(cell, cellMap);\r\n\t\t\t\t}\r\n\t\t\t\tlet nodeIndices = cellMap.get(signature);\r\n\t\t\t\tif (nodeIndices === undefined) {\r\n\t\t\t\t\tnodeIndices = [];\r\n\t\t\t\t\tcellMap.set(signature, nodeIndices);\r\n\t\t\t\t}\r\n\t\t\t\tnodeIndices.push(nodeIndex);\r\n\t\t\t});\r\n\t\t\t// Partition cells based on signature blocks\r\n\t\t\tfor (let cellId = 1; cellId <= this.nodeCount; cellId++) {\r\n\t\t\t\tconst value = partitionMap.get(cellId);\r\n\t\t\t\tif (value === undefined || value.size < 2) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tisEquitable = false;\r\n\t\t\t\t// Sort block signatures descending\r\n\t\t\t\tconst blockKeys = [...value.keys()].sort((a, b) => b.localeCompare(a));\r\n\t\t\t\tlet newCellId = cellId;\r\n\t\t\t\tfor (const key of blockKeys) {\r\n\t\t\t\t\tconst nodes = value.get(key)!;\r\n\t\t\t\t\tnodes.forEach((n) => (nodeCells[n] = newCellId));\r\n\t\t\t\t\tnewCellId += nodes.length;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate getCellToBreak(nodeCells: number[]): [number, number[]] {\r\n\t\tconst cells: number[][] = Array.from({length: nodeCells.length}, () => []);\r\n\t\tnodeCells.forEach((c, i) => cells[c - 1].push(i));\r\n\t\tfor (let i = 0; i < cells.length; i++) {\r\n\t\t\tif (cells[i].length > 1) {\r\n\t\t\t\treturn [i + 1, cells[i]];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn [1, cells[0]];\r\n\t}\r\n\r\n\tprivate buildRepresentationGraph(nodeCells: number[]): Graph {\r\n\t\tconst nodeMapping = nodeCells.map((c) => c - 1);\r\n\t\tconst graph: Graph = {\r\n\t\t\tadjacencyMatrix: Array.from(\r\n\t\t\t\t{length: this.nodeCount},\r\n\t\t\t\t() => new Array(this.nodeCount)\r\n\t\t\t),\r\n\t\t};\r\n\t\tif (this.isSymmetric) {\r\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\tconst mi = nodeMapping[i];\r\n\t\t\t\tconst row = this.graph.adjacencyMatrix[i];\r\n\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\r\n\t\t\t\t\tgraph.adjacencyMatrix[mi][nodeMapping[j]] = row[j];\r\n\t\t\t\t\tgraph.adjacencyMatrix[nodeMapping[j]][mi] = row[j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\tconst mi = nodeMapping[i];\r\n\t\t\t\tconst row = this.graph.adjacencyMatrix[i];\r\n\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\t\tgraph.adjacencyMatrix[mi][nodeMapping[j]] = row[j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this.hasNodeLabels) {\r\n\t\t\tgraph.labels = new Array(this.nodeCount);\r\n\t\t\tnodeMapping.forEach((c, i) => (graph.labels![c] = this.graph.labels![i]));\r\n\t\t}\r\n\t\tif (this.hasNodeProperties) {\r\n\t\t\tgraph.nodeProperties = new Array(this.nodeCount);\r\n\t\t\tnodeMapping.forEach(\r\n\t\t\t\t(c, i) =>\r\n\t\t\t\t\t(graph.nodeProperties![c] = this.nodePropertiesMapper(\r\n\t\t\t\t\t\tthis.graph,\r\n\t\t\t\t\t\ti,\r\n\t\t\t\t\t\tnodeMapping\r\n\t\t\t\t\t))\r\n\t\t\t);\r\n\t\t}\r\n\t\tif (this.hasEdgeLabels) {\r\n\t\t\tgraph.edgeLabels = Array.from(\r\n\t\t\t\t{length: this.nodeCount},\r\n\t\t\t\t() => new Array(this.nodeCount)\r\n\t\t\t);\r\n\t\t\tif (this.isSymmetric) {\r\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\t\tconst mi = nodeMapping[i];\r\n\t\t\t\t\tconst row = this.graph.edgeLabels![i];\r\n\t\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\r\n\t\t\t\t\t\tgraph.edgeLabels[mi][nodeMapping[j]] = row[j];\r\n\t\t\t\t\t\tgraph.edgeLabels[nodeMapping[j]][mi] = row[j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\t\tconst mi = nodeMapping[i];\r\n\t\t\t\t\tconst row = this.graph.edgeLabels![i];\r\n\t\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\t\t\tgraph.edgeLabels[mi][nodeMapping[j]] = row[j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn graph;\r\n\t}\r\n\r\n\tprivate buildGraphStringCurry() {\r\n\t\tconst edgeCallback = this.hasEdgeLabels\r\n\t\t\t? (graph: Graph, i: number, j: number) =>\r\n\t\t\t\t\t`${i}-${graph.edgeLabels![i][j]}-${j}`\r\n\t\t\t: (_: Graph, i: number, j: number) => `${i}-${j}`;\r\n\t\tconst nodePropertyCallback = this.hasNodeProperties\r\n\t\t\t? (graph: Graph, i: number): string => {\r\n\t\t\t\t\tconst nodePropertyCanonKey = this.nodePropertiesCanonKeyMapper(\r\n\t\t\t\t\t\tgraph,\r\n\t\t\t\t\t\ti\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn nodePropertyCanonKey.length > 0\r\n\t\t\t\t\t\t? `{${nodePropertyCanonKey}}`\r\n\t\t\t\t\t\t: '';\r\n\t\t\t\t}\r\n\t\t\t: (_graph: Graph, _i: number): string => '';\r\n\t\tconst nodeCallback = this.hasNodeLabels\r\n\t\t\t? (graph: Graph): string =>\r\n\t\t\t\t\t';' +\r\n\t\t\t\t\tgraph\r\n\t\t\t\t\t\t.labels!.map((l, i) => l + nodePropertyCallback(graph, i))\r\n\t\t\t\t\t\t.join('|')\r\n\t\t\t: this.hasNodeProperties\r\n\t\t\t\t? (graph: Graph): string =>\r\n\t\t\t\t\t\t';' +\r\n\t\t\t\t\t\tgraph\r\n\t\t\t\t\t\t\t.nodeProperties!.map((_, i) =>\r\n\t\t\t\t\t\t\t\tthis.nodePropertiesCanonKeyMapper(graph, i)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t.join('|')\r\n\t\t\t\t: (_: Graph): string => '';\r\n\r\n\t\tif (this.isSymmetric) {\r\n\t\t\treturn (graph: Graph): string => {\r\n\t\t\t\tconst edges = [];\r\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\t\tconst row = graph.adjacencyMatrix[i];\r\n\t\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\r\n\t\t\t\t\t\tif (row[j] === 1) {\r\n\t\t\t\t\t\t\tedges.push(edgeCallback(graph, i, j));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn (\r\n\t\t\t\t\tGraphCanon.KEY_VERSION +\r\n\t\t\t\t\t';' +\r\n\t\t\t\t\tgraph.adjacencyMatrix.length +\r\n\t\t\t\t\t';sym;' +\r\n\t\t\t\t\tedges.join('|') +\r\n\t\t\t\t\tnodeCallback(graph)\r\n\t\t\t\t);\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn (graph: Graph): string => {\r\n\t\t\tconst edges = [];\r\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\tconst row = graph.adjacencyMatrix[i];\r\n\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\t\tif (row[j] === 1) {\r\n\t\t\t\t\t\tedges.push(edgeCallback(graph, i, j));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn (\r\n\t\t\t\tGraphCanon.KEY_VERSION +\r\n\t\t\t\t';' +\r\n\t\t\t\tgraph.adjacencyMatrix.length +\r\n\t\t\t\t';' +\r\n\t\t\t\tedges.join('|') +\r\n\t\t\t\tnodeCallback(graph)\r\n\t\t\t);\r\n\t\t};\r\n\t}\r\n\r\n\tpublic buildGraphString(graph: Graph): string {\r\n\t\treturn this.graphStringBuilder(graph);\r\n\t}\r\n}\r\n","import {Graph} from '.';\r\n\r\nexport class ConnectedComponents {\r\n\tpublic static find(graph: Graph): number[][] {\r\n\t\tconst result: number[][] = [];\r\n\t\tconst visited = new Set<number>();\r\n\r\n\t\tconst dfs = (node: number, component: number[]) => {\r\n\t\t\tvisited.add(node);\r\n\t\t\tcomponent.push(node);\r\n\t\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tgraph.adjacencyMatrix[node][i] === 1 ||\r\n\t\t\t\t\tgraph.adjacencyMatrix[i][node] === 1\r\n\t\t\t\t) {\r\n\t\t\t\t\tif (!visited.has(i)) {\r\n\t\t\t\t\t\tdfs(i, component);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\tif (!visited.has(i)) {\r\n\t\t\t\tconst component: number[] = [];\r\n\t\t\t\tdfs(i, component);\r\n\t\t\t\tresult.push(component);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n","export * as matching from './matching';\r\nexport * as canon from './canon';\r\nexport * from './ConnectedComponents';\r\n\r\nexport interface Graph {\r\n\t/**\r\n\t * N x N adjacency matrix of the graph. Must be symmetric if directed is true.\r\n\t */\r\n\tadjacencyMatrix: number[][];\r\n\t/**\r\n\t * Optional node labels\r\n\t */\r\n\tlabels?: string[];\r\n\t/**\r\n\t * Optional node properties\r\n\t */\r\n\tnodeProperties?: (Map<string, any> | undefined)[];\r\n\t/**\r\n\t * Optional edge labels\r\n\t */\r\n\tedgeLabels?: string[][];\r\n}\r\n\r\nexport function symmetricGraphToDIMACS(graph: Graph): string {\r\n\tconst n = graph.adjacencyMatrix.length;\r\n\tlet edges: string[] = [];\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tfor (let j = i + 1; j < n; j++) {\r\n\t\t\tif (graph.adjacencyMatrix[i][j] !== 0) {\r\n\t\t\t\tedges.push(`e ${i + 1} ${j + 1}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn [`p edge ${n} ${edges.length}`, ...edges].join('\\n');\r\n}\r\n"],"names":["GraphMatcher","UllmannGraphMatcher","pattern","target","nodeLabelWildcards","edgeLabelWildcards","partialMapping","n","m","isLabeled","used","mapping","nodeLabelWildcardsSet","edgeLabelWildcardsSet","patternInDegrees","patternOutDegrees","targetInDegrees","targetOutDegrees","domains","pd","i","td","j","match","depth","candidate","r","b","row","_","a","results","isEdgeLabeled","Automorphism","mappings","__publicField","visited","keys","key","cycle","value","x","g","h","gx","fgx","k","v","AutomorphismGroup","generators","identity","orbit","aut","c","seen","orbits","orb","result","addIfUnvisited","queue","f","_GraphCanon","graph","nodeKeySuffixGenerator","nodePropertiesMapper","nodePropertiesCanonKeyMapper","isSymmetric","neighbors","inDegree","outDegree","isOut","isIn","nodeKey","nodeCells","partitions","prunedSubtrees","lexSmallestKey","partition","smallestRepresentation","lexSmallestMapping","lexSmallestGraph","allAutomorphisms","p","cellIds","repNodeCells","suffix","partitionKey","sameRepresentations","automorphismMap","partitionIndex","automorphism","propertyKeyNodeIndices","nextFreeCell","nodesInNextCell","handleRepresentation","cellToBreak","nodeId","newSuffix","isEquitable","signatures","edgeLabels","partitionMap","signature","nodeIndex","cell","cellMap","nodeIndices","cellId","blockKeys","newCellId","nodes","cells","nodeMapping","mi","edgeCallback","nodePropertyCallback","nodePropertyCanonKey","_graph","_i","nodeCallback","l","edges","_nodeMapping","_nodeIndex","GraphCanon","ConnectedComponents","dfs","node","component","symmetricGraphToDIMACS"],"mappings":"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"}