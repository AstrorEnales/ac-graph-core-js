{"version":3,"file":"ac-graph-core-js.js","sources":["../src/graph/matching/GraphMatcher.ts","../src/graph/matching/UllmannGraphMatcher.ts"],"sourcesContent":["import {Mapping} from '.';\nimport {Graph} from '..';\n\nexport abstract class GraphMatcher {\n\tpublic abstract isSubgraphIsomorphic(pattern: Graph, target: Graph): boolean;\n\n\tpublic abstract findAllSubgraphMonomorphisms(\n\t\tpattern: Graph,\n\t\ttarget: Graph\n\t): Mapping[];\n}\n","import {Mapping} from '.';\nimport {Graph} from '..';\nimport {GraphMatcher} from './GraphMatcher';\n\nexport class UllmannGraphMatcher extends GraphMatcher {\n\t/**\n\t * Subgraph isomorphism check\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t */\n\tpublic override isSubgraphIsomorphic(pattern: Graph, target: Graph): boolean {\n\t\t// Number of nodes in the pattern graph\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\t// Number of nodes in the target graph\n\t\tconst m = target.adjacencyMatrix.length;\n\t\t// If pattern is larger than target, no mapping is possible\n\t\tif (n > m) {\n\t\t\treturn false;\n\t\t}\n\t\tconst isLabeled = pattern.labels && target.labels;\n\t\t// Track which target nodes are already used in the mapping\n\t\tconst used = Array(m).fill(false);\n\t\tconst mapping = Array(n).fill(-1);\n\t\t// Pre-compute degrees for pattern and target nodes\n\t\tconst patternInDegrees: number[] = [];\n\t\tconst patternOutDegrees: number[] = [];\n\t\tconst targetInDegrees: number[] = [];\n\t\tconst targetOutDegrees: number[] = [];\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tconst row = pattern.adjacencyMatrix[i];\n\t\t\tpatternInDegrees.push(row.reduce((a, b) => a + b, 0));\n\t\t\tpatternOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => pattern.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t}\n\t\tfor (let i = 0; i < m; i++) {\n\t\t\tconst row = target.adjacencyMatrix[i];\n\t\t\ttargetInDegrees.push(row.reduce((a, b) => a + b, 0));\n\t\t\ttargetOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => target.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t}\n\t\t// Pre-compute candidate domains for pattern nodes based on degree\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\n\t\t\ttargetInDegrees\n\t\t\t\t.map((td, j) => {\n\t\t\t\t\treturn td >= pd &&\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\n\t\t\t\t\t\t(!isLabeled || pattern.labels![i] === target.labels![j])\n\t\t\t\t\t\t? j\n\t\t\t\t\t\t: -1;\n\t\t\t\t})\n\t\t\t\t.filter((j) => j !== -1)\n\t\t);\n\t\t// Recursive backtracking function to try all injective mappings\n\t\tconst match = (depth: number): boolean => {\n\t\t\tif (depth === n) {\n\t\t\t\treturn this.checkCompatibility(pattern, target, mapping);\n\t\t\t}\n\t\t\tfor (const candidate of domains[depth]) {\n\t\t\t\tif (!used[candidate]) {\n\t\t\t\t\tmapping[depth] = candidate;\n\t\t\t\t\tused[candidate] = true;\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.isFeasible(pattern, target, mapping, depth) &&\n\t\t\t\t\t\tmatch(depth + 1)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// Backtrack\n\t\t\t\t\tused[candidate] = false;\n\t\t\t\t\tmapping[depth] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\treturn match(0);\n\t}\n\n\t/**\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\n\t * including symmetries\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t */\n\tpublic override findAllSubgraphMonomorphisms(\n\t\tpattern: Graph,\n\t\ttarget: Graph\n\t): Mapping[] {\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\tconst m = target.adjacencyMatrix.length;\n\t\tconst results: Mapping[] = [];\n\t\tif (n > m) {\n\t\t\treturn results;\n\t\t}\n\t\tconst isLabeled = pattern.labels && target.labels;\n\t\tconst used = Array(m).fill(false);\n\t\tconst mapping = Array(n).fill(-1);\n\t\tconst patternInDegrees: number[] = [];\n\t\tconst patternOutDegrees: number[] = [];\n\t\tconst targetInDegrees: number[] = [];\n\t\tconst targetOutDegrees: number[] = [];\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tconst row = pattern.adjacencyMatrix[i];\n\t\t\tpatternInDegrees.push(row.reduce((a, b) => a + b, 0));\n\t\t\tpatternOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => pattern.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t}\n\t\tfor (let i = 0; i < m; i++) {\n\t\t\tconst row = target.adjacencyMatrix[i];\n\t\t\ttargetInDegrees.push(row.reduce((a, b) => a + b, 0));\n\t\t\ttargetOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => target.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t}\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\n\t\t\ttargetInDegrees\n\t\t\t\t.map((td, j) => {\n\t\t\t\t\treturn td >= pd &&\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\n\t\t\t\t\t\t(!isLabeled || pattern.labels![i] === target.labels![j])\n\t\t\t\t\t\t? j\n\t\t\t\t\t\t: -1;\n\t\t\t\t})\n\t\t\t\t.filter((j) => j !== -1)\n\t\t);\n\t\tconst match = (depth: number): void => {\n\t\t\tif (depth === n) {\n\t\t\t\tif (this.checkCompatibility(pattern, target, mapping)) {\n\t\t\t\t\tresults.push([...mapping]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (const candidate of domains[depth]) {\n\t\t\t\tif (!used[candidate]) {\n\t\t\t\t\tmapping[depth] = candidate;\n\t\t\t\t\tused[candidate] = true;\n\t\t\t\t\tif (this.isFeasible(pattern, target, mapping, depth)) {\n\t\t\t\t\t\tmatch(depth + 1);\n\t\t\t\t\t}\n\t\t\t\t\tused[candidate] = false;\n\t\t\t\t\tmapping[depth] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmatch(0);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Feasibility check for current depth: preserve pattern edges\n\t * and edge labels if present\n\t */\n\tprivate isFeasible(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tmapping: Mapping,\n\t\tdepth: number\n\t): boolean {\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\n\t\t// Check that all edges in the current partial mapping are preserved\n\t\tfor (let i = 0; i < depth; i++) {\n\t\t\tif (pattern.adjacencyMatrix[depth][i]) {\n\t\t\t\tif (!target.adjacencyMatrix[mapping[depth]][mapping[i]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check edge labels if present\n\t\t\t\tif (\n\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\tpattern.edgeLabels![depth][i] !==\n\t\t\t\t\t\ttarget.edgeLabels![mapping[depth]][mapping[i]]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pattern.adjacencyMatrix[i][depth]) {\n\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[depth]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check edge labels if present\n\t\t\t\tif (\n\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\tpattern.edgeLabels![i][depth] !==\n\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[depth]]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Verifies full structural consistency of the mapping\n\t */\n\tprivate checkCompatibility(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tmapping: Mapping\n\t): boolean {\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tfor (let j = 0; j < n; j++) {\n\t\t\t\tif (pattern.adjacencyMatrix[i][j]) {\n\t\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[j]]) {\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t\tpattern.edgeLabels![i][j] !==\n\t\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[j]]\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge label\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n"],"names":["GraphMatcher","UllmannGraphMatcher","pattern","target","n","m","isLabeled","used","mapping","patternInDegrees","patternOutDegrees","targetInDegrees","targetOutDegrees","row","a","b","_","j","domains","pd","i","td","match","depth","candidate","results","isEdgeLabeled"],"mappings":"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"}