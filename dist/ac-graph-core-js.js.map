{"version":3,"file":"ac-graph-core-js.js","sources":["../src/graph/matching/GraphMatcher.ts","../src/graph/matching/UllmannGraphMatcher.ts","../src/graph/Automorphism.ts","../src/graph/canon/GraphCanon.ts","../src/graph/ConnectedComponents.ts","../src/graph/index.ts"],"sourcesContent":["import {Mapping} from '.';\nimport {Graph} from '..';\n\nexport abstract class GraphMatcher {\n\t/**\n\t * Subgraph isomorphism check\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic abstract isSubgraphIsomorphic(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[],\n\t\tedgeLabelWildcards: string[],\n\t\tpartialMapping: number[] | null\n\t): boolean;\n\n\t/**\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\n\t * including symmetries\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic abstract findAllSubgraphMonomorphisms(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[],\n\t\tedgeLabelWildcards: string[],\n\t\tpartialMapping: number[] | null\n\t): Mapping[];\n}\n","import {Mapping} from '.';\nimport {Graph} from '..';\nimport {GraphMatcher} from './GraphMatcher';\n\nexport class UllmannGraphMatcher extends GraphMatcher {\n\t/**\n\t * Subgraph isomorphism check\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic override isSubgraphIsomorphic(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[] = [],\n\t\tedgeLabelWildcards: string[] = [],\n\t\tpartialMapping: number[] | null = null\n\t): boolean {\n\t\t// Number of nodes in the pattern graph\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\t// Number of nodes in the target graph\n\t\tconst m = target.adjacencyMatrix.length;\n\t\t// If pattern is larger than target, no mapping is possible\n\t\tif (n > m) {\n\t\t\treturn false;\n\t\t}\n\t\tif (partialMapping === null) {\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\n\t\t}\n\t\tconst isLabeled = pattern.labels && target.labels;\n\t\t// Track which target nodes are already used in the mapping\n\t\tconst used = Array(m).fill(false);\n\t\tconst mapping = Array(n).fill(-1);\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\n\t\t// Pre-compute degrees for pattern and target nodes\n\t\tconst [\n\t\t\tpatternInDegrees,\n\t\t\tpatternOutDegrees,\n\t\t\ttargetInDegrees,\n\t\t\ttargetOutDegrees,\n\t\t] = this.getInOutDegrees(pattern, target);\n\t\t// Pre-compute candidate domains for pattern nodes based on degree\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\n\t\t\ttargetInDegrees\n\t\t\t\t.map((td, j) => {\n\t\t\t\t\treturn td >= pd &&\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\n\t\t\t\t\t\t(!isLabeled ||\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\n\t\t\t\t\t\t? j\n\t\t\t\t\t\t: -1;\n\t\t\t\t})\n\t\t\t\t.filter((j) => j !== -1)\n\t\t);\n\t\t// Recursive backtracking function to try all injective mappings\n\t\tconst match = (depth: number): boolean => {\n\t\t\tif (depth === n) {\n\t\t\t\treturn this.checkCompatibility(\n\t\t\t\t\tpattern,\n\t\t\t\t\ttarget,\n\t\t\t\t\tmapping,\n\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t);\n\t\t\t}\n\t\t\tfor (const candidate of domains[depth]) {\n\t\t\t\tif (!used[candidate]) {\n\t\t\t\t\tmapping[depth] = candidate;\n\t\t\t\t\tused[candidate] = true;\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.isFeasible(\n\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tmapping,\n\t\t\t\t\t\t\tdepth,\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t\t\t) &&\n\t\t\t\t\t\tmatch(depth + 1)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// Backtrack\n\t\t\t\t\tused[candidate] = false;\n\t\t\t\t\tmapping[depth] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\treturn match(0);\n\t}\n\n\tprivate getInOutDegrees(\n\t\tpattern: Graph,\n\t\ttarget: Graph\n\t): [number[], number[], number[], number[]] {\n\t\tconst patternInDegrees = pattern.adjacencyMatrix.map((r) =>\n\t\t\tr.reduce((a, b) => a + b, 0)\n\t\t);\n\t\tconst patternOutDegrees: number[] = [];\n\t\tconst targetInDegrees = target.adjacencyMatrix.map((r) =>\n\t\t\tr.reduce((a, b) => a + b, 0)\n\t\t);\n\t\tconst targetOutDegrees: number[] = [];\n\t\tpattern.adjacencyMatrix.forEach((row, i) => {\n\t\t\tpatternOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => pattern.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t});\n\t\ttarget.adjacencyMatrix.forEach((row, i) => {\n\t\t\ttargetOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => target.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t});\n\t\treturn [\n\t\t\tpatternInDegrees,\n\t\t\tpatternOutDegrees,\n\t\t\ttargetInDegrees,\n\t\t\ttargetOutDegrees,\n\t\t];\n\t}\n\n\t/**\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\n\t * including symmetries\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic override findAllSubgraphMonomorphisms(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[] = [],\n\t\tedgeLabelWildcards: string[] = [],\n\t\tpartialMapping: number[] | null = null\n\t): Mapping[] {\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\tconst m = target.adjacencyMatrix.length;\n\t\tconst results: Mapping[] = [];\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\n\t\tif (n > m) {\n\t\t\treturn results;\n\t\t}\n\t\tif (partialMapping === null) {\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\n\t\t}\n\t\tconst isLabeled = pattern.labels && target.labels;\n\t\tconst used = Array(m).fill(false);\n\t\tconst mapping = Array(n).fill(-1);\n\t\tconst [\n\t\t\tpatternInDegrees,\n\t\t\tpatternOutDegrees,\n\t\t\ttargetInDegrees,\n\t\t\ttargetOutDegrees,\n\t\t] = this.getInOutDegrees(pattern, target);\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\n\t\t\ttargetInDegrees\n\t\t\t\t.map((td, j) => {\n\t\t\t\t\treturn td >= pd &&\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\n\t\t\t\t\t\t(!isLabeled ||\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\n\t\t\t\t\t\t? j\n\t\t\t\t\t\t: -1;\n\t\t\t\t})\n\t\t\t\t.filter((j) => j !== -1)\n\t\t);\n\t\tconst match = (depth: number): void => {\n\t\t\tif (depth === n) {\n\t\t\t\tif (\n\t\t\t\t\tthis.checkCompatibility(\n\t\t\t\t\t\tpattern,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tmapping,\n\t\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tresults.push([...mapping]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (const candidate of domains[depth]) {\n\t\t\t\tif (!used[candidate]) {\n\t\t\t\t\tmapping[depth] = candidate;\n\t\t\t\t\tused[candidate] = true;\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.isFeasible(\n\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tmapping,\n\t\t\t\t\t\t\tdepth,\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tmatch(depth + 1);\n\t\t\t\t\t}\n\t\t\t\t\tused[candidate] = false;\n\t\t\t\t\tmapping[depth] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmatch(0);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Feasibility check for current depth: preserve pattern edges\n\t * and edge labels if present\n\t */\n\tprivate isFeasible(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tmapping: Mapping,\n\t\tdepth: number,\n\t\tedgeLabelWildcardsSet: Set<string>\n\t): boolean {\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\n\t\t// Check that all edges in the current partial mapping are preserved\n\t\tfor (let i = 0; i < depth; i++) {\n\t\t\tif (pattern.adjacencyMatrix[depth][i]) {\n\t\t\t\tif (!target.adjacencyMatrix[mapping[depth]][mapping[i]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check edge labels if present\n\t\t\t\tif (\n\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t!edgeLabelWildcardsSet.has(depth + ',' + i) &&\n\t\t\t\t\tpattern.edgeLabels![depth][i] !==\n\t\t\t\t\t\ttarget.edgeLabels![mapping[depth]][mapping[i]]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pattern.adjacencyMatrix[i][depth]) {\n\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[depth]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check edge labels if present\n\t\t\t\tif (\n\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + depth) &&\n\t\t\t\t\tpattern.edgeLabels![i][depth] !==\n\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[depth]]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Verifies full structural consistency of the mapping\n\t */\n\tprivate checkCompatibility(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tmapping: Mapping,\n\t\tedgeLabelWildcardsSet: Set<string>\n\t): boolean {\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tfor (let j = 0; j < n; j++) {\n\t\t\t\tif (pattern.adjacencyMatrix[i][j]) {\n\t\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[j]]) {\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + j) &&\n\t\t\t\t\t\tpattern.edgeLabels![i][j] !==\n\t\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[j]]\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge label\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n","export class Automorphism {\n\tpublic readonly mappings: Map<number, number>;\n\tpublic readonly cycles: number[][] = [];\n\n\tconstructor(mappings: Map<number, number>) {\n\t\tthis.mappings = mappings;\n\t\tif (new Set(mappings.values()).size !== mappings.size) {\n\t\t\tthrow 'Automorphism is not bijective';\n\t\t}\n\t\tconst visited = new Set<number>();\n\t\tconst keys = [...mappings.keys()].sort();\n\t\tfor (const key of keys) {\n\t\t\tif (!visited.has(key)) {\n\t\t\t\tvisited.add(key);\n\t\t\t\tconst cycle = [key];\n\t\t\t\twhile (mappings.has(cycle[cycle.length - 1])) {\n\t\t\t\t\tconst value = mappings.get(cycle[cycle.length - 1])!;\n\t\t\t\t\tvisited.add(value);\n\t\t\t\t\tif (value !== cycle[0]) {\n\t\t\t\t\t\tcycle.push(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cycle.length > 1) {\n\t\t\t\t\tthis.cycles.push(cycle);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic apply(x: number): number {\n\t\treturn this.mappings.get(x)!;\n\t}\n\n\t/**\n\t * Compose this automorphism (f) with another one (g): (f ∘ g)(x) = f(g(x))\n\t */\n\tpublic compose(g: Automorphism): Automorphism {\n\t\tconst h = new Map<number, number>();\n\t\tfor (const x of this.mappings.keys()) {\n\t\t\tconst gx = g.apply(x);\n\t\t\tconst fgx = this.apply(gx);\n\t\t\th.set(x, fgx);\n\t\t}\n\t\treturn new Automorphism(h);\n\t}\n\n\tpublic reverse(): Automorphism {\n\t\treturn new Automorphism(\n\t\t\tnew Map([...this.mappings.entries()].map(([k, v]) => [v, k]))\n\t\t);\n\t}\n\n\tpublic equals(g: Automorphism): boolean {\n\t\tfor (const key of this.mappings.keys()) {\n\t\t\tif (this.mappings.get(key)! !== g.mappings.get(key)!) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic isIdentity(): boolean {\n\t\tfor (const key of this.mappings.keys()) {\n\t\t\tif (this.mappings.get(key)! !== key) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic toString(): string {\n\t\tif (this.cycles.length === 0) {\n\t\t\treturn '()';\n\t\t}\n\t\treturn this.cycles\n\t\t\t.map((m) => `(${m.join(' ')})`)\n\t\t\t.sort()\n\t\t\t.join('');\n\t}\n}\n\nexport class AutomorphismGroup {\n\tpublic readonly generators: Automorphism[];\n\n\tconstructor(generators: Automorphism[], n: number) {\n\t\tif (generators.some((g) => g.isIdentity())) {\n\t\t\tthis.generators = [...generators];\n\t\t} else {\n\t\t\tconst identity = new Automorphism(\n\t\t\t\tnew Map(Array.from({length: n}, (_, i) => [i, i]))\n\t\t\t);\n\t\t\tthis.generators = [identity, ...generators];\n\t\t}\n\t}\n\n\tpublic orbitOf(x: number): number[] {\n\t\tconst orbit = new Set<number>();\n\t\torbit.add(x);\n\t\tfor (const aut of this.generators) {\n\t\t\torbit.add(aut.apply(x));\n\t\t}\n\t\treturn Array.from(orbit).sort();\n\t}\n\n\tpublic stabilizerOf(x: number): Automorphism[] {\n\t\treturn this.generators.filter((aut) => aut.apply(x) === x);\n\t}\n\n\tpublic stabilizerSizeOf(x: number): number {\n\t\treturn this.generators.reduce(\n\t\t\t(c, aut) => (c += aut.apply(x) === x ? 1 : 0),\n\t\t\t0\n\t\t);\n\t}\n\n\t/**\n\t * Orbit size of x via Orbit–Stabilizer Theorem.\n\t */\n\tpublic orbitSizeOf(x: number): number {\n\t\treturn this.generators.length / this.stabilizerSizeOf(x);\n\t}\n\n\tpublic orbits(): number[][] {\n\t\tconst seen = new Set<number>();\n\t\tconst orbits: number[][] = [];\n\t\tfor (const g of this.generators[0].mappings.keys()) {\n\t\t\tif (!seen.has(g)) {\n\t\t\t\tconst orb = this.orbitOf(g);\n\t\t\t\torb.forEach((x) => seen.add(x));\n\t\t\t\torbits.push(orb);\n\t\t\t}\n\t\t}\n\t\treturn orbits;\n\t}\n\n\tpublic closure(): Automorphism[] {\n\t\tconst result: Automorphism[] = [];\n\t\tconst visited = new Set<string>();\n\t\tconst addIfUnvisited = (aut: Automorphism) => {\n\t\t\tconst key = aut.toString();\n\t\t\tif (!visited.has(key)) {\n\t\t\t\tresult.push(aut);\n\t\t\t\tvisited.add(key);\n\t\t\t}\n\t\t};\n\t\tconst queue = [\n\t\t\t...this.generators,\n\t\t\t...this.generators.map((g) => g.reverse()),\n\t\t];\n\t\tqueue.forEach((aut) => addIfUnvisited(aut));\n\t\twhile (queue.length > 0) {\n\t\t\tconst f = queue.pop()!;\n\t\t\tfor (const g of result) {\n\t\t\t\taddIfUnvisited(f.compose(g));\n\t\t\t\taddIfUnvisited(g.compose(f));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toString(): string {\n\t\treturn '[' + this.generators.map((g) => g.toString()).join(', ') + ']';\n\t}\n}\n","import {Graph} from '..';\nimport {Automorphism, AutomorphismGroup} from '../Automorphism';\nimport {Mapping} from '../matching';\n\nexport type NodeKeySuffixGenerator = (\n\tgraph: Graph,\n\tnodeIndex: number\n) => string;\nexport type NodePropertiesMapper = (\n\tgraph: Graph,\n\tnodeIndex: number,\n\tnodeMapping: number[]\n) => Map<string, any> | undefined;\nexport type NodeLabelCanonKeyMapper = (\n\tgraph: Graph,\n\tnodeIndex: number\n) => string;\nexport type EdgeLabelCanonKeyMapper = (\n\tgraph: Graph,\n\tsourceNodeIndex: number,\n\ttargetNodeIndex: number\n) => string;\nexport type NodePropertiesCanonKeyMapper = (\n\tgraph: Graph,\n\tnodeIndex: number\n) => string;\n\n/**\n * Nauty graph canonicalization using the following graph properties\n * for ordering and selection:\n * - First, node cell membership is sorted ascending by \"outDegree|inDegree|label?\"\n * - Second, direct neighborhood cell memberships and optional edge labels are sorted\n *   ascending, concatenated, and used to further split cells.\n *   \"neighborCell_1;outEdgeLabel_1?;inEdgeLabel_1?|neighborCell_2;outEdgeLabel_2?;inEdgeLabel_2?|...\"\n *   New cell IDs of the split are assigned by descending key order.\n * - Target cell selection in the search tree is performed by selecting the leftmost (smallest) cell ID\n *   with at least two members.\n */\nexport class GraphCanon {\n\tpublic static readonly KEY_VERSION = 'v2';\n\tpublic static readonly DefaultNodeKeySuffixGenerator: NodeKeySuffixGenerator =\n\t\t(graph: Graph, nodeIndex: number) => {\n\t\t\treturn graph.labels ? graph.labels[nodeIndex] : '';\n\t\t};\n\tpublic static readonly DefaultNodePropertiesMapper: NodePropertiesMapper = (\n\t\tgraph: Graph,\n\t\tnodeIndex: number,\n\t\t_nodeMapping: number[]\n\t) => {\n\t\treturn graph.nodeProperties && graph.nodeProperties[nodeIndex]\n\t\t\t? new Map(graph.nodeProperties[nodeIndex])\n\t\t\t: undefined;\n\t};\n\tpublic static readonly DefaultNodeLabelCanonKeyMapper: NodeLabelCanonKeyMapper =\n\t\t(graph: Graph, nodeIndex: number) => {\n\t\t\treturn graph.labels ? graph.labels[nodeIndex] : '';\n\t\t};\n\tpublic static readonly DefaultEdgeLabelCanonKeyMapper: EdgeLabelCanonKeyMapper =\n\t\t(graph: Graph, sourceNodeIndex: number, targetNodeIndex: number) => {\n\t\t\treturn graph.edgeLabels\n\t\t\t\t? graph.edgeLabels[sourceNodeIndex][targetNodeIndex]\n\t\t\t\t: '';\n\t\t};\n\tpublic static readonly DefaultNodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper =\n\t\t(_graph: Graph, _nodeIndex: number) => {\n\t\t\treturn '';\n\t\t};\n\n\tprivate readonly nodeCount: number;\n\tprivate readonly hasNodeLabels: boolean;\n\tprivate readonly hasNodeProperties: boolean;\n\tprivate readonly hasEdgeLabels: boolean;\n\tprivate readonly isSymmetric: boolean;\n\tprivate readonly graph: Graph;\n\tprivate readonly nodeNeighbors = new Map<number, number[]>();\n\tprivate readonly nodeKeys = new Map<number, string>();\n\tprivate readonly nodePropertiesMapper: NodePropertiesMapper;\n\tprivate readonly nodeLabelCanonKeyMapper: NodeLabelCanonKeyMapper;\n\tprivate readonly edgeLabelCanonKeyMapper: EdgeLabelCanonKeyMapper;\n\tprivate readonly nodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper;\n\tprivate readonly graphStringBuilder: (graph: Graph) => string;\n\n\tpublic constructor(\n\t\tgraph: Graph,\n\t\tnodeKeySuffixGenerator: NodeKeySuffixGenerator = GraphCanon.DefaultNodeKeySuffixGenerator,\n\t\tnodePropertiesMapper: NodePropertiesMapper = GraphCanon.DefaultNodePropertiesMapper,\n\t\tnodeLabelCanonKeyMapper: NodeLabelCanonKeyMapper = GraphCanon.DefaultNodeLabelCanonKeyMapper,\n\t\tedgeLabelCanonKeyMapper: EdgeLabelCanonKeyMapper = GraphCanon.DefaultEdgeLabelCanonKeyMapper,\n\t\tnodePropertiesCanonKeyMapper: NodePropertiesCanonKeyMapper = GraphCanon.DefaultNodePropertiesCanonKeyMapper\n\t) {\n\t\tthis.graph = graph;\n\t\tthis.nodeCount = graph.adjacencyMatrix.length;\n\t\tthis.hasNodeLabels = graph.labels !== undefined;\n\t\tthis.hasNodeProperties = graph.nodeProperties !== undefined;\n\t\tthis.hasEdgeLabels = graph.edgeLabels !== undefined;\n\t\tthis.nodePropertiesMapper = nodePropertiesMapper;\n\t\tthis.nodeLabelCanonKeyMapper = nodeLabelCanonKeyMapper;\n\t\tthis.edgeLabelCanonKeyMapper = edgeLabelCanonKeyMapper;\n\t\tthis.nodePropertiesCanonKeyMapper = nodePropertiesCanonKeyMapper;\n\t\tlet isSymmetric = true;\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\tconst neighbors = new Set<number>();\n\t\t\tlet inDegree = 0;\n\t\t\tlet outDegree = 0;\n\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\tconst isOut = graph.adjacencyMatrix[i][j];\n\t\t\t\tconst isIn = graph.adjacencyMatrix[j][i];\n\t\t\t\tif (isOut === 1) {\n\t\t\t\t\toutDegree++;\n\t\t\t\t\tneighbors.add(j);\n\t\t\t\t}\n\t\t\t\tif (isIn === 1) {\n\t\t\t\t\tinDegree++;\n\t\t\t\t\tneighbors.add(j);\n\t\t\t\t}\n\t\t\t\tif (isOut !== isIn) {\n\t\t\t\t\tisSymmetric = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.nodeNeighbors.set(i, [...neighbors]);\n\t\t\tconst nodeKey =\n\t\t\t\toutDegree + '|' + inDegree + '|' + nodeKeySuffixGenerator(graph, i);\n\t\t\tthis.nodeKeys.set(i, nodeKey);\n\t\t}\n\t\tthis.isSymmetric = isSymmetric;\n\t\t// Finally build the curried graph key function\n\t\tthis.graphStringBuilder = this.buildGraphStringCurry();\n\t}\n\n\t/**\n\t * Canonicalize the graph\n\t * @returns\n\t * 1. canonical graph representation\n\t * 2. graph key\n\t * 3. node mapping from the original to the canonical graph\n\t * 4. automorphisms\n\t */\n\tpublic canonicalize(): [Graph, string, Mapping, AutomorphismGroup] {\n\t\tconst nodeCells = new Array(this.nodeCount).fill(1);\n\t\tthis.partitionByPropertyKeys(nodeCells);\n\t\tconst partitions: Map<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpartitions: Map<number, number>[];\n\t\t\t\tautomorphisms: Map<string, Automorphism>;\n\t\t\t}\n\t\t> = new Map();\n\t\tconst prunedSubtrees = new Set<string>();\n\t\tthis.individualizeDFS(\n\t\t\tnodeCells,\n\t\t\t[],\n\t\t\tprunedSubtrees,\n\t\t\tthis.handleRepresentationCurry(partitions, prunedSubtrees)\n\t\t);\n\t\tconst lexSmallestKey = [...partitions.keys()].sort((a, b) =>\n\t\t\ta.localeCompare(b)\n\t\t)[0];\n\t\tconst partition = partitions.get(lexSmallestKey)!;\n\t\tconst smallestRepresentation = new Array(this.nodeCount);\n\t\tconst lexSmallestMapping = new Array(smallestRepresentation.length);\n\t\t[...partition.partitions[0].entries()].forEach(([c, i]) => {\n\t\t\tsmallestRepresentation[i] = c;\n\t\t\tlexSmallestMapping[c - 1] = i;\n\t\t});\n\t\tconst lexSmallestGraph = this.buildRepresentationGraph(\n\t\t\tsmallestRepresentation\n\t\t);\n\t\tconst allAutomorphisms = new Map<string, Automorphism>();\n\t\t[...partitions.values()].forEach((p) =>\n\t\t\t[...p.automorphisms.entries()].forEach(([key, aut]) =>\n\t\t\t\tallAutomorphisms.set(key, aut)\n\t\t\t)\n\t\t);\n\t\treturn [\n\t\t\tlexSmallestGraph,\n\t\t\tthis.buildGraphString(lexSmallestGraph),\n\t\t\tlexSmallestMapping,\n\t\t\tnew AutomorphismGroup([...allAutomorphisms.values()], this.nodeCount),\n\t\t];\n\t}\n\n\tprivate handleRepresentationCurry(\n\t\tpartitions: Map<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpartitions: Map<number, number>[];\n\t\t\t\tautomorphisms: Map<string, Automorphism>;\n\t\t\t}\n\t\t>,\n\t\tprunedSubtrees: Set<string>\n\t): (nodeCells: number[], suffix: number[]) => void {\n\t\tconst cellIds = Array.from({length: this.nodeCount}, (_, i) => i + 1);\n\t\treturn (repNodeCells, suffix) => {\n\t\t\t// Build the partition key for comparison with other partitions\n\t\t\tconst partition = new Map<number, number>();\n\t\t\trepNodeCells.forEach((c, i) => partition.set(c, i));\n\t\t\tconst partitionKey = cellIds\n\t\t\t\t.map((c) =>\n\t\t\t\t\tthis.nodeNeighbors\n\t\t\t\t\t\t.get(partition.get(c)!)!\n\t\t\t\t\t\t.map((n) => repNodeCells[n])\n\t\t\t\t\t\t.sort()\n\t\t\t\t\t\t.join(';')\n\t\t\t\t)\n\t\t\t\t.join('|');\n\t\t\tlet sameRepresentations = partitions.get(partitionKey);\n\t\t\tif (sameRepresentations === undefined) {\n\t\t\t\tsameRepresentations = {\n\t\t\t\t\tpartitions: [],\n\t\t\t\t\tautomorphisms: new Map(),\n\t\t\t\t};\n\t\t\t\tpartitions.set(partitionKey, sameRepresentations);\n\t\t\t}\n\n\t\t\tfor (const partition of sameRepresentations.partitions) {\n\t\t\t\tconst automorphismMap = new Map<number, number>();\n\t\t\t\tfor (let i = 0; i < repNodeCells.length; i++) {\n\t\t\t\t\tconst partitionIndex = partition.get(repNodeCells[i])!;\n\t\t\t\t\tautomorphismMap.set(i, partitionIndex);\n\t\t\t\t}\n\t\t\t\tconst automorphism = new Automorphism(automorphismMap);\n\t\t\t\tconst key = automorphism.toString();\n\t\t\t\tif (!sameRepresentations.automorphisms.has(key)) {\n\t\t\t\t\tsameRepresentations.automorphisms.set(key, automorphism);\n\t\t\t\t\tfor (const x of automorphism.mappings) {\n\t\t\t\t\t\tif (x[0] === x[1]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < suffix.length; i++) {\n\t\t\t\t\t\t\tif (suffix[i] === x[0]) {\n\t\t\t\t\t\t\t\tprunedSubtrees.add([...suffix.slice(0, i), x[1]].join('|'));\n\t\t\t\t\t\t\t} else if (suffix[i] === x[1]) {\n\t\t\t\t\t\t\t\tprunedSubtrees.add([...suffix.slice(0, i), x[0]].join('|'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Save the representation\n\t\t\tsameRepresentations.partitions.push(partition);\n\t\t};\n\t}\n\n\t/**\n\t * Calculates only the automorphisms of the graph.\n\t *\n\t * Note: if any of the graph, graph key, or node mapping are needed as well,\n\t * use the canonicalize() function.\n\t */\n\tpublic aut(): AutomorphismGroup {\n\t\tconst nodeCells = new Array(this.nodeCount).fill(1);\n\t\tthis.partitionByPropertyKeys(nodeCells);\n\t\tconst partitions: Map<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpartitions: Map<number, number>[];\n\t\t\t\tautomorphisms: Map<string, Automorphism>;\n\t\t\t}\n\t\t> = new Map();\n\t\tconst prunedSubtrees = new Set<string>();\n\t\tthis.individualizeDFS(\n\t\t\tnodeCells,\n\t\t\t[],\n\t\t\tprunedSubtrees,\n\t\t\tthis.handleRepresentationCurry(partitions, prunedSubtrees)\n\t\t);\n\t\tconst allAutomorphisms = new Map<string, Automorphism>();\n\t\t[...partitions.values()].forEach((p) =>\n\t\t\t[...p.automorphisms.entries()].forEach(([key, aut]) =>\n\t\t\t\tallAutomorphisms.set(key, aut)\n\t\t\t)\n\t\t);\n\t\treturn new AutomorphismGroup(\n\t\t\t[...allAutomorphisms.values()],\n\t\t\tthis.nodeCount\n\t\t);\n\t}\n\n\tprivate partitionByPropertyKeys(nodeCells: number[]) {\n\t\tconst propertyKeyNodeIndices = new Map<string, number[]>();\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\tconst key = this.nodeKeys.get(i)!;\n\t\t\tif (propertyKeyNodeIndices.has(key)) {\n\t\t\t\tpropertyKeyNodeIndices.get(key)!.push(i);\n\t\t\t} else {\n\t\t\t\tpropertyKeyNodeIndices.set(key, [i]);\n\t\t\t}\n\t\t}\n\t\tlet nextFreeCell = 1;\n\t\tArray.from(propertyKeyNodeIndices.keys())\n\t\t\t.sort((a, b) => a.localeCompare(b))\n\t\t\t.forEach((k) => {\n\t\t\t\tconst nodesInNextCell = propertyKeyNodeIndices.get(k)!;\n\t\t\t\tnodesInNextCell.forEach((i) => (nodeCells[i] = nextFreeCell));\n\t\t\t\tnextFreeCell += nodesInNextCell.length;\n\t\t\t});\n\t}\n\n\tprivate isCanon(nodeCells: number[]): boolean {\n\t\treturn new Set<number>(nodeCells).size === this.nodeCount;\n\t}\n\n\tprivate individualizeDFS(\n\t\tnodeCells: number[],\n\t\tsuffix: number[],\n\t\tprunedSubtrees: Set<string>,\n\t\thandleRepresentation: (nodeCells: number[], suffix: number[]) => void\n\t) {\n\t\tif (this.isCanon(nodeCells)) {\n\t\t\thandleRepresentation(nodeCells, suffix);\n\t\t\treturn;\n\t\t}\n\t\tthis.individualizationRefinement(nodeCells);\n\t\tif (this.isCanon(nodeCells)) {\n\t\t\thandleRepresentation(nodeCells, suffix);\n\t\t\treturn;\n\t\t}\n\t\tconst cellToBreak = this.getCellToBreak(nodeCells);\n\t\tfor (const n of cellToBreak[1]) {\n\t\t\tnodeCells[n] = cellToBreak[0] + 1;\n\t\t}\n\t\tfor (const nodeId of cellToBreak[1]) {\n\t\t\t// Check if subtree is pruned\n\t\t\tconst newSuffix = [...suffix, nodeId];\n\t\t\tif (prunedSubtrees.has(newSuffix.join('|'))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnodeCells[nodeId] = cellToBreak[0];\n\t\t\tthis.individualizeDFS(\n\t\t\t\t[...nodeCells],\n\t\t\t\tnewSuffix,\n\t\t\t\tprunedSubtrees,\n\t\t\t\thandleRepresentation\n\t\t\t);\n\t\t\tnodeCells[nodeId] = cellToBreak[0] + 1;\n\t\t}\n\t}\n\n\tprivate individualizationRefinement(nodeCells: number[]) {\n\t\tlet isEquitable = false;\n\t\twhile (!isEquitable) {\n\t\t\tisEquitable = true;\n\t\t\t// Build signature for each node\n\t\t\tconst signatures: string[] = nodeCells.map((_, i) => {\n\t\t\t\tconst neighborCells = this.nodeNeighbors.get(i)!.map((n) => {\n\t\t\t\t\tif (this.hasEdgeLabels) {\n\t\t\t\t\t\tconst edgeLabels = this.graph.edgeLabels!;\n\t\t\t\t\t\tif (this.isSymmetric) {\n\t\t\t\t\t\t\treturn `${nodeCells[n]};${edgeLabels[i][n]}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `${nodeCells[n]};${edgeLabels[i][n]};${edgeLabels[n][i]}`;\n\t\t\t\t\t}\n\t\t\t\t\treturn nodeCells[n].toString();\n\t\t\t\t});\n\t\t\t\treturn neighborCells.sort().join('|');\n\t\t\t});\n\t\t\t// Group by current cell and signature\n\t\t\tconst partitionMap = new Map<number, Map<string, number[]>>();\n\t\t\tsignatures.forEach((signature, nodeIndex) => {\n\t\t\t\tconst cell = nodeCells[nodeIndex];\n\t\t\t\tlet cellMap = partitionMap.get(cell);\n\t\t\t\tif (cellMap === undefined) {\n\t\t\t\t\tcellMap = new Map();\n\t\t\t\t\tpartitionMap.set(cell, cellMap);\n\t\t\t\t}\n\t\t\t\tlet nodeIndices = cellMap.get(signature);\n\t\t\t\tif (nodeIndices === undefined) {\n\t\t\t\t\tnodeIndices = [];\n\t\t\t\t\tcellMap.set(signature, nodeIndices);\n\t\t\t\t}\n\t\t\t\tnodeIndices.push(nodeIndex);\n\t\t\t});\n\t\t\t// Partition cells based on signature blocks\n\t\t\tfor (let cellId = 1; cellId <= this.nodeCount; cellId++) {\n\t\t\t\tconst value = partitionMap.get(cellId);\n\t\t\t\tif (value === undefined || value.size < 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisEquitable = false;\n\t\t\t\t// Sort block signatures descending\n\t\t\t\tconst blockKeys = [...value.keys()].sort((a, b) => b.localeCompare(a));\n\t\t\t\tlet newCellId = cellId;\n\t\t\t\tfor (const key of blockKeys) {\n\t\t\t\t\tconst nodes = value.get(key)!;\n\t\t\t\t\tnodes.forEach((n) => (nodeCells[n] = newCellId));\n\t\t\t\t\tnewCellId += nodes.length;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getCellToBreak(nodeCells: number[]): [number, number[]] {\n\t\tconst cells: number[][] = Array.from({length: nodeCells.length}, () => []);\n\t\tnodeCells.forEach((c, i) => cells[c - 1].push(i));\n\t\tfor (let i = 0; i < cells.length; i++) {\n\t\t\tif (cells[i].length > 1) {\n\t\t\t\treturn [i + 1, cells[i]];\n\t\t\t}\n\t\t}\n\t\treturn [1, cells[0]];\n\t}\n\n\tprivate buildRepresentationGraph(nodeCells: number[]): Graph {\n\t\tconst nodeMapping = nodeCells.map((c) => c - 1);\n\t\tconst graph: Graph = {\n\t\t\tadjacencyMatrix: Array.from(\n\t\t\t\t{length: this.nodeCount},\n\t\t\t\t() => new Array(this.nodeCount)\n\t\t\t),\n\t\t};\n\t\tif (this.isSymmetric) {\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\tconst mi = nodeMapping[i];\n\t\t\t\tconst row = this.graph.adjacencyMatrix[i];\n\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\n\t\t\t\t\tgraph.adjacencyMatrix[mi][nodeMapping[j]] = row[j];\n\t\t\t\t\tgraph.adjacencyMatrix[nodeMapping[j]][mi] = row[j];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\tconst mi = nodeMapping[i];\n\t\t\t\tconst row = this.graph.adjacencyMatrix[i];\n\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\t\tgraph.adjacencyMatrix[mi][nodeMapping[j]] = row[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.hasNodeLabels) {\n\t\t\tgraph.labels = new Array(this.nodeCount);\n\t\t\tnodeMapping.forEach((c, i) => (graph.labels![c] = this.graph.labels![i]));\n\t\t}\n\t\tif (this.hasNodeProperties) {\n\t\t\tgraph.nodeProperties = new Array(this.nodeCount);\n\t\t\tnodeMapping.forEach(\n\t\t\t\t(c, i) =>\n\t\t\t\t\t(graph.nodeProperties![c] = this.nodePropertiesMapper(\n\t\t\t\t\t\tthis.graph,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\tnodeMapping\n\t\t\t\t\t))\n\t\t\t);\n\t\t}\n\t\tif (this.hasEdgeLabels) {\n\t\t\tgraph.edgeLabels = Array.from(\n\t\t\t\t{length: this.nodeCount},\n\t\t\t\t() => new Array(this.nodeCount)\n\t\t\t);\n\t\t\tif (this.isSymmetric) {\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\t\tconst mi = nodeMapping[i];\n\t\t\t\t\tconst row = this.graph.edgeLabels![i];\n\t\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\n\t\t\t\t\t\tgraph.edgeLabels[mi][nodeMapping[j]] = row[j];\n\t\t\t\t\t\tgraph.edgeLabels[nodeMapping[j]][mi] = row[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\t\tconst mi = nodeMapping[i];\n\t\t\t\t\tconst row = this.graph.edgeLabels![i];\n\t\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\t\t\tgraph.edgeLabels[mi][nodeMapping[j]] = row[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\n\tprivate buildGraphStringCurry() {\n\t\tconst edgeCallback = this.hasEdgeLabels\n\t\t\t? (graph: Graph, i: number, j: number) =>\n\t\t\t\t\t`${i}-${this.edgeLabelCanonKeyMapper(graph, i, j)}-${j}`\n\t\t\t: (_: Graph, i: number, j: number) => `${i}-${j}`;\n\t\tconst nodePropertyCallback = this.hasNodeProperties\n\t\t\t? (graph: Graph, i: number): string => {\n\t\t\t\t\tconst nodePropertyCanonKey = this.nodePropertiesCanonKeyMapper(\n\t\t\t\t\t\tgraph,\n\t\t\t\t\t\ti\n\t\t\t\t\t);\n\t\t\t\t\treturn nodePropertyCanonKey.length > 0\n\t\t\t\t\t\t? `{${nodePropertyCanonKey}}`\n\t\t\t\t\t\t: '';\n\t\t\t\t}\n\t\t\t: (_graph: Graph, _i: number): string => '';\n\t\tconst nodeCallback = this.hasNodeLabels\n\t\t\t? (graph: Graph): string =>\n\t\t\t\t\t';' +\n\t\t\t\t\tgraph\n\t\t\t\t\t\t.labels!.map(\n\t\t\t\t\t\t\t(_, i) =>\n\t\t\t\t\t\t\t\tthis.nodeLabelCanonKeyMapper(graph, i) +\n\t\t\t\t\t\t\t\tnodePropertyCallback(graph, i)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.join('|')\n\t\t\t: this.hasNodeProperties\n\t\t\t\t? (graph: Graph): string =>\n\t\t\t\t\t\t';' +\n\t\t\t\t\t\tgraph\n\t\t\t\t\t\t\t.nodeProperties!.map((_, i) =>\n\t\t\t\t\t\t\t\tthis.nodePropertiesCanonKeyMapper(graph, i)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.join('|')\n\t\t\t\t: (_: Graph): string => '';\n\n\t\tif (this.isSymmetric) {\n\t\t\treturn (graph: Graph): string => {\n\t\t\t\tconst edges = [];\n\t\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\t\tconst row = graph.adjacencyMatrix[i];\n\t\t\t\t\tfor (let j = i; j < this.nodeCount; j++) {\n\t\t\t\t\t\tif (row[j] === 1) {\n\t\t\t\t\t\t\tedges.push(edgeCallback(graph, i, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn (\n\t\t\t\t\tGraphCanon.KEY_VERSION +\n\t\t\t\t\t';' +\n\t\t\t\t\tgraph.adjacencyMatrix.length +\n\t\t\t\t\t';sym;' +\n\t\t\t\t\tedges.join('|') +\n\t\t\t\t\tnodeCallback(graph)\n\t\t\t\t);\n\t\t\t};\n\t\t}\n\t\treturn (graph: Graph): string => {\n\t\t\tconst edges = [];\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\n\t\t\t\tconst row = graph.adjacencyMatrix[i];\n\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\n\t\t\t\t\tif (row[j] === 1) {\n\t\t\t\t\t\tedges.push(edgeCallback(graph, i, j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (\n\t\t\t\tGraphCanon.KEY_VERSION +\n\t\t\t\t';' +\n\t\t\t\tgraph.adjacencyMatrix.length +\n\t\t\t\t';' +\n\t\t\t\tedges.join('|') +\n\t\t\t\tnodeCallback(graph)\n\t\t\t);\n\t\t};\n\t}\n\n\tpublic buildGraphString(graph: Graph): string {\n\t\treturn this.graphStringBuilder(graph);\n\t}\n}\n","import {Graph} from '.';\r\n\r\nexport class ConnectedComponents {\r\n\tpublic static find(graph: Graph): number[][] {\r\n\t\tconst result: number[][] = [];\r\n\t\tconst visited = new Set<number>();\r\n\r\n\t\tconst dfs = (node: number, component: number[]) => {\r\n\t\t\tvisited.add(node);\r\n\t\t\tcomponent.push(node);\r\n\t\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tgraph.adjacencyMatrix[node][i] === 1 ||\r\n\t\t\t\t\tgraph.adjacencyMatrix[i][node] === 1\r\n\t\t\t\t) {\r\n\t\t\t\t\tif (!visited.has(i)) {\r\n\t\t\t\t\t\tdfs(i, component);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\tif (!visited.has(i)) {\r\n\t\t\t\tconst component: number[] = [];\r\n\t\t\t\tdfs(i, component);\r\n\t\t\t\tresult.push(component);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n","export * as matching from './matching';\r\nexport * as canon from './canon';\r\nexport * from './ConnectedComponents';\r\nexport * from './Automorphism';\r\n\r\nexport interface Graph {\r\n\t/**\r\n\t * N x N adjacency matrix of the graph. Must be symmetric if directed is true.\r\n\t */\r\n\tadjacencyMatrix: number[][];\r\n\t/**\r\n\t * Optional node labels\r\n\t */\r\n\tlabels?: string[];\r\n\t/**\r\n\t * Optional node properties\r\n\t */\r\n\tnodeProperties?: (Map<string, any> | undefined)[];\r\n\t/**\r\n\t * Optional edge labels\r\n\t */\r\n\tedgeLabels?: string[][];\r\n}\r\n\r\nexport function symmetricGraphToDIMACS(graph: Graph): string {\r\n\tconst n = graph.adjacencyMatrix.length;\r\n\tlet edges: string[] = [];\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tfor (let j = i + 1; j < n; j++) {\r\n\t\t\tif (graph.adjacencyMatrix[i][j] !== 0) {\r\n\t\t\t\tedges.push(`e ${i + 1} ${j + 1}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn [`p edge ${n} ${edges.length}`, ...edges].join('\\n');\r\n}\r\n"],"names":["GraphMatcher","UllmannGraphMatcher","pattern","target","nodeLabelWildcards","edgeLabelWildcards","partialMapping","n","m","isLabeled","used","mapping","nodeLabelWildcardsSet","edgeLabelWildcardsSet","patternInDegrees","patternOutDegrees","targetInDegrees","targetOutDegrees","domains","pd","i","td","j","match","depth","candidate","r","b","row","_","a","results","isEdgeLabeled","Automorphism","mappings","__publicField","visited","keys","key","cycle","value","x","g","h","gx","fgx","k","v","AutomorphismGroup","generators","identity","orbit","aut","c","seen","orbits","orb","result","addIfUnvisited","queue","f","_GraphCanon","graph","nodeKeySuffixGenerator","nodePropertiesMapper","nodeLabelCanonKeyMapper","edgeLabelCanonKeyMapper","nodePropertiesCanonKeyMapper","isSymmetric","neighbors","inDegree","outDegree","isOut","isIn","nodeKey","nodeCells","partitions","prunedSubtrees","lexSmallestKey","partition","smallestRepresentation","lexSmallestMapping","lexSmallestGraph","allAutomorphisms","p","cellIds","repNodeCells","suffix","partitionKey","sameRepresentations","automorphismMap","partitionIndex","automorphism","propertyKeyNodeIndices","nextFreeCell","nodesInNextCell","handleRepresentation","cellToBreak","nodeId","newSuffix","isEquitable","signatures","edgeLabels","partitionMap","signature","nodeIndex","cell","cellMap","nodeIndices","cellId","blockKeys","newCellId","nodes","cells","nodeMapping","mi","edgeCallback","nodePropertyCallback","nodePropertyCanonKey","_graph","_i","nodeCallback","edges","_nodeMapping","sourceNodeIndex","targetNodeIndex","_nodeIndex","GraphCanon","ConnectedComponents","dfs","node","component","symmetricGraphToDIMACS"],"mappings":"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"}