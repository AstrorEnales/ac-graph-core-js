{"version":3,"file":"ac-graph-core-js.js","sources":["../src/graph/matching/GraphMatcher.ts","../src/graph/matching/UllmannGraphMatcher.ts","../src/graph/canon/GraphCanon.ts","../src/graph/ConnectedComponents.ts"],"sourcesContent":["import {Mapping} from '.';\nimport {Graph} from '..';\n\nexport abstract class GraphMatcher {\n\t/**\n\t * Subgraph isomorphism check\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic abstract isSubgraphIsomorphic(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[],\n\t\tedgeLabelWildcards: string[],\n\t\tpartialMapping: number[] | null\n\t): boolean;\n\n\t/**\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\n\t * including symmetries\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic abstract findAllSubgraphMonomorphisms(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[],\n\t\tedgeLabelWildcards: string[],\n\t\tpartialMapping: number[] | null\n\t): Mapping[];\n}\n","import {Mapping} from '.';\nimport {Graph} from '..';\nimport {GraphMatcher} from './GraphMatcher';\n\nexport class UllmannGraphMatcher extends GraphMatcher {\n\t/**\n\t * Subgraph isomorphism check\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic override isSubgraphIsomorphic(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[] = [],\n\t\tedgeLabelWildcards: string[] = [],\n\t\tpartialMapping: number[] | null = null\n\t): boolean {\n\t\t// Number of nodes in the pattern graph\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\t// Number of nodes in the target graph\n\t\tconst m = target.adjacencyMatrix.length;\n\t\t// If pattern is larger than target, no mapping is possible\n\t\tif (n > m) {\n\t\t\treturn false;\n\t\t}\n\t\tif (partialMapping === null) {\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\n\t\t}\n\t\tconst isLabeled = pattern.labels && target.labels;\n\t\t// Track which target nodes are already used in the mapping\n\t\tconst used = Array(m).fill(false);\n\t\tconst mapping = Array(n).fill(-1);\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\n\t\t// Pre-compute degrees for pattern and target nodes\n\t\tconst [\n\t\t\tpatternInDegrees,\n\t\t\tpatternOutDegrees,\n\t\t\ttargetInDegrees,\n\t\t\ttargetOutDegrees,\n\t\t] = this.getInOutDegrees(pattern, target);\n\t\t// Pre-compute candidate domains for pattern nodes based on degree\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\n\t\t\ttargetInDegrees\n\t\t\t\t.map((td, j) => {\n\t\t\t\t\treturn td >= pd &&\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\n\t\t\t\t\t\t(!isLabeled ||\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\n\t\t\t\t\t\t? j\n\t\t\t\t\t\t: -1;\n\t\t\t\t})\n\t\t\t\t.filter((j) => j !== -1)\n\t\t);\n\t\t// Recursive backtracking function to try all injective mappings\n\t\tconst match = (depth: number): boolean => {\n\t\t\tif (depth === n) {\n\t\t\t\treturn this.checkCompatibility(\n\t\t\t\t\tpattern,\n\t\t\t\t\ttarget,\n\t\t\t\t\tmapping,\n\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t);\n\t\t\t}\n\t\t\tfor (const candidate of domains[depth]) {\n\t\t\t\tif (!used[candidate]) {\n\t\t\t\t\tmapping[depth] = candidate;\n\t\t\t\t\tused[candidate] = true;\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.isFeasible(\n\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tmapping,\n\t\t\t\t\t\t\tdepth,\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t\t\t) &&\n\t\t\t\t\t\tmatch(depth + 1)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// Backtrack\n\t\t\t\t\tused[candidate] = false;\n\t\t\t\t\tmapping[depth] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\treturn match(0);\n\t}\n\n\tprivate getInOutDegrees(\n\t\tpattern: Graph,\n\t\ttarget: Graph\n\t): [number[], number[], number[], number[]] {\n\t\tconst patternInDegrees = pattern.adjacencyMatrix.map((r) =>\n\t\t\tr.reduce((a, b) => a + b, 0)\n\t\t);\n\t\tconst patternOutDegrees: number[] = [];\n\t\tconst targetInDegrees = target.adjacencyMatrix.map((r) =>\n\t\t\tr.reduce((a, b) => a + b, 0)\n\t\t);\n\t\tconst targetOutDegrees: number[] = [];\n\t\tpattern.adjacencyMatrix.forEach((row, i) => {\n\t\t\tpatternOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => pattern.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t});\n\t\ttarget.adjacencyMatrix.forEach((row, i) => {\n\t\t\ttargetOutDegrees.push(\n\t\t\t\trow\n\t\t\t\t\t.map((_, j) => target.adjacencyMatrix[j][i])\n\t\t\t\t\t.reduce((a, b) => a + b, 0)\n\t\t\t);\n\t\t});\n\t\treturn [\n\t\t\tpatternInDegrees,\n\t\t\tpatternOutDegrees,\n\t\t\ttargetInDegrees,\n\t\t\ttargetOutDegrees,\n\t\t];\n\t}\n\n\t/**\n\t * Collect all possible monomorphisms of the pattern graph in the target graph\n\t * including symmetries\n\t * @param pattern Pattern graph adjacency matrix\n\t * @param target Target graph adjacency matrix\n\t * @param nodeLabelWildcards Indices of pattern nodes considered wildcards\n\t * for labelled graphs. Their label is ignored during validation.\n\t * @param edgeLabelWildcards Indices of pattern edges considered wildcards\n\t * for labelled graphs. Their label is ignored during validation. Encoded\n\t * as \"sourceIndex + ',' + targetIndex\".\n\t * @param partialMapping Partial mapping of pattern nodes in target to only\n\t * find solutions containing this mapping. The array needs to follow the\n\t * same format as the Mapping type. Nodes not fixed in the partial mapping\n\t * are represented by -1.\n\t */\n\tpublic override findAllSubgraphMonomorphisms(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tnodeLabelWildcards: number[] = [],\n\t\tedgeLabelWildcards: string[] = [],\n\t\tpartialMapping: number[] | null = null\n\t): Mapping[] {\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\tconst m = target.adjacencyMatrix.length;\n\t\tconst results: Mapping[] = [];\n\t\tconst nodeLabelWildcardsSet = new Set(nodeLabelWildcards);\n\t\tconst edgeLabelWildcardsSet = new Set(edgeLabelWildcards);\n\t\tif (n > m) {\n\t\t\treturn results;\n\t\t}\n\t\tif (partialMapping === null) {\n\t\t\tpartialMapping = new Array<number>(n).fill(-1);\n\t\t}\n\t\tconst isLabeled = pattern.labels && target.labels;\n\t\tconst used = Array(m).fill(false);\n\t\tconst mapping = Array(n).fill(-1);\n\t\tconst [\n\t\t\tpatternInDegrees,\n\t\t\tpatternOutDegrees,\n\t\t\ttargetInDegrees,\n\t\t\ttargetOutDegrees,\n\t\t] = this.getInOutDegrees(pattern, target);\n\t\tconst domains: number[][] = patternInDegrees.map((pd, i) =>\n\t\t\ttargetInDegrees\n\t\t\t\t.map((td, j) => {\n\t\t\t\t\treturn td >= pd &&\n\t\t\t\t\t\ttargetOutDegrees[j] >= patternOutDegrees[i] &&\n\t\t\t\t\t\t(partialMapping[i] === -1 || partialMapping[i] === j) &&\n\t\t\t\t\t\t(!isLabeled ||\n\t\t\t\t\t\t\tnodeLabelWildcardsSet.has(i) ||\n\t\t\t\t\t\t\tpattern.labels![i] === target.labels![j])\n\t\t\t\t\t\t? j\n\t\t\t\t\t\t: -1;\n\t\t\t\t})\n\t\t\t\t.filter((j) => j !== -1)\n\t\t);\n\t\tconst match = (depth: number): void => {\n\t\t\tif (depth === n) {\n\t\t\t\tif (\n\t\t\t\t\tthis.checkCompatibility(\n\t\t\t\t\t\tpattern,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tmapping,\n\t\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tresults.push([...mapping]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (const candidate of domains[depth]) {\n\t\t\t\tif (!used[candidate]) {\n\t\t\t\t\tmapping[depth] = candidate;\n\t\t\t\t\tused[candidate] = true;\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.isFeasible(\n\t\t\t\t\t\t\tpattern,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tmapping,\n\t\t\t\t\t\t\tdepth,\n\t\t\t\t\t\t\tedgeLabelWildcardsSet\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tmatch(depth + 1);\n\t\t\t\t\t}\n\t\t\t\t\tused[candidate] = false;\n\t\t\t\t\tmapping[depth] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmatch(0);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Feasibility check for current depth: preserve pattern edges\n\t * and edge labels if present\n\t */\n\tprivate isFeasible(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tmapping: Mapping,\n\t\tdepth: number,\n\t\tedgeLabelWildcardsSet: Set<string>\n\t): boolean {\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\n\t\t// Check that all edges in the current partial mapping are preserved\n\t\tfor (let i = 0; i < depth; i++) {\n\t\t\tif (pattern.adjacencyMatrix[depth][i]) {\n\t\t\t\tif (!target.adjacencyMatrix[mapping[depth]][mapping[i]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check edge labels if present\n\t\t\t\tif (\n\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t!edgeLabelWildcardsSet.has(depth + ',' + i) &&\n\t\t\t\t\tpattern.edgeLabels![depth][i] !==\n\t\t\t\t\t\ttarget.edgeLabels![mapping[depth]][mapping[i]]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pattern.adjacencyMatrix[i][depth]) {\n\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[depth]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check edge labels if present\n\t\t\t\tif (\n\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + depth) &&\n\t\t\t\t\tpattern.edgeLabels![i][depth] !==\n\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[depth]]\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Verifies full structural consistency of the mapping\n\t */\n\tprivate checkCompatibility(\n\t\tpattern: Graph,\n\t\ttarget: Graph,\n\t\tmapping: Mapping,\n\t\tedgeLabelWildcardsSet: Set<string>\n\t): boolean {\n\t\tconst isEdgeLabeled = pattern.edgeLabels && target.edgeLabels;\n\t\tconst n = pattern.adjacencyMatrix.length;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tfor (let j = 0; j < n; j++) {\n\t\t\t\tif (pattern.adjacencyMatrix[i][j]) {\n\t\t\t\t\tif (!target.adjacencyMatrix[mapping[i]][mapping[j]]) {\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tisEdgeLabeled &&\n\t\t\t\t\t\t!edgeLabelWildcardsSet.has(i + ',' + j) &&\n\t\t\t\t\t\tpattern.edgeLabels![i][j] !==\n\t\t\t\t\t\t\ttarget.edgeLabels![mapping[i]][mapping[j]]\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Mapped nodes don't preserve an edge label\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n","import {Graph} from '..';\r\nimport {Mapping} from '../matching';\r\n\r\n/**\r\n * Nauty graph canonicalization using the following graph properties\r\n * for ordering and selection:\r\n * - First, node cell membership is sorted ascending by \"outDegree|inDegree|label?\"\r\n * - Second, direct neighborhood cell memberships and optional edge labels are sorted\r\n *   ascending, concatenated, and used to further split cells.\r\n *   \"neighborCell_1;outEdgeLabel_1?;inEdgeLabel_1?|neighborCell_2;outEdgeLabel_2?;inEdgeLabel_2?|...\"\r\n *   New cell IDs of the split are assigned by descending key order.\r\n * - Target cell selection in the search tree is performed by selecting the leftmost (smallest) cell ID\r\n *   with at least two members.\r\n *\r\n * TODO:\r\n * - Automorphism detection\r\n * - Search tree pruning\r\n */\r\nexport class GraphCanon {\r\n\tpublic static readonly DefaultNodeKeySuffixGenerator = (\r\n\t\tgraph: Graph,\r\n\t\tnodeIndex: number\r\n\t): string => {\r\n\t\treturn graph.labels ? graph.labels[nodeIndex] : '';\r\n\t};\r\n\r\n\tprivate readonly nodeCount: number;\r\n\tprivate readonly hasNodeLabels: boolean;\r\n\tprivate readonly hasEdgeLabels: boolean;\r\n\tprivate readonly graph: Graph;\r\n\tprivate readonly nodeNeighbors = new Map<number, number[]>();\r\n\tprivate readonly nodeKeys = new Map<number, string>();\r\n\tprivate readonly inDegrees = new Map<number, number>();\r\n\tprivate readonly outDegrees = new Map<number, number>();\r\n\r\n\tpublic constructor(\r\n\t\tgraph: Graph,\r\n\t\tnodeKeySuffixGenerator: {\r\n\t\t\t(graph: Graph, nodeIndex: number): string;\r\n\t\t} = GraphCanon.DefaultNodeKeySuffixGenerator\r\n\t) {\r\n\t\tthis.graph = graph;\r\n\t\tthis.nodeCount = graph.adjacencyMatrix.length;\r\n\t\tthis.hasNodeLabels = graph.labels !== undefined;\r\n\t\tthis.hasEdgeLabels = graph.edgeLabels !== undefined;\r\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\tconst neighbors = new Set<number>();\r\n\t\t\tlet inDegree = 0;\r\n\t\t\tlet outDegree = 0;\r\n\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\tif (graph.adjacencyMatrix[i][j] === 1) {\r\n\t\t\t\t\toutDegree++;\r\n\t\t\t\t\tneighbors.add(j);\r\n\t\t\t\t}\r\n\t\t\t\tif (graph.adjacencyMatrix[j][i] === 1) {\r\n\t\t\t\t\tinDegree++;\r\n\t\t\t\t\tneighbors.add(j);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.inDegrees.set(i, inDegree);\r\n\t\t\tthis.outDegrees.set(i, outDegree);\r\n\t\t\tthis.nodeNeighbors.set(i, [...neighbors]);\r\n\t\t\tconst nodeKey =\r\n\t\t\t\toutDegree + '|' + inDegree + nodeKeySuffixGenerator(graph, i);\r\n\t\t\tthis.nodeKeys.set(i, nodeKey);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic canonicalize(): [Graph, string, Mapping] {\r\n\t\tconst nodeCells = new Array(this.nodeCount).fill(1);\r\n\t\tthis.partitionByPropertyKeys(nodeCells);\r\n\t\tlet lexSmallestGraph: Graph | null = null;\r\n\t\tlet lexSmallestMapping: Mapping | null = null;\r\n\t\tlet lexSmallestGraphString: string | null = null;\r\n\t\tthis.individualizeDFS(nodeCells, [], (repNodeCells, _repSuffix) => {\r\n\t\t\t// TODO: find automorphisms and prune search tree\r\n\t\t\tconst repGraph = this.buildRepresentationGraph(repNodeCells);\r\n\t\t\tconst repGraphString = this.buildGraphString(repGraph);\r\n\t\t\tif (\r\n\t\t\t\tlexSmallestGraphString === null ||\r\n\t\t\t\trepGraphString.localeCompare(lexSmallestGraphString) < 0\r\n\t\t\t) {\r\n\t\t\t\tlexSmallestGraph = repGraph;\r\n\t\t\t\tlexSmallestMapping = new Array(repNodeCells.length);\r\n\t\t\t\trepNodeCells.forEach((cell, i) => (lexSmallestMapping![cell - 1] = i));\r\n\t\t\t\tlexSmallestGraphString = repGraphString;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn [lexSmallestGraph!, lexSmallestGraphString!, lexSmallestMapping!];\r\n\t}\r\n\r\n\tprivate partitionByPropertyKeys(nodeCells: number[]) {\r\n\t\tconst propertyKeyNodeIndices = new Map<string, number[]>();\r\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\tconst key = this.nodeKeys.get(i)!;\r\n\t\t\tif (propertyKeyNodeIndices.has(key)) {\r\n\t\t\t\tpropertyKeyNodeIndices.get(key)!.push(i);\r\n\t\t\t} else {\r\n\t\t\t\tpropertyKeyNodeIndices.set(key, [i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet nextFreeCell = 1;\r\n\t\tArray.from(propertyKeyNodeIndices.keys())\r\n\t\t\t.sort((a, b) => a.localeCompare(b))\r\n\t\t\t.forEach((k) => {\r\n\t\t\t\tconst nodesInNextCell = propertyKeyNodeIndices.get(k)!;\r\n\t\t\t\tnodesInNextCell.forEach((i) => (nodeCells[i] = nextFreeCell));\r\n\t\t\t\tnextFreeCell += nodesInNextCell.length;\r\n\t\t\t});\r\n\t}\r\n\r\n\tprivate isCanon(nodeCells: number[]): boolean {\r\n\t\treturn new Set<number>(nodeCells).size === this.nodeCount;\r\n\t}\r\n\r\n\tprivate individualizeDFS(\r\n\t\tnodeCells: number[],\r\n\t\tsuffix: number[],\r\n\t\thandleRepresentation: (nodeCells: number[], suffix: number[]) => void\r\n\t) {\r\n\t\tif (this.isCanon(nodeCells)) {\r\n\t\t\thandleRepresentation(nodeCells, suffix);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.individualizationRefinement(nodeCells);\r\n\t\tif (this.isCanon(nodeCells)) {\r\n\t\t\thandleRepresentation(nodeCells, suffix);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst cells = this.getCurrentCells(nodeCells);\r\n\t\tconst cellToBreak = Array.from(cells.entries())\r\n\t\t\t.sort(([a], [b]) => a - b)\r\n\t\t\t.filter(([, nodes]) => nodes.length > 1)[0];\r\n\t\tfor (const nodeId of cellToBreak[1]) {\r\n\t\t\tconst newNodeCells = [...nodeCells];\r\n\t\t\tcellToBreak[1].forEach((n) => {\r\n\t\t\t\tif (n !== nodeId) {\r\n\t\t\t\t\tnewNodeCells[n] = cellToBreak[0] + 1;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tthis.individualizeDFS(\r\n\t\t\t\tnewNodeCells,\r\n\t\t\t\t[...suffix, nodeId],\r\n\t\t\t\thandleRepresentation\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate individualizationRefinement(nodeCells: number[]) {\r\n\t\tlet isEquitable = false;\r\n\t\twhile (!isEquitable) {\r\n\t\t\tisEquitable = true;\r\n\t\t\t// Build signature for each node\r\n\t\t\tconst signatures: [string, number][] = nodeCells.map((_, i) => {\r\n\t\t\t\tconst neighborCells = this.nodeNeighbors.get(i)!.map((n) => {\r\n\t\t\t\t\tlet cellInfo = nodeCells[n].toString();\r\n\t\t\t\t\tif (this.hasEdgeLabels) {\r\n\t\t\t\t\t\tcellInfo +=\r\n\t\t\t\t\t\t\t';' +\r\n\t\t\t\t\t\t\tthis.graph.edgeLabels![i][n] +\r\n\t\t\t\t\t\t\t';' +\r\n\t\t\t\t\t\t\tthis.graph.edgeLabels![n][i];\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn cellInfo;\r\n\t\t\t\t});\r\n\t\t\t\tconst signature = neighborCells.sort().join('|');\r\n\t\t\t\treturn [signature, i];\r\n\t\t\t});\r\n\t\t\t// Group by current cell and signature\r\n\t\t\tconst partitionMap = new Map<number, Map<string, number[]>>();\r\n\t\t\tfor (const [signature, nodeIndex] of signatures) {\r\n\t\t\t\tconst cell = nodeCells[nodeIndex];\r\n\t\t\t\tif (!partitionMap.has(cell)) {\r\n\t\t\t\t\tpartitionMap.set(cell, new Map());\r\n\t\t\t\t}\r\n\t\t\t\tconst cellMap = partitionMap.get(cell)!;\r\n\t\t\t\tif (!cellMap.has(signature)) {\r\n\t\t\t\t\tcellMap.set(signature, []);\r\n\t\t\t\t}\r\n\t\t\t\tcellMap.get(signature)!.push(nodeIndex);\r\n\t\t\t}\r\n\t\t\t// Partition cells based on signature blocks\r\n\t\t\tconst cellIds = Array.from(partitionMap.keys()).sort();\r\n\t\t\tfor (const cellId of cellIds) {\r\n\t\t\t\tconst blocks = Array.from(partitionMap.get(cellId)!.entries());\r\n\t\t\t\tif (blocks.length > 1) {\r\n\t\t\t\t\tisEquitable = false;\r\n\t\t\t\t\t// Sort block signatures descending\r\n\t\t\t\t\tblocks.sort(([sigA], [sigB]) => sigB.localeCompare(sigA));\r\n\t\t\t\t\tlet newCellId = cellId;\r\n\t\t\t\t\tblocks.forEach(([, nodes]) => {\r\n\t\t\t\t\t\tnodes.forEach((n) => (nodeCells[n] = newCellId));\r\n\t\t\t\t\t\tnewCellId += nodes.length;\r\n\t\t\t\t\t});\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate getCurrentCells(nodeCells: number[]): Map<number, number[]> {\r\n\t\tconst cells = new Map<number, number[]>();\r\n\t\tnodeCells.forEach((c, i) => {\r\n\t\t\tif (cells.has(c)) {\r\n\t\t\t\tcells.get(c)!.push(i);\r\n\t\t\t} else {\r\n\t\t\t\tcells.set(c, [i]);\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn cells;\r\n\t}\r\n\r\n\t/*private getCellsString(nodeCells: number[]): string {\r\n\t\tconst cells = this.getCurrentCells(nodeCells);\r\n\t\tconst cellIds = Array.from(cells.keys()).sort();\r\n\t\tlet text = '[';\r\n\t\tfor (const cellId of cellIds) {\r\n\t\t\tconst nodeIds = Array.from(cells.get(cellId)!.values()).sort();\r\n\t\t\tif (text.length > 1) {\r\n\t\t\t\ttext += '|';\r\n\t\t\t}\r\n\t\t\ttext += nodeIds.join(' ');\r\n\t\t}\r\n\t\treturn text + ']';\r\n\t}*/\r\n\r\n\tprivate buildRepresentationGraph(nodeCells: number[]): Graph {\r\n\t\tconst graph: Graph = {\r\n\t\t\tadjacencyMatrix: Array.from(\r\n\t\t\t\t{length: this.nodeCount},\r\n\t\t\t\t() => new Array(this.nodeCount)\r\n\t\t\t),\r\n\t\t};\r\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\tgraph.adjacencyMatrix[nodeCells[i] - 1][nodeCells[j] - 1] =\r\n\t\t\t\t\tthis.graph.adjacencyMatrix[i][j];\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this.hasNodeLabels) {\r\n\t\t\tgraph.labels = new Array(this.nodeCount);\r\n\t\t\tnodeCells.forEach(\r\n\t\t\t\t(c, i) => (graph.labels![c - 1] = this.graph.labels![i])\r\n\t\t\t);\r\n\t\t}\r\n\t\tif (this.hasEdgeLabels) {\r\n\t\t\tgraph.edgeLabels = Array.from(\r\n\t\t\t\t{length: this.nodeCount},\r\n\t\t\t\t() => new Array(this.nodeCount)\r\n\t\t\t);\r\n\t\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\t\tgraph.edgeLabels[nodeCells[i] - 1][nodeCells[j] - 1] =\r\n\t\t\t\t\t\tthis.graph.edgeLabels![i][j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn graph;\r\n\t}\r\n\r\n\tpublic buildGraphString(graph: Graph): string {\r\n\t\tconst edges: string[] = [];\r\n\t\tfor (let i = 0; i < this.nodeCount; i++) {\r\n\t\t\tfor (let j = 0; j < this.nodeCount; j++) {\r\n\t\t\t\tif (graph.adjacencyMatrix[i][j] === 1) {\r\n\t\t\t\t\tif (this.hasEdgeLabels) {\r\n\t\t\t\t\t\tedges.push(i + '-' + graph.edgeLabels![i][j] + '-' + j);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tedges.push(i + '-' + j);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this.hasNodeLabels) {\r\n\t\t\treturn edges.join('|') + ';' + graph.labels!.join('|');\r\n\t\t}\r\n\t\treturn edges.join('|');\r\n\t}\r\n}\r\n","import {Graph} from '.';\r\n\r\nexport class ConnectedComponents {\r\n\tpublic static find(graph: Graph): number[][] {\r\n\t\tconst result: number[][] = [];\r\n\t\tconst visited = new Set<number>();\r\n\r\n\t\tconst dfs = (node: number, component: number[]) => {\r\n\t\t\tvisited.add(node);\r\n\t\t\tcomponent.push(node);\r\n\t\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tgraph.adjacencyMatrix[node][i] === 1 ||\r\n\t\t\t\t\tgraph.adjacencyMatrix[i][node] === 1\r\n\t\t\t\t) {\r\n\t\t\t\t\tif (!visited.has(i)) {\r\n\t\t\t\t\t\tdfs(i, component);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfor (let i = 0; i < graph.adjacencyMatrix.length; i++) {\r\n\t\t\tif (!visited.has(i)) {\r\n\t\t\t\tconst component: number[] = [];\r\n\t\t\t\tdfs(i, component);\r\n\t\t\t\tresult.push(component);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n"],"names":["GraphMatcher","UllmannGraphMatcher","pattern","target","nodeLabelWildcards","edgeLabelWildcards","partialMapping","n","m","isLabeled","used","mapping","nodeLabelWildcardsSet","edgeLabelWildcardsSet","patternInDegrees","patternOutDegrees","targetInDegrees","targetOutDegrees","domains","pd","i","td","j","match","depth","candidate","a","b","row","_","results","isEdgeLabeled","_GraphCanon","graph","nodeKeySuffixGenerator","__publicField","neighbors","inDegree","outDegree","nodeKey","nodeCells","lexSmallestGraph","lexSmallestMapping","lexSmallestGraphString","repNodeCells","_repSuffix","repGraph","repGraphString","cell","propertyKeyNodeIndices","key","nextFreeCell","k","nodesInNextCell","suffix","handleRepresentation","cells","cellToBreak","nodes","nodeId","newNodeCells","isEquitable","signatures","cellInfo","partitionMap","signature","nodeIndex","cellMap","cellIds","cellId","blocks","sigA","sigB","newCellId","c","edges","GraphCanon","ConnectedComponents","result","visited","dfs","node","component"],"mappings":"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"}